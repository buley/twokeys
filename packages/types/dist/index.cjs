'use strict';var zod=require('zod');var c=zod.z.object({data:zod.z.array(zod.z.number()).optional()}),y=zod.z.object({data:zod.z.array(zod.z.array(zod.z.number())).optional(),dimensionality:zod.z.number().int().positive().optional(),count:zod.z.number().int().positive().optional()}),t=zod.z.object({datum:zod.z.number(),depth:zod.z.number()}),a=zod.z.object({count:zod.z.number().int().nonnegative(),data:zod.z.array(zod.z.number())}),n=zod.z.object({rank:zod.z.number().int().positive(),peers:zod.z.number().int().nonnegative()}),r=zod.z.object({up:zod.z.record(zod.z.string(),n),down:zod.z.record(zod.z.string(),n),groups:zod.z.object({up:zod.z.array(zod.z.union([zod.z.number(),zod.z.array(zod.z.number())])),down:zod.z.array(zod.z.union([zod.z.number(),zod.z.array(zod.z.number())]))})}),o=zod.z.object({from:zod.z.number(),to:zod.z.number(),data:zod.z.array(zod.z.number())}),m=zod.z.object({bins:zod.z.number().int().nonnegative(),width:zod.z.number(),binned:zod.z.record(zod.z.string(),o)}),p=zod.z.object({median:t,mean:zod.z.number(),mode:a,hinges:zod.z.array(t),adjacent:zod.z.array(zod.z.number()),outliers:zod.z.array(zod.z.number()),outer:zod.z.array(zod.z.number()),outside:zod.z.array(zod.z.number()),inside:zod.z.array(zod.z.number()),extremes:zod.z.array(zod.z.number()),iqr:zod.z.number(),fences:zod.z.array(zod.z.number())}),i=zod.z.object({smooth:zod.z.array(zod.z.number()),hanning:zod.z.array(zod.z.number())}),s=zod.z.object({logs:zod.z.array(zod.z.number()),roots:zod.z.array(zod.z.number()),inverse:zod.z.array(zod.z.number())}),b=zod.z.object({original:zod.z.array(zod.z.number()),summary:p,smooths:i,transforms:s,counts:zod.z.array(zod.z.tuple([zod.z.number(),zod.z.number()])),sorted:zod.z.array(zod.z.number()),ranked:r,binned:m}),h=zod.z.object({original:zod.z.array(zod.z.array(zod.z.number()))}),S=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element")}),f=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element")}),d=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element")}),l=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element")}),x=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element")}),I=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element")}),z=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element")}),j=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element")}),R=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element"),bins:zod.z.number().int().positive().optional()}),v=zod.z.object({data:zod.z.array(zod.z.number()).min(3,"Smoothing requires at least 3 data points")}),D=zod.z.object({data:zod.z.array(zod.z.number()).min(1,"Data array must have at least one element"),type:zod.z.enum(["log","sqrt","inverse"])});Object.defineProperty(exports,"z",{enumerable:true,get:function(){return zod.z}});exports.AnalyzeInputSchema=S;exports.BinDataSchema=o;exports.BinnedInputSchema=R;exports.BinnedResultSchema=m;exports.FencesInputSchema=I;exports.HingesInputSchema=z;exports.MeanInputSchema=d;exports.MedianInputSchema=f;exports.MedianResultSchema=t;exports.ModeInputSchema=l;exports.ModeResultSchema=a;exports.OutliersInputSchema=x;exports.PointsDescriptionSchema=h;exports.PointsOptionsSchema=y;exports.RankInfoSchema=n;exports.RankedInputSchema=j;exports.RankedResultSchema=r;exports.SeriesDescriptionSchema=b;exports.SeriesOptionsSchema=c;exports.SeriesSummarySchema=p;exports.SmoothInputSchema=v;exports.SmoothsSchema=i;exports.TransformInputSchema=D;exports.TransformsSchema=s;//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map