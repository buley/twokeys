import {z as z$1}from'zod';export{z}from'zod';var c=z$1.object({data:z$1.array(z$1.number()).optional()}),y=z$1.object({data:z$1.array(z$1.array(z$1.number())).optional(),dimensionality:z$1.number().int().positive().optional(),count:z$1.number().int().positive().optional()}),t=z$1.object({datum:z$1.number(),depth:z$1.number()}),a=z$1.object({count:z$1.number().int().nonnegative(),data:z$1.array(z$1.number())}),n=z$1.object({rank:z$1.number().int().positive(),peers:z$1.number().int().nonnegative()}),r=z$1.object({up:z$1.record(z$1.string(),n),down:z$1.record(z$1.string(),n),groups:z$1.object({up:z$1.array(z$1.union([z$1.number(),z$1.array(z$1.number())])),down:z$1.array(z$1.union([z$1.number(),z$1.array(z$1.number())]))})}),o=z$1.object({from:z$1.number(),to:z$1.number(),data:z$1.array(z$1.number())}),m=z$1.object({bins:z$1.number().int().nonnegative(),width:z$1.number(),binned:z$1.record(z$1.string(),o)}),p=z$1.object({median:t,mean:z$1.number(),mode:a,hinges:z$1.array(t),adjacent:z$1.array(z$1.number()),outliers:z$1.array(z$1.number()),outer:z$1.array(z$1.number()),outside:z$1.array(z$1.number()),inside:z$1.array(z$1.number()),extremes:z$1.array(z$1.number()),iqr:z$1.number(),fences:z$1.array(z$1.number())}),i=z$1.object({smooth:z$1.array(z$1.number()),hanning:z$1.array(z$1.number())}),s=z$1.object({logs:z$1.array(z$1.number()),roots:z$1.array(z$1.number()),inverse:z$1.array(z$1.number())}),b=z$1.object({original:z$1.array(z$1.number()),summary:p,smooths:i,transforms:s,counts:z$1.array(z$1.tuple([z$1.number(),z$1.number()])),sorted:z$1.array(z$1.number()),ranked:r,binned:m}),h=z$1.object({original:z$1.array(z$1.array(z$1.number()))}),S=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element")}),f=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element")}),d=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element")}),l=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element")}),x=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element")}),I=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element")}),z=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element")}),j=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element")}),R=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element"),bins:z$1.number().int().positive().optional()}),v=z$1.object({data:z$1.array(z$1.number()).min(3,"Smoothing requires at least 3 data points")}),D=z$1.object({data:z$1.array(z$1.number()).min(1,"Data array must have at least one element"),type:z$1.enum(["log","sqrt","inverse"])});export{S as AnalyzeInputSchema,o as BinDataSchema,R as BinnedInputSchema,m as BinnedResultSchema,I as FencesInputSchema,z as HingesInputSchema,d as MeanInputSchema,f as MedianInputSchema,t as MedianResultSchema,l as ModeInputSchema,a as ModeResultSchema,x as OutliersInputSchema,h as PointsDescriptionSchema,y as PointsOptionsSchema,n as RankInfoSchema,j as RankedInputSchema,r as RankedResultSchema,b as SeriesDescriptionSchema,c as SeriesOptionsSchema,p as SeriesSummarySchema,v as SmoothInputSchema,i as SmoothsSchema,D as TransformInputSchema,s as TransformsSchema};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map