{"version":3,"sources":["../src/index.ts"],"names":["SeriesOptionsSchema","z","PointsOptionsSchema","MedianResultSchema","ModeResultSchema","RankInfoSchema","RankedResultSchema","BinDataSchema","BinnedResultSchema","SeriesSummarySchema","SmoothsSchema","TransformsSchema","SeriesDescriptionSchema","PointsDescriptionSchema","AnalyzeInputSchema","MedianInputSchema","MeanInputSchema","ModeInputSchema","OutliersInputSchema","FencesInputSchema","HingesInputSchema","RankedInputSchema","BinnedInputSchema","SmoothInputSchema","TransformInputSchema"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * @twokeys/types - Shared Zod schemas for Twokeys ecosystem\n *\n * Provides runtime validation and TypeScript types for all Twokeys data structures.\n */\n\nimport { z } from 'zod';\n\n// =============================================================================\n// Series Options\n// =============================================================================\n\nexport const SeriesOptionsSchema = z.object({\n  data: z.array(z.number()).optional(),\n});\nexport type SeriesOptions = z.infer<typeof SeriesOptionsSchema>;\n\n// =============================================================================\n// Points Options\n// =============================================================================\n\nexport const PointsOptionsSchema = z.object({\n  data: z.array(z.array(z.number())).optional(),\n  dimensionality: z.number().int().positive().optional(),\n  count: z.number().int().positive().optional(),\n});\nexport type PointsOptions = z.infer<typeof PointsOptionsSchema>;\n\n// =============================================================================\n// Median Result\n// =============================================================================\n\nexport const MedianResultSchema = z.object({\n  datum: z.number(),\n  depth: z.number(),\n});\nexport type MedianResult = z.infer<typeof MedianResultSchema>;\n\n// =============================================================================\n// Mode Result\n// =============================================================================\n\nexport const ModeResultSchema = z.object({\n  count: z.number().int().nonnegative(),\n  data: z.array(z.number()),\n});\nexport type ModeResult = z.infer<typeof ModeResultSchema>;\n\n// =============================================================================\n// Rank Info\n// =============================================================================\n\nexport const RankInfoSchema = z.object({\n  rank: z.number().int().positive(),\n  peers: z.number().int().nonnegative(),\n});\nexport type RankInfo = z.infer<typeof RankInfoSchema>;\n\n// =============================================================================\n// Ranked Result\n// =============================================================================\n\nexport const RankedResultSchema = z.object({\n  up: z.record(z.string(), RankInfoSchema),\n  down: z.record(z.string(), RankInfoSchema),\n  groups: z.object({\n    up: z.array(z.union([z.number(), z.array(z.number())])),\n    down: z.array(z.union([z.number(), z.array(z.number())])),\n  }),\n});\nexport type RankedResult = z.infer<typeof RankedResultSchema>;\n\n// =============================================================================\n// Binned Result\n// =============================================================================\n\nexport const BinDataSchema = z.object({\n  from: z.number(),\n  to: z.number(),\n  data: z.array(z.number()),\n});\nexport type BinData = z.infer<typeof BinDataSchema>;\n\nexport const BinnedResultSchema = z.object({\n  bins: z.number().int().nonnegative(),\n  width: z.number(),\n  binned: z.record(z.string(), BinDataSchema),\n});\nexport type BinnedResult = z.infer<typeof BinnedResultSchema>;\n\n// =============================================================================\n// Series Summary\n// =============================================================================\n\nexport const SeriesSummarySchema = z.object({\n  median: MedianResultSchema,\n  mean: z.number(),\n  mode: ModeResultSchema,\n  hinges: z.array(MedianResultSchema),\n  adjacent: z.array(z.number()),\n  outliers: z.array(z.number()),\n  outer: z.array(z.number()),\n  outside: z.array(z.number()),\n  inside: z.array(z.number()),\n  extremes: z.array(z.number()),\n  iqr: z.number(),\n  fences: z.array(z.number()),\n});\nexport type SeriesSummary = z.infer<typeof SeriesSummarySchema>;\n\n// =============================================================================\n// Smooths\n// =============================================================================\n\nexport const SmoothsSchema = z.object({\n  smooth: z.array(z.number()),\n  hanning: z.array(z.number()),\n});\nexport type Smooths = z.infer<typeof SmoothsSchema>;\n\n// =============================================================================\n// Transforms\n// =============================================================================\n\nexport const TransformsSchema = z.object({\n  logs: z.array(z.number()),\n  roots: z.array(z.number()),\n  inverse: z.array(z.number()),\n});\nexport type Transforms = z.infer<typeof TransformsSchema>;\n\n// =============================================================================\n// Series Description (full analysis)\n// =============================================================================\n\nexport const SeriesDescriptionSchema = z.object({\n  original: z.array(z.number()),\n  summary: SeriesSummarySchema,\n  smooths: SmoothsSchema,\n  transforms: TransformsSchema,\n  counts: z.array(z.tuple([z.number(), z.number()])),\n  sorted: z.array(z.number()),\n  ranked: RankedResultSchema,\n  binned: BinnedResultSchema,\n});\nexport type SeriesDescription = z.infer<typeof SeriesDescriptionSchema>;\n\n// =============================================================================\n// Points Description\n// =============================================================================\n\nexport const PointsDescriptionSchema = z.object({\n  original: z.array(z.array(z.number())),\n});\nexport type PointsDescription = z.infer<typeof PointsDescriptionSchema>;\n\n// =============================================================================\n// MCP Command Inputs\n// =============================================================================\n\nexport const AnalyzeInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n});\nexport type AnalyzeInput = z.infer<typeof AnalyzeInputSchema>;\n\nexport const MedianInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n});\nexport type MedianInput = z.infer<typeof MedianInputSchema>;\n\nexport const MeanInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n});\nexport type MeanInput = z.infer<typeof MeanInputSchema>;\n\nexport const ModeInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n});\nexport type ModeInput = z.infer<typeof ModeInputSchema>;\n\nexport const OutliersInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n});\nexport type OutliersInput = z.infer<typeof OutliersInputSchema>;\n\nexport const FencesInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n});\nexport type FencesInput = z.infer<typeof FencesInputSchema>;\n\nexport const HingesInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n});\nexport type HingesInput = z.infer<typeof HingesInputSchema>;\n\nexport const RankedInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n});\nexport type RankedInput = z.infer<typeof RankedInputSchema>;\n\nexport const BinnedInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n  bins: z.number().int().positive().optional(),\n});\nexport type BinnedInput = z.infer<typeof BinnedInputSchema>;\n\nexport const SmoothInputSchema = z.object({\n  data: z.array(z.number()).min(3, 'Smoothing requires at least 3 data points'),\n});\nexport type SmoothInput = z.infer<typeof SmoothInputSchema>;\n\nexport const TransformInputSchema = z.object({\n  data: z.array(z.number()).min(1, 'Data array must have at least one element'),\n  type: z.enum(['log', 'sqrt', 'inverse']),\n});\nexport type TransformInput = z.infer<typeof TransformInputSchema>;\n\n// =============================================================================\n// Re-export zod for convenience\n// =============================================================================\n\nexport { z };\n"]}