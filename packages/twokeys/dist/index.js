function re(c,n){let t=Math.min(c.length,n.length);if(t===0)return 0;let e=0,o=0,r=0;for(let a=0;a<t;a+=1){let s=c[a]??0,d=n[a]??0;e+=s*d,o+=s*s,r+=d*d;}let i=Math.sqrt(o)*Math.sqrt(r);return i===0?0:e/i}function q(c,n){let t=0,e=Math.max(c.length,n.length);for(let o=0;o<e;o+=1){let r=(c[o]??0)-(n[o]??0);t+=r*r;}return t}function U(c,n){return Math.sqrt(q(c,n))}function se(c,n){let t=0,e=Math.max(c.length,n.length);for(let o=0;o<e;o+=1)t+=Math.abs((c[o]??0)-(n[o]??0));return t}function it(c,n,t,e=1e-8){let o=Math.min(c.length,n.length,t.length);if(o===0)return 0;let r=0;for(let i=0;i<o;i+=1){let a=(c[i]??0)-(n[i]??0),s=Math.max(t[i]??0,e);r+=a*a/s;}return Math.sqrt(r)}function dt(c){let n=0;for(let e=0;e<c.length;e+=1){let o=c[e]??0;n+=o*o;}let t=Math.sqrt(n);return t===0?c.map(()=>0):c.map(e=>(e??0)/t)}function at(c,n){if(c.size===0||n.size===0)return 0;let t=0,e=0,o=0,[r,i]=c.size<=n.size?[c,n]:[n,c];for(let[s,d]of r){let u=i.get(s);u!==void 0&&(t+=d*u),e+=d*d;}for(let s of i.values())o+=s*s;let a=Math.sqrt(e)*Math.sqrt(o);return a===0?0:t/a}function ct(c,n){if(c.size===0||n.size===0)return 0;let t=0,[e,o]=c.size<=n.size?[c,n]:[n,c];for(let i of e)o.has(i)&&(t+=1);let r=c.size+n.size-t;return r<=0?0:t/r}function ut(c,n){if(c.size===0||n.size===0)return 0;let t=0,[e,o]=c.size<=n.size?[c,n]:[n,c];for(let i of e)o.has(i)&&(t+=1);let r=Math.min(c.size,n.size);return r<=0?0:t/r}var A=class extends Error{code;constructor(n,t){super(t),this.name="GraphAlgorithmError",this.code=n;}},W=class{heap=[];get size(){return this.heap.length}push(n,t){this.heap.push({priority:t,value:n}),this.siftUp(this.heap.length-1);}pop(){if(this.heap.length===0)return;let n=this.heap[0],t=this.heap.pop();return this.heap.length>0&&t&&(this.heap[0]=t,this.siftDown(0)),n}siftUp(n){let t=n;for(;t>0;){let e=Math.floor((t-1)/2),o=this.heap[t],r=this.heap[e];if(!o||!r||r.priority<=o.priority)return;this.heap[e]=o,this.heap[t]=r,t=e;}}siftDown(n){let t=n;for(;;){let e=t*2+1,o=t*2+2,r=t,i=this.heap[r],a=this.heap[e],s=this.heap[o];i&&a&&a.priority<i.priority&&(r=e);let d=this.heap[r];if(d&&s&&s.priority<d.priority&&(r=o),r===t)return;let u=this.heap[t],h=this.heap[r];if(!u||!h)return;this.heap[t]=h,this.heap[r]=u,t=r;}}};function R(c,n){return c.localeCompare(n)}function ee(c,n){return R(c,n)<=0?{from:c,to:n}:{from:n,to:c}}function $(c,n){let t=ee(c,n);return `${t.from}\0${t.to}`}function ke(c){return typeof c=="string"?c:c.id}var ie=class{parent=new Map;rank=new Map;constructor(n){for(let t of n)this.parent.set(t,t),this.rank.set(t,0);}find(n){let t=this.parent.get(n);if(!t||t===n)return n;let e=this.find(t);return this.parent.set(n,e),e}union(n,t){let e=this.find(n),o=this.find(t);if(e===o)return  false;let r=this.rank.get(e)??0,i=this.rank.get(o)??0;return r<i?(this.parent.set(e,o),true):r>i?(this.parent.set(o,e),true):(this.parent.set(o,e),this.rank.set(e,r+1),true)}};function te(c,n){let t=new Set,e=[];for(let o of c){let r=ke(o);t.has(r)||(t.add(r),e.push(r));}for(let o of n)t.has(o.from)||(t.add(o.from),e.push(o.from)),t.has(o.to)||(t.add(o.to),e.push(o.to));return e}function Ge(c){if(c===void 0)return 1;if(!Number.isFinite(c))throw new A("INVALID_ARGUMENT",`Graph edge weight must be finite, received ${c}`);return c}function Ce(c){let n=new Map;for(let t of c)n.set(t,new Map);return n}function Ne(c,n,t,e){let o=c.get(n);if(!o)return;let r=o.get(t);(r===void 0||e<r)&&o.set(t,e);}function De(c,n,t){let e=Ce(c);for(let o of n){if(o.from===o.to)continue;let r=Ge(o.weight);!e.has(o.from)||!e.has(o.to)||(Ne(e,o.from,o.to,r),t||Ne(e,o.to,o.from,r));}return e}function Pe(c){let n=new Map;for(let[t,e]of c.entries()){let o=[];for(let[r,i]of e.entries())o.push({id:r,weight:i});n.set(t,o);}return n}function Fe(c,n){let t=new Map;for(let e of c)t.set(e,[]);for(let[e,o]of n.entries())for(let r of o){let i=t.get(r.id);i&&i.push({id:e,weight:r.weight});}return t}function Oe(c){let n=[];for(let[t,e]of c.entries())for(let o of e)n.push({from:t,to:o.id,weight:o.weight});return n}function F(c){for(let n of c.edges)if(n.weight<0)return  true;return  false}function ce(c,n,t){if(c===n)return [c];let e=[n],o=n;for(;o&&o!==c;){let r=t.get(o);if(!r)return [];e.push(r),o=r;}return e.reverse(),e[0]===c?e:[]}function pe(c){return c.reduce((n,t)=>n+t.weight,0)}function Be(c){let n=new Map;for(let t of c.edges){let e=ee(t.from,t.to),o=$(e.from,e.to),r=n.get(o);(!r||t.weight<r.weight-1e-12)&&n.set(o,{from:e.from,to:e.to,weight:t.weight});}return Array.from(n.values())}function _e(c,n){let t=Be(c),e=0;for(let s of t)e+=s.weight;if(!Number.isFinite(e)||e<=0)return 0;let o=new Map;for(let s of c.nodes)o.set(s,pe(c.neighborsByNode.get(s)??[]));let r=new Map,i=new Map;for(let s of c.nodes){let d=n.get(s);if(d===void 0)continue;let u=o.get(s)??0;r.set(d,(r.get(d)??0)+u);}for(let s of t){let d=n.get(s.from),u=n.get(s.to);d===void 0||u===void 0||d===u&&i.set(d,(i.get(d)??0)+s.weight);}let a=0;for(let[s,d]of r.entries()){let u=i.get(s)??0;a+=u/e-Math.pow(d/(2*e),2);}return a}function de(c,n,t,e,o){let r=new Map;for(let s of c.nodes){let d=n.get(s);if(d===void 0)continue;let u=r.get(d)??[];u.push(s),r.set(d,u);}let i=Array.from(r.values()).map(s=>[...s].sort(R));i.sort((s,d)=>R(s[0]??"",d[0]??""));let a=new Map;for(let s=0;s<i.length;s+=1)for(let d of i[s]??[])a.set(d,s);return {communities:i,communityByNode:a,iterations:t,converged:e,algorithm:o,modularity:_e(c,a)}}function ue(c){let n=new Map;for(let t of c.nodes)n.set(t,new Set);for(let[t,e]of c.neighborsByNode.entries()){let o=n.get(t);if(o)for(let r of e)o.add(r.id);}return n}function Z(c,n,t,e){let o=t.get(c)??new Set,r=t.get(n)??new Set,i=o.size,a=r.size,s=i<=a?o:r,d=s===o?r:o,u=0,h=0,l=0;for(let N of s){if(!d.has(N))continue;u+=1;let p=t.get(N)?.size??0;p>1&&(h+=1/Math.log(p)),p>0&&(l+=1/p);}if(e==="common-neighbors")return u;if(e==="preferential-attachment")return i*a;if(e==="adamic-adar")return h;if(e==="resource-allocation")return l;if(e==="jaccard"){let N=i+a-u;return N>0?u/N:0}if(e==="cosine")return i>0&&a>0?u/Math.sqrt(i*a):0;let g=Math.min(i,a);return g>0?u/g:0}function ze(c,n){if(c.length<=1)return 0;let t=0;for(let e=1;e<c.length;e+=1){let o=c[e-1],r=c[e];if(!o||!r)return Number.POSITIVE_INFINITY;let i=n.neighborsByNode.get(o)?.find(a=>a.id===r)?.weight;if(i===void 0||!Number.isFinite(i))return Number.POSITIVE_INFINITY;t+=i;}return t}function Q(c){return c.join("\0")}function Le(c,n){if(n.length>c.length)return  false;for(let t=0;t<n.length;t+=1)if(c[t]!==n[t])return  false;return  true}function xe(c,n){return c==="auto"?n?"bellman-ford":"dijkstra":c}function Ve(c,n){if(F(c))throw new A("NEGATIVE_WEIGHT","Dijkstra cannot run on negative graph weights.");let t=new Map,e=new Map,o=new Set,r=new W;for(let i of c.nodes)t.set(i,Number.POSITIVE_INFINITY);for(t.set(n,0),r.push(n,0);r.size>0;){let i=r.pop();if(!i)break;let a=i.value;if(o.has(a))continue;o.add(a);let s=t.get(a);if(s===void 0||!Number.isFinite(s))continue;let d=c.neighborsByNode.get(a)??[];for(let u of d){let h=s+u.weight,l=t.get(u.id);(l===void 0||h<l-1e-12)&&(t.set(u.id,h),e.set(u.id,a),r.push(u.id,h));}}return {distanceByNode:t,previousByNode:e,explored:o.size,negativeCycleNodes:new Set}}function qe(c,n){let t=new Map,e=new Map;for(let d of c.nodes)t.set(d,Number.POSITIVE_INFINITY);t.set(n,0);let o=c.nodes.length;for(let d=0;d<o-1;d+=1){let u=false;for(let h of c.edges){let l=t.get(h.from);if(l===void 0||!Number.isFinite(l))continue;let g=l+h.weight,N=t.get(h.to);(N===void 0||g<N-1e-12)&&(t.set(h.to,g),e.set(h.to,h.from),u=true);}if(!u)break}let r=new Set,i=[];for(let d of c.edges){let u=t.get(d.from),h=t.get(d.to);u!==void 0&&Number.isFinite(u)&&h!==void 0&&u+d.weight<h-1e-12&&(r.has(d.to)||(r.add(d.to),i.push(d.to)),r.has(d.from)||(r.add(d.from),i.push(d.from)));}let a=0;for(;a<i.length;){let d=i[a];if(a+=1,!!d)for(let u of c.neighborsByNode.get(d)??[])r.has(u.id)||(r.add(u.id),i.push(u.id));}if(r.size>0)for(let d of r)t.set(d,Number.NEGATIVE_INFINITY),e.delete(d);let s=0;for(let d of c.nodes){let u=t.get(d);u!==void 0&&Number.isFinite(u)&&(s+=1);}return {distanceByNode:t,previousByNode:e,explored:s,negativeCycleNodes:r}}function ne(c,n,t){let e=F(c),o=xe(t,e);return o==="dijkstra"?{algorithm:o,result:Ve(c,n),hasNegativeWeights:e}:{algorithm:o,result:qe(c,n),hasNegativeWeights:e}}function Me(c){if(c===void 0||!Number.isFinite(c))return Math.random;let n=Math.floor(c)>>>0||1;return ()=>(n=n*1664525+1013904223>>>0,n/4294967296)}function Ye(c,n){let t=c[0]?.length??0;if(n==="none")return {normalize:s=>[...s],denormalize:s=>[...s]};let e=new Array(t).fill(0),o=new Array(t).fill(Number.POSITIVE_INFINITY),r=new Array(t).fill(Number.NEGATIVE_INFINITY);for(let s of c)for(let d=0;d<t;d+=1){let u=s[d]??0;e[d]=(e[d]??0)+u,o[d]=Math.min(o[d]??u,u),r[d]=Math.max(r[d]??u,u);}for(let s=0;s<t;s+=1)e[s]=(e[s]??0)/c.length;if(n==="minmax"){let s=r.map((d,u)=>{let h=o[u]??0;return d-h});return {normalize:d=>d.map((u,h)=>{let l=o[h]??0,g=s[h]??0;return Math.abs(g)<1e-12?0:(u-l)/g}),denormalize:d=>d.map((u,h)=>{let l=o[h]??0,g=s[h]??0;return u*g+l})}}let i=new Array(t).fill(0);for(let s of c)for(let d=0;d<t;d+=1){let u=(s[d]??0)-(e[d]??0);i[d]=(i[d]??0)+u*u;}let a=i.map(s=>Math.sqrt(s/c.length));return {normalize:s=>s.map((d,u)=>{let h=a[u]??0;return h<1e-12?0:(d-(e[u]??0))/h}),denormalize:s=>s.map((d,u)=>{let h=a[u]??0;return d*h+(e[u]??0)})}}function je(c,n,t,e){if(c.length===0)return [];if(!e){let a=[],s=new Set;for(;a.length<n;){let d=Math.floor(t()*c.length);s.has(d)||(s.add(d),a.push([...c[d]??c[0]??[]]));}return a}let o=[],r=new Set,i=Math.floor(t()*c.length);for(r.add(i),o.push([...c[i]??c[0]??[]]);o.length<n;){let a=new Array(c.length).fill(0),s=0;for(let l=0;l<c.length;l+=1){if(r.has(l))continue;let g=c[l];if(!g)continue;let N=Number.POSITIVE_INFINITY;for(let p of o)N=Math.min(N,q(g,p));a[l]=N,s+=N;}if(!Number.isFinite(s)||s<=0){for(let l=0;l<c.length;l+=1)if(!r.has(l)){r.add(l),o.push([...c[l]??c[0]??[]]);break}continue}let d=t()*s,u=0,h=-1;for(let l=0;l<c.length;l+=1)if(!r.has(l)&&(u+=a[l]??0,u>=d)){h=l;break}if(h<0){for(let l=0;l<c.length;l+=1)if(!r.has(l)){h=l;break}}if(h<0)break;r.add(h),o.push([...c[h]??c[0]??[]]);}return o}function Ke(c,n,t,e,o,r){let i=c[0]?.length??0,a=je(c,n,t,r);if(a.length!==n)throw new A("INVALID_ARGUMENT","Unable to initialize centroids for k-means.");let s=new Array(c.length).fill(-1),d=0,u=false,h=Number.POSITIVE_INFINITY;for(;d<e;){d+=1;let l=false;h=0;for(let b=0;b<c.length;b+=1){let I=c[b];if(!I)continue;let m=0,f=Number.POSITIVE_INFINITY;for(let x=0;x<a.length;x+=1){let y=a[x];if(!y)continue;let M=q(I,y);M<f&&(f=M,m=x);}h+=f,s[b]!==m&&(s[b]=m,l=true);}let g=new Array(n),N=new Array(n).fill(0);for(let b=0;b<n;b+=1)g[b]=new Array(i).fill(0);for(let b=0;b<c.length;b+=1){let I=s[b];if(I<0)continue;let m=c[b],f=g[I];if(!(!m||!f)){N[I]=(N[I]??0)+1;for(let x=0;x<i;x+=1)f[x]=(f[x]??0)+(m[x]??0);}}for(let b=0;b<n;b+=1){let I=N[b]??0;if(I>0){let m=g[b];if(!m)continue;for(let f=0;f<i;f+=1)m[f]=(m[f]??0)/I;}else {let m=0,f=-1;for(let x=0;x<c.length;x+=1){let y=s[x],M=a[y],w=c[x];if(!M||!w)continue;let S=q(w,M);S>f&&(f=S,m=x);}g[b]=[...c[m]??c[0]??[]];}}let p=0;for(let b=0;b<n;b+=1){let I=a[b],m=g[b];!I||!m||(p=Math.max(p,Math.sqrt(q(I,m))));}if(a=g,!l||p<=o){u=true;break}}return {assignments:s,centroidsNormalized:a,iterations:d,inertia:h,converged:u}}function we(c,n,t){if(c.length<=1||t<=1)return null;let e=Array.from({length:t},()=>[]);for(let i=0;i<n.length;i+=1){let a=n[i]??-1;if(a>=0&&a<t){let s=e[a];s&&s.push(i);}}let o=0,r=0;for(let i=0;i<c.length;i+=1){let a=c[i],s=n[i]??-1;if(!a||s<0||s>=t)continue;let d=e[s]??[];if(d.length<=1)continue;let u=0;for(let g of d){if(g===i)continue;let N=c[g];N&&(u+=U(a,N));}u/=d.length-1;let h=Number.POSITIVE_INFINITY;for(let g=0;g<t;g+=1){if(g===s)continue;let N=e[g]??[];if(N.length===0)continue;let p=0;for(let b of N){let I=c[b];I&&(p+=U(a,I));}p/=N.length,h=Math.min(h,p);}if(!Number.isFinite(h))continue;let l=Math.max(u,h);l<=0||(o+=(h-u)/l,r+=1);}return r===0?null:o/r}function ae(c,n){let t=0;for(let e=1;e<c.length;e+=1){let o=c[e-1],r=c[e];if(!o||!r)return Number.POSITIVE_INFINITY;let i=n.get(o)?.get(r);if(i===void 0||!Number.isFinite(i))return Number.POSITIVE_INFINITY;t+=i;}return t}function Ue(c,n,t){if(c.length<4||t<=0)return c;let e=[...c],o=ae(e,n);if(!Number.isFinite(o))return e;for(let r=0;r<t;r+=1){let i=false;for(let a=1;a<e.length-2;a+=1)for(let s=a+1;s<e.length-1;s+=1){let d=e.slice(0,a),u=e.slice(a,s+1).reverse(),h=e.slice(s+1),l=d.concat(u,h),g=ae(l,n);g+1e-9<o&&(e=l,o=g,i=true);}if(!i)break}return e}function We(c,n){let t=[],e=new Set;n.start&&c.includes(n.start)&&(t.push(n.start),e.add(n.start));for(let a of n.startCandidates??[])c.includes(a)&&!e.has(a)&&(t.push(a),e.add(a));let o=Me(n.seed),r=c.filter(a=>!e.has(a));for(let a=r.length-1;a>0;a-=1){let s=Math.floor(o()*(a+1)),d=r[a],u=r[s];d!==void 0&&u!==void 0&&(r[a]=u,r[s]=d);}let i=Math.max(1,Math.min(c.length,n.multiStartCount??Math.min(8,c.length)));for(let a of r){if(t.length>=i)break;t.push(a);}return t.length===0&&c.length>0&&t.push(c[0]),t}function $e(c,n,t,e){let o=[c],r=new Set(n.filter(a=>a!==c)),i=c;for(;r.size>0;){let a=null,s=Number.POSITIVE_INFINITY,d=t.get(i);for(let u of r){let h=d?.get(u)??Number.POSITIVE_INFINITY;h<s&&(s=h,a=u);}if(!a||!Number.isFinite(s))break;o.push(a),r.delete(a),i=a;}return e&&o.length>1&&o.push(c),o}function He(c,n){if(c.length<=1)return 0;let t=new Set;t.add(c[0]);let e=0;for(;t.size<c.length;){let o=Number.POSITIVE_INFINITY,r=null;for(let i of t){let a=n.get(i);for(let s of c){if(t.has(s))continue;let d=a?.get(s)??Number.POSITIVE_INFINITY;d<o&&(o=d,r=s);}}if(!r||!Number.isFinite(o))return Number.POSITIVE_INFINITY;t.add(r),e+=o;}return e}function G(c,n,t={}){let e=t.directed??true,o=te(c,n),r=De(o,n,e),i=Pe(r),a=Fe(o,i);return {nodes:o,neighborsByNode:i,incomingByNode:a,edges:Oe(i),directed:e}}function ye(c,n,t={}){let e=G(c,n,t),o=[];if(e.directed){let i=0,a=new Map,s=new Map,d=[],u=new Set,h=l=>{a.set(l,i),s.set(l,i),i+=1,d.push(l),u.add(l);for(let g of e.neighborsByNode.get(l)??[])if(a.has(g.id)){if(u.has(g.id)){let N=s.get(l)??0,p=a.get(g.id)??0;s.set(l,Math.min(N,p));}}else {h(g.id);let N=s.get(l)??0,p=s.get(g.id)??0;s.set(l,Math.min(N,p));}if((s.get(l)??-1)===(a.get(l)??-2)){let g=[];for(;d.length>0;){let N=d.pop();if(!N||(u.delete(N),g.push(N),N===l))break}g.sort(R),o.push(g);}};for(let l of e.nodes)a.has(l)||h(l);}else {let i=new Set;for(let a of e.nodes){if(i.has(a))continue;let s=[a];i.add(a);let d=[],u=0;for(;u<s.length;){let h=s[u];if(u+=1,!!h){d.push(h);for(let l of e.neighborsByNode.get(h)??[])i.has(l.id)||(i.add(l.id),s.push(l.id));}}d.sort(R),o.push(d);}}o.sort((i,a)=>{let s=i[0]??"",d=a[0]??"";return R(s,d)});let r=new Map;for(let i=0;i<o.length;i+=1)for(let a of o[i]??[])r.set(a,i);return {components:o,componentByNode:r}}function Xe(c,n){let t=G(c,n,{directed:false}),e=[],o=new Map,r=new Set;for(let i of t.nodes){if(r.has(i))continue;let a=[i];r.add(i);let s=[],d=0;for(;d<a.length;){let h=a[d];if(d+=1,!!h){s.push(h);for(let l of t.neighborsByNode.get(h)??[])r.has(l.id)||(r.add(l.id),a.push(l.id));}}s.sort(R);let u=e.length;e.push(s);for(let h of s)o.set(h,u);}e.sort((i,a)=>{let s=i[0]??"",d=a[0]??"";return R(s,d)}),o.clear();for(let i=0;i<e.length;i+=1){let a=e[i]??[];for(let s of a)o.set(s,i);}return {components:e,componentByNode:o}}function mt(c,n,t={}){let e=te(c,n),o=t.tieBreaker??((I,m)=>R(I,m)),r=t.priorityByNode,i=t.priority??(I=>r instanceof Map?r.get(I)??0:r?r[I]??0:0),a=(I,m)=>{let f=i(m)-i(I);return Math.abs(f)>1e-12?f:o(I,m)},s=new Map,d=new Map;for(let I of e)s.set(I,new Set),d.set(I,0);for(let I of n){if(I.from===I.to||!s.has(I.from)||!s.has(I.to))continue;let m=s.get(I.from);!m||m.has(I.to)||(m.add(I.to),d.set(I.to,(d.get(I.to)??0)+1));}let u=e.filter(I=>(d.get(I)??0)===0).sort(a),h=[];for(;u.length>0;){let I=u.shift();if(!I)continue;h.push(I);let m=Array.from(s.get(I)??[]).sort(a);for(let f of m){let x=(d.get(f)??0)-1;d.set(f,x),x===0&&u.push(f);}u.sort(a);}let l=new Set(h),g=e.filter(I=>!l.has(I));g.sort(a);let N=ye(e,n,{directed:true}),p=new Set(n.filter(I=>I.from===I.to).map(I=>I.from)),b=new Set;for(let I of N.components)if(I.length>1)for(let m of I)b.add(m);else if(I.length===1){let m=I[0];m&&p.has(m)&&b.add(m);}for(let I of g)b.add(I);for(let I of g)l.has(I)||(h.push(I),l.add(I));return {order:h,cycleNodes:Array.from(b).sort(a),isDag:b.size===0}}function Je(c,n,t={}){let e=G(c,n,t),o=e.nodes.length,r=o<=1?1:e.directed?2*(o-1):Math.max(1,o-1),i=new Map;for(let a of e.nodes){let s=e.neighborsByNode.get(a)?.length??0,d=e.incomingByNode.get(a)?.length??0,u=e.directed?d+s:s;i.set(a,{inDegree:d,outDegree:s,degree:u,normalized:u/r});}return i}function Qe(c,n,t={}){let e=G(c,n,t),o=e.nodes.length,r=Math.max(0,o-1),i=t.mode??"harmonic",a=new Map;for(let s of e.nodes){let d=ne(e,s,t.shortestPathAlgorithm??"auto"),u=d.result.distanceByNode,h=d.result.negativeCycleNodes.size>0,l=0,g=0,N=0;for(let I of e.nodes){if(I===s)continue;let m=u.get(I);m===void 0||!Number.isFinite(m)||m<=0||(l+=1,g+=m,N+=1/m);}let p=0,b=0;h||(i==="classic"?(p=l>0&&g>0?l/g:0,b=r>0?p*(l/r):0):(p=N,b=r>0?N/r:0)),a.set(s,{reachableCount:l,distanceSum:g,score:p,normalized:b,mode:i,negativeCycle:h});}return a}function Ze(c,n,t={}){let e=G(c,n,t);if(F(e))throw new A("NEGATIVE_WEIGHT","Betweenness centrality requires non-negative graph weights.");let o=new Map;for(let s of e.nodes)o.set(s,0);for(let s of e.nodes){let d=[],u=new Map,h=new Map,l=new Map,g=new W,N=new Set;for(let b of e.nodes)u.set(b,[]),h.set(b,0),l.set(b,Number.POSITIVE_INFINITY);for(h.set(s,1),l.set(s,0),g.push(s,0);g.size>0;){let b=g.pop();if(!b)break;let I=b.value;if(N.has(I))continue;N.add(I),d.push(I);let m=l.get(I);if(m===void 0||!Number.isFinite(m))continue;let f=h.get(I)??0;for(let x of e.neighborsByNode.get(I)??[]){let y=m+x.weight,M=l.get(x.id);M===void 0||y<M-1e-12?(l.set(x.id,y),g.push(x.id,y),h.set(x.id,f),u.set(x.id,[I])):M!==void 0&&Math.abs(y-M)<=1e-12&&(h.set(x.id,(h.get(x.id)??0)+f),u.get(x.id)?.push(I));}}let p=new Map;for(let b of e.nodes)p.set(b,0);for(;d.length>0;){let b=d.pop();if(!b)continue;let I=h.get(b)??0,m=p.get(b)??0;for(let f of u.get(b)??[]){let x=h.get(f)??0;if(I<=0)continue;let y=x/I*(1+m);p.set(f,(p.get(f)??0)+y);}b!==s&&o.set(b,(o.get(b)??0)+m);}}if(!e.directed)for(let s of e.nodes)o.set(s,(o.get(s)??0)/2);let r=e.nodes.length,i=r<=2?Number.POSITIVE_INFINITY:e.directed?(r-1)*(r-2):(r-1)*(r-2)/2,a=new Map;for(let s of e.nodes){let d=o.get(s)??0;a.set(s,{raw:d,normalized:Number.isFinite(i)&&i>0?d/i:0});}return a}function et(c,n,t={}){let e=G(c,n,t);if(F(e))throw new A("NEGATIVE_WEIGHT","PageRank requires non-negative graph weights.");let o=e.nodes.length;if(o===0)return {byNode:new Map,order:[],iterations:0,converged:true,dampingFactor:t.dampingFactor??.85};let r=t.dampingFactor??.85;if(!Number.isFinite(r)||r<0||r>=1)throw new A("INVALID_ARGUMENT",`PageRank dampingFactor must be in [0, 1), received ${r}.`);let i=Math.max(0,t.tolerance??1e-9),a=Math.max(1,Math.floor(t.maxIterations??200)),s=1/o,d=new Map;for(let I of e.nodes){let m=(e.neighborsByNode.get(I)??[]).reduce((f,x)=>f+x.weight,0);d.set(I,m);}let u=new Map;for(let I of e.nodes)u.set(I,s);let h=0,l=false;for(let I=0;I<a;I+=1){h=I+1;let m=new Map,f=(1-r)/o,x=0;for(let w of e.nodes)(d.get(w)??0)<=1e-12&&(x+=u.get(w)??0),m.set(w,f);let y=r*x/o;if(y>0)for(let w of e.nodes)m.set(w,(m.get(w)??0)+y);for(let w of e.nodes){let S=d.get(w)??0;if(S<=1e-12)continue;let v=u.get(w)??0;for(let E of e.neighborsByNode.get(w)??[]){let k=r*v*E.weight/S;m.set(E.id,(m.get(E.id)??0)+k);}}let M=0;for(let w of e.nodes){let S=u.get(w)??0,v=m.get(w)??0;M+=Math.abs(S-v);}if(u=m,M<=i){l=true;break}}let g=0;for(let I of e.nodes)g+=u.get(I)??0;if(!Number.isFinite(g)||g<=0){u=new Map;for(let I of e.nodes)u.set(I,s);g=1;}else if(Math.abs(g-1)>1e-12)for(let I of e.nodes)u.set(I,(u.get(I)??0)/g);let N=[...e.nodes].sort((I,m)=>{let f=(u.get(m)??0)-(u.get(I)??0);return Math.abs(f)>1e-12?f:R(I,m)}),p=N.length>0?u.get(N[0])??0:0,b=new Map;for(let I=0;I<N.length;I+=1){let m=N[I];if(!m)continue;let f=u.get(m)??0;b.set(m,{score:f,normalized:p>0?f/p:0,rank:I+1});}return {byNode:b,order:N,iterations:h,converged:l,dampingFactor:r}}function ft(c,n,t={}){let e=G(c,n,{directed:false}),o=t.tieBreaker??((l,g)=>R(l,g)),r=new Map;for(let l of e.edges){if(l.from===l.to)continue;let g=ee(l.from,l.to),N=$(g.from,g.to),p=r.get(N);(!p||l.weight<p.weight-1e-12)&&r.set(N,{from:g.from,to:g.to,weight:l.weight});}let i=Array.from(r.values());i.sort((l,g)=>{let N=l.weight-g.weight;if(Math.abs(N)>1e-12)return N;let p=o(l.from,g.from);return p!==0?p:o(l.to,g.to)});let a=new ie(e.nodes),s=[],d=0;for(let l of i)a.union(l.from,l.to)&&(s.push(l),d+=l.weight);let u=new Set;for(let l of e.nodes)u.add(a.find(l));let h=u.size;return {edges:s,totalWeight:d,componentCount:h,spanning:e.nodes.length<=1||h===1&&s.length===e.nodes.length-1}}function tt(c,n){let t=G(c,n,{directed:false}),e=new Map,o=new Map,r=new Map,i=new Set,a=new Map,s=0,d=h=>{e.set(h,s),o.set(h,s),s+=1;let l=0,g=r.get(h)??null;for(let N of t.neighborsByNode.get(h)??[]){let p=e.get(N.id);if(p===void 0){r.set(N.id,h),l+=1,d(N.id);let b=o.get(h)??0,I=o.get(N.id)??0;o.set(h,Math.min(b,I));let m=e.get(h)??0;if(g===null&&l>1&&i.add(h),g!==null&&I>=m&&i.add(h),I>m){let f=ee(h,N.id),x=$(f.from,f.to),y=a.get(x);(!y||N.weight<y.weight-1e-12)&&a.set(x,{from:f.from,to:f.to,weight:N.weight});}}else if(N.id!==g){let b=o.get(h)??0;o.set(h,Math.min(b,p));}}};for(let h of t.nodes)e.has(h)||(r.set(h,null),d(h));let u=Array.from(a.values());return u.sort((h,l)=>{let g=R(h.from,l.from);if(g!==0)return g;let N=R(h.to,l.to);return N!==0?N:h.weight-l.weight}),{articulationPoints:Array.from(i).sort(R),bridges:u}}function gt(c,n,t={}){let e=ye(c,n,t),o=Xe(c,n),r=tt(c,n),i=te(c,n),a=[...i].sort(R),s=new Map,d=new Map;try{s=Ze(c,n,t);}catch(u){if(!(u instanceof A)||u.code!=="NEGATIVE_WEIGHT")throw u;s=new Map;for(let h of a)s.set(h,{raw:0,normalized:0});}try{d=et(c,n,{directed:t.directed??!0,...t.pageRankOptions??{}}).byNode;}catch(u){if(!(u instanceof A)||u.code!=="NEGATIVE_WEIGHT")throw u;let h=i.length>0?1/i.length:0;d=new Map;for(let l=0;l<a.length;l+=1){let g=a[l];g&&d.set(g,{score:h,normalized:1,rank:l+1});}}return {degree:Je(c,n,t),closeness:Qe(c,n,{...t,mode:t.closenessMode??"harmonic",shortestPathAlgorithm:t.shortestPathAlgorithm}),betweenness:s,pageRank:d,stronglyConnectedComponents:e.components,weaklyConnectedComponents:o.components,articulationPoints:r.articulationPoints,bridges:r.bridges}}function be(c,n,t,e,o={}){let r=G(c,n,o);if(!r.neighborsByNode.has(t)||!r.neighborsByNode.has(e))return {source:t,target:e,path:[],distance:Number.POSITIVE_INFINITY,reachable:false,explored:0,algorithm:o.algorithm??"auto",hasNegativeWeights:F(r),negativeCycle:false};let i=ne(r,t,o.algorithm??"auto");if(i.result.negativeCycleNodes.has(e)){if(o.failOnNegativeCycle??false)throw new A("NEGATIVE_CYCLE",`Negative cycle reaches target node "${e}".`);return {source:t,target:e,path:[],distance:Number.NEGATIVE_INFINITY,reachable:false,explored:i.result.explored,algorithm:i.algorithm,hasNegativeWeights:i.hasNegativeWeights,negativeCycle:true}}let a=i.result.distanceByNode.get(e)??Number.POSITIVE_INFINITY,s=Number.isFinite(a),d=s?ce(t,e,i.result.previousByNode):[];return {source:t,target:e,path:d,distance:a,reachable:s&&d.length>0,explored:i.result.explored,algorithm:i.algorithm,hasNegativeWeights:i.hasNegativeWeights,negativeCycle:i.result.negativeCycleNodes.size>0}}function It(c,n,t={}){let e=G(c,n,{directed:t.directed??false});if(F(e))throw new A("NEGATIVE_WEIGHT","Label propagation requires non-negative graph weights.");let o=t.tieBreaker??((u,h)=>R(u,h)),r=[...e.nodes].sort(o),i=new Map;for(let u=0;u<r.length;u+=1){let h=r[u];h&&i.set(h,u);}let a=Math.max(1,t.maxIterations??100),s=0,d=false;for(let u=0;u<a;u+=1){s=u+1;let h=false;for(let l of r){let g=e.neighborsByNode.get(l)??[];if(g.length===0)continue;let N=new Map;for(let m of g){let f=i.get(m.id);f!==void 0&&N.set(f,(N.get(f)??0)+m.weight);}let p=i.get(l);if(p===void 0||N.size===0)continue;let b=p,I=Number.NEGATIVE_INFINITY;for(let[m,f]of N.entries()){if(f>I+1e-12){I=f,b=m;continue}Math.abs(f-I)<=1e-12&&m<b&&(b=m);}b!==p&&(i.set(l,b),h=true);}if(!h){d=true;break}}return de(e,i,s,d,"label-propagation")}function Nt(c,n,t={}){let e=G(c,n,{directed:t.directed??false});if(F(e))throw new A("NEGATIVE_WEIGHT","Louvain requires non-negative graph weights.");let o=t.tieBreaker??((N,p)=>R(N,p)),r=[...e.nodes].sort(o),i=Math.max(1,t.maxPasses??32),a=Math.max(0,t.tolerance??1e-9),s=new Map;for(let N of e.nodes)s.set(N,pe(e.neighborsByNode.get(N)??[]));let d=0;for(let N of s.values())d+=N;let u=new Map,h=new Map;for(let N=0;N<r.length;N+=1){let p=r[N];if(!p)continue;u.set(p,N);let b=s.get(p)??0;h.set(N,b);}if(d<=1e-12)return de(e,u,0,true,"louvain");let l=0,g=false;for(let N=0;N<i;N+=1){l=N+1;let p=false;for(let b of r){let I=u.get(b);if(I===void 0)continue;let m=s.get(b)??0;h.set(I,(h.get(I)??0)-m);let f=new Map;for(let M of e.neighborsByNode.get(b)??[]){let w=u.get(M.id);w!==void 0&&f.set(w,(f.get(w)??0)+M.weight);}let x=I,y=0;for(let[M,w]of f.entries()){let S=h.get(M)??0,v=w-S*m/d;if(v>y+a){y=v,x=M;continue}Math.abs(v-y)<=a&&M<x&&(x=M);}x!==I&&y>a?(u.set(b,x),h.set(x,(h.get(x)??0)+m),p=true):h.set(I,(h.get(I)??0)+m);}if(!p){g=true;break}}return de(e,u,l,g,"louvain")}function bt(c,n,t={}){let e=G(c,n,{directed:t.directed??false}),o=t.metric??"jaccard",r=t.minScore??0,i=ue(e),a=[...e.nodes].sort(R),s=[];for(let d=0;d<a.length;d+=1){let u=a[d];if(u)for(let h=d+1;h<a.length;h+=1){let l=a[h];if(!l)continue;let g=Z(u,l,i,o);g<r-1e-12||s.push({left:u,right:l,score:g,metric:o});}}return s.sort((d,u)=>{let h=u.score-d.score;if(Math.abs(h)>1e-12)return h;let l=R(d.left,u.left);return l!==0?l:R(d.right,u.right)}),{metric:o,pairs:s.map((d,u)=>({...d,rank:u+1}))}}function pt(c,n,t={}){let e=G(c,n,{directed:t.directed??false}),o=t.metric??"jaccard",r=t.minScore??0,i=Math.max(1,Math.floor(t.k??5)),a=ue(e),s=[...e.nodes].sort(R),d=new Map;for(let u of s){let h=[];for(let l of s){if(u===l)continue;let g=Z(u,l,a,o);g<r-1e-12||h.push({nodeId:l,score:g});}h.sort((l,g)=>{let N=g.score-l.score;return Math.abs(N)>1e-12?N:R(l.nodeId,g.nodeId)}),d.set(u,h.slice(0,i));}return {metric:o,k:i,neighborsByNode:d}}function nt(c,n,t={}){let e=t.directed??false,o=G(c,n,{directed:e}),r=t.metric??"jaccard",i=t.minScore??0,a=Math.max(1,Math.floor(t.limit??20)),s=t.allowExistingEdges??false,d=ue(o),u=[...o.nodes].sort(R),h=t.sourceFilter?new Set(t.sourceFilter):null,l=t.targetFilter?new Set(t.targetFilter):null,g=new Set;for(let p of o.edges)e?g.add(`${p.from}\0${p.to}`):g.add($(p.from,p.to));let N=[];if(e){for(let p of u)if(!(h&&!h.has(p)))for(let b of u){if(p===b||l&&!l.has(b)||!s&&g.has(`${p}\0${b}`))continue;let I=Z(p,b,d,r);I<i-1e-12||N.push({from:p,to:b,score:I,metric:r});}}else for(let p=0;p<u.length;p+=1){let b=u[p];if(b)for(let I=p+1;I<u.length;I+=1){let m=u[I];if(!m||h&&!h.has(b)&&!h.has(m)||l&&!l.has(b)&&!l.has(m)||!s&&g.has($(b,m)))continue;let f=Z(b,m,d,r);f<i-1e-12||N.push({from:b,to:m,score:f,metric:r});}}return N.sort((p,b)=>{let I=b.score-p.score;if(Math.abs(I)>1e-12)return I;let m=R(p.from,b.from);return m!==0?m:R(p.to,b.to)}),{metric:r,predictions:N.slice(0,a).map((p,b)=>({...p,rank:b+1}))}}function xt(c,n,t={}){return nt(c,n,t)}function Mt(c,n,t,e,o={}){let r=G(c,n,o);if(F(r))throw new A("NEGATIVE_WEIGHT","A* requires non-negative graph weights.");if(!r.neighborsByNode.has(t)||!r.neighborsByNode.has(e))return {source:t,target:e,path:[],distance:Number.POSITIVE_INFINITY,reachable:false,explored:0,estimatedDistance:Number.POSITIVE_INFINITY};let i=o.heuristic??((b,I)=>0),a=new W,s=new Map,d=new Map,u=new Set;for(let b of r.nodes)s.set(b,Number.POSITIVE_INFINITY);s.set(t,0);let h=i(t,e);if(!Number.isFinite(h))throw new A("INVALID_ARGUMENT","A* heuristic must return finite values.");a.push(t,h);let l=0;for(;a.size>0;){let b=a.pop();if(!b)break;let I=b.value;if(u.has(I))continue;if(u.add(I),l+=1,I===e)break;let m=s.get(I);if(!(m===void 0||!Number.isFinite(m)))for(let f of r.neighborsByNode.get(I)??[]){let x=m+f.weight,y=s.get(f.id)??Number.POSITIVE_INFINITY;if(x>=y-1e-12)continue;let M=i(f.id,e);if(!Number.isFinite(M))throw new A("INVALID_ARGUMENT","A* heuristic must return finite values.");s.set(f.id,x),d.set(f.id,I),a.push(f.id,x+M);}}let g=s.get(e)??Number.POSITIVE_INFINITY,N=Number.isFinite(g),p=N?ce(t,e,d):[];return {source:t,target:e,path:p,distance:g,reachable:N&&p.length>0,explored:l,estimatedDistance:g}}function wt(c,n,t={}){let e=G(c,n,t),o=t.algorithm??"auto",r=xe(o,F(e)),i=new Map,a=new Map,s=false;for(let d of e.nodes){let u=ne(e,d,r);if(u.result.negativeCycleNodes.size>0&&(s=true,t.failOnNegativeCycle??false))throw new A("NEGATIVE_CYCLE",`Negative cycle reaches source node "${d}".`);let h=new Map,l=new Map;for(let g of e.nodes){h.set(g,u.result.distanceByNode.get(g)??Number.POSITIVE_INFINITY);let N=u.result.previousByNode.get(g);N&&l.set(g,N);}i.set(d,h),a.set(d,l);}return {nodes:e.nodes,distanceBySource:i,previousBySource:a,algorithm:r,hasNegativeWeights:F(e),negativeCycle:s}}function yt(c,n,t,e,o={}){let r=o.directed??true,i=Math.max(1,Math.floor(o.k??3)),a=o.shortestPathAlgorithm??"auto",s=G(c,n,{directed:r});if(!s.neighborsByNode.has(t)||!s.neighborsByNode.has(e))return {source:t,target:e,paths:[],complete:false};let d=be(s.nodes,s.edges,t,e,{directed:r,algorithm:a});if(!d.reachable||d.path.length===0)return {source:t,target:e,paths:[],complete:false};let u=[{path:d.path,distance:d.distance}],h=new Map;for(let l=1;l<i;l+=1){let g=u[l-1]?.path??[];if(g.length<2)break;for(let p=0;p<g.length-1;p+=1){let b=g[p];if(!b)continue;let I=g.slice(0,p+1),m=new Set(I.slice(0,-1)),f=new Set;for(let v of u)if(v.path.length>p+1&&Le(v.path,I)){let E=v.path[p],k=v.path[p+1];E&&k&&f.add(`${E}\0${k}`);}let x=s.edges.filter(v=>!(f.has(`${v.from}\0${v.to}`)||m.has(v.from)||m.has(v.to))),y=be(s.nodes,x,b,e,{directed:r,algorithm:a});if(!y.reachable||y.path.length===0)continue;let M=I.slice(0,-1).concat(y.path),w=ze(M,s);if(!Number.isFinite(w))continue;let S=Q(M);h.has(S)||h.set(S,{path:M,distance:w});}if(h.size===0)break;let N=Array.from(h.values()).sort((p,b)=>{let I=p.distance-b.distance;return Math.abs(I)>1e-12?I:R(Q(p.path),Q(b.path))})[0];if(!N)break;u.push(N),h.delete(Q(N.path));}return {source:t,target:e,paths:u,complete:u.length>=i}}function St(c,n,t,e,o={}){let r=G(c,n,o);if(!r.neighborsByNode.has(t)||!r.neighborsByNode.has(e))return {source:t,sink:e,maxFlow:0,augmentations:0,flowByEdge:[],sourcePartition:[],sinkPartition:[],cutEdges:[]};let i=[];for(let f of r.edges){if(f.weight<0)throw new A("NEGATIVE_WEIGHT","Maximum flow requires non-negative capacities.");i.push(f);}let a=new Map;for(let f of r.nodes)a.set(f,[]);let s=(f,x,y,M)=>{let w=a.get(f),S=a.get(x);if(!w||!S)return;let v=w.length,E=S.length;w.push({to:x,reverseIndex:E,capacity:y,originalIndex:M}),S.push({to:f,reverseIndex:v,capacity:0,originalIndex:null});};for(let f=0;f<i.length;f+=1){let x=i[f];x&&s(x.from,x.to,x.weight,f);}let d=0,u=0,h=new Array(i.length).fill(0);for(;;){let f=new Map,x=[t];f.set(t,{from:t,edgeIndex:-1});let y=0;for(;y<x.length&&!f.has(e);){let S=x[y];if(y+=1,!S)continue;let v=a.get(S)??[];for(let E=0;E<v.length;E+=1){let k=v[E];!k||k.capacity<=1e-12||f.has(k.to)||(f.set(k.to,{from:S,edgeIndex:E}),x.push(k.to));}}if(!f.has(e))break;let M=Number.POSITIVE_INFINITY,w=e;for(;w!==t;){let S=f.get(w);if(!S){M=0;break}let v=a.get(S.from)?.[S.edgeIndex];if(!v){M=0;break}M=Math.min(M,v.capacity),w=S.from;}if(!Number.isFinite(M)||M<=1e-12)break;for(w=e;w!==t;){let S=f.get(w);if(!S)break;let v=a.get(S.from)?.[S.edgeIndex],E=v?a.get(v.to)?.[v.reverseIndex]:void 0;if(!v||!E)break;v.capacity-=M,E.capacity+=M,v.originalIndex!==null?h[v.originalIndex]=(h[v.originalIndex]??0)+M:E.originalIndex!==null&&(h[E.originalIndex]=(h[E.originalIndex]??0)-M),w=S.from;}d+=M,u+=1;}let l=new Set,g=[t];l.add(t);let N=0;for(;N<g.length;){let f=g[N];if(N+=1,!!f)for(let x of a.get(f)??[])x.capacity<=1e-12||l.has(x.to)||(l.add(x.to),g.push(x.to));}let p=r.nodes.filter(f=>l.has(f)).sort(R),b=r.nodes.filter(f=>!l.has(f)).sort(R),I=i.filter(f=>l.has(f.from)&&!l.has(f.to)).sort((f,x)=>{let y=R(f.from,x.from);return y!==0?y:R(f.to,x.to)}),m=i.map((f,x)=>({from:f.from,to:f.to,flow:Math.max(0,h[x]??0),capacity:f.weight})).sort((f,x)=>{let y=R(f.from,x.from);return y!==0?y:R(f.to,x.to)});return {source:t,sink:e,maxFlow:d,augmentations:u,flowByEdge:m,sourcePartition:p,sinkPartition:b,cutEdges:I}}function vt(c,n,t,e,o={}){let r=n.map(m=>({from:m.from,to:m.to,weight:m.capacity})),i=te(c,r),a=o.directed??true;if(!i.includes(t)||!i.includes(e))return {source:t,sink:e,flow:0,cost:0,complete:false,augmentations:0,flowByEdge:[]};let s=[];for(let m of n){if(!Number.isFinite(m.capacity)||m.capacity<0)throw new A("INVALID_ARGUMENT",`Flow edge capacity must be non-negative and finite, received ${m.capacity}.`);let f=m.cost??0;if(!Number.isFinite(f))throw new A("INVALID_ARGUMENT",`Flow edge cost must be finite, received ${f}.`);s.push({from:m.from,to:m.to,capacity:m.capacity,cost:f}),a||s.push({from:m.to,to:m.from,capacity:m.capacity,cost:f});}let d=new Map;for(let m of i)d.set(m,[]);let u=(m,f,x,y,M)=>{let w=d.get(m),S=d.get(f);if(!w||!S)return;let v=w.length,E=S.length;w.push({to:f,reverseIndex:E,capacity:x,cost:y,originalIndex:M}),S.push({to:m,reverseIndex:v,capacity:0,cost:-y,originalIndex:null});};for(let m=0;m<s.length;m+=1){let f=s[m];f&&u(f.from,f.to,f.capacity,f.cost,m);}let h=o.targetFlow,l=h===void 0?Number.POSITIVE_INFINITY:h;if(!Number.isFinite(l)&&l!==Number.POSITIVE_INFINITY)throw new A("INVALID_ARGUMENT",`targetFlow must be finite or omitted, received ${l}.`);if(l<0)throw new A("INVALID_ARGUMENT",`targetFlow must be non-negative, received ${l}.`);let g=0,N=0,p=0,b=new Array(s.length).fill(0);for(;g<l-1e-12;){let m=new Map,f=new Map;for(let w of i)m.set(w,Number.POSITIVE_INFINITY);m.set(t,0);for(let w=0;w<i.length-1;w+=1){let S=false;for(let v of i){let E=m.get(v);if(E===void 0||!Number.isFinite(E))continue;let k=d.get(v)??[];for(let L=0;L<k.length;L+=1){let B=k[L];if(!B||B.capacity<=1e-12)continue;let Y=E+B.cost,T=m.get(B.to)??Number.POSITIVE_INFINITY;Y<T-1e-12&&(m.set(B.to,Y),f.set(B.to,{from:v,edgeIndex:L}),S=true);}}if(!S)break}let x=m.get(e)??Number.POSITIVE_INFINITY;if(!Number.isFinite(x))break;let y=Math.min(l-g,Number.POSITIVE_INFINITY),M=e;for(;M!==t;){let w=f.get(M);if(!w){y=0;break}let S=d.get(w.from)?.[w.edgeIndex];if(!S){y=0;break}y=Math.min(y,S.capacity),M=w.from;}if(!Number.isFinite(y)||y<=1e-12)break;for(M=e;M!==t;){let w=f.get(M);if(!w)break;let S=d.get(w.from)?.[w.edgeIndex],v=S?d.get(S.to)?.[S.reverseIndex]:void 0;if(!S||!v)break;S.capacity-=y,v.capacity+=y,S.originalIndex!==null?b[S.originalIndex]=(b[S.originalIndex]??0)+y:v.originalIndex!==null&&(b[v.originalIndex]=(b[v.originalIndex]??0)-y),M=w.from;}g+=y,N+=y*x,p+=1;}let I=s.map((m,f)=>({from:m.from,to:m.to,flow:Math.max(0,b[f]??0),capacity:m.capacity,cost:m.cost})).sort((m,f)=>{let x=R(m.from,f.from);return x!==0?x:R(m.to,f.to)});return {source:t,sink:e,flow:g,cost:N,complete:l===Number.POSITIVE_INFINITY?true:g>=l-1e-12,augmentations:p,flowByEdge:I}}function ot(c,n,t={}){if(!Array.isArray(c)||c.length===0)throw new A("INVALID_ARGUMENT","kMeansClustering requires at least one point.");let e=c[0]?.length??0;if(e===0)throw new A("INVALID_ARGUMENT","kMeansClustering requires points with at least one axis.");for(let I of c)if(I.length!==e)throw new A("INVALID_ARGUMENT","kMeansClustering requires all points to share dimensionality.");let o=Math.max(1,Math.min(c.length,Math.floor(n))),r=Math.max(1,t.maxIterations??120),i=Math.max(0,t.tolerance??1e-5),a=Math.max(1,t.nInit??8),s=t.normalization??"zscore",d=t.useKMeansPlusPlus??true,u=t.seed===void 0||!Number.isFinite(t.seed)?Math.floor(Math.random()*4294967295):Math.floor(t.seed),h=Ye(c,s),l=c.map(I=>h.normalize(I)),g=null,N=u;for(let I=0;I<a;I+=1){let m=u+I*2654435761>>>0,f=Me(m),x=Ke(l,o,f,r,i,d);(!g||x.inertia<g.inertia-1e-9)&&(g=x,N=m);}if(!g)throw new A("INVALID_ARGUMENT","kMeansClustering failed to produce a valid run.");let p=[];for(let I=0;I<o;I+=1){let m=[];for(let f=0;f<g.assignments.length;f+=1)g.assignments[f]===I&&m.push(f);p.push({centroid:h.denormalize(g.centroidsNormalized[I]??[]),indices:m});}let b=we(l,g.assignments,o);return {assignments:g.assignments,clusters:p,iterations:g.iterations,inertia:g.inertia,converged:g.converged,silhouette:b,selectedSeed:N}}function Et(c,n={}){if(!Array.isArray(c)||c.length===0)throw new A("INVALID_ARGUMENT","kMeansAuto requires at least one point.");let t=Math.max(2,n.kMin??2),e=Math.max(t,Math.min(c.length,n.kMax??Math.min(10,Math.ceil(Math.sqrt(c.length))+2))),o=null,r=t,i=[];for(let a=t;a<=e;a+=1){let s=ot(c,a,{...n,seed:n.seed===void 0||!Number.isFinite(n.seed)?void 0:n.seed+a*997});if(i.push({k:a,silhouette:s.silhouette,inertia:s.inertia}),!o){o=s,r=a;continue}let d=s.silhouette??Number.NEGATIVE_INFINITY,u=o.silhouette??Number.NEGATIVE_INFINITY;if(d>u+1e-9){o=s,r=a;continue}Math.abs(d-u)<=1e-9&&s.inertia<o.inertia-1e-9&&(o=s,r=a);}if(!o)throw new A("INVALID_ARGUMENT","kMeansAuto failed to choose a cluster configuration.");return {...o,selectedK:r,candidates:i}}function Rt(c,n,t={}){let e=G(c,n,t);if(e.nodes.length===0)return {order:[],distance:0,segments:[],visitedCount:0,complete:true,unreachableNodes:[],lowerBound:0,optimalityGap:0};if(F(e))throw new A("NEGATIVE_WEIGHT","TSP approximation requires non-negative graph weights.");let o=t.returnToStart??true,r=Math.max(0,t.twoOptPasses??3),i=We(e.nodes,t),a=new Map,s=new Map;for(let m of e.nodes){let f=ne(e,m,t.shortestPathAlgorithm??"auto");if(f.result.negativeCycleNodes.size>0)throw new A("NEGATIVE_CYCLE","TSP approximation cannot run when negative cycles are reachable.");a.set(m,f.result.distanceByNode),s.set(m,f.result.previousByNode);}let d=[],u=Number.POSITIVE_INFINITY;for(let m of i){let x=$e(m,e.nodes,a,o);x.length>2&&(x=Ue(x,a,r));let y=ae(x,a);y<u&&(u=y,d=x);}let h=new Set(d),l=e.nodes.filter(m=>!h.has(m)),g=l.length===0&&Number.isFinite(u),N=[],p=0;for(let m=1;m<d.length;m+=1){let f=d[m-1],x=d[m];if(!f||!x)continue;let y=a.get(f)?.get(x)??Number.POSITIVE_INFINITY,M=s.get(f)??new Map,w=ce(f,x,M);!Number.isFinite(y)||w.length===0||(p+=y,N.push({from:f,to:x,distance:y,path:w}));}g||(p=Number.POSITIVE_INFINITY);let b=He(e.nodes,a),I=g&&Number.isFinite(p)&&Number.isFinite(b)&&b>0?(p-b)/b:null;return {order:d,distance:p,segments:N,visitedCount:h.size,complete:g,unreachableNodes:l,lowerBound:b,optimalityGap:I}}function At(c,n,t={}){if(!Array.isArray(c)||c.length===0)throw new A("INVALID_ARGUMENT","hierarchicalClustering requires at least one point.");let e=c.length,o=Math.max(1,Math.min(e,Math.floor(n))),r=t.linkage??"average",i=t.distanceMetric??"euclidean",a=(m,f)=>{switch(i){case "cosine":return 1-re(m,f);case "manhattan":return se(m,f);default:return U(m,f)}},s=c.map((m,f)=>[f]),d=new Array(e).fill(true),u=[],h=Array.from({length:e},()=>new Array(e).fill(0));for(let m=0;m<e;m+=1)for(let f=m+1;f<e;f+=1){let x=a(c[m],c[f]);h[m][f]=x,h[f][m]=x;}let l=Array.from({length:e},(m,f)=>[...h[f]]),g=e;for(;g>o;){let m=-1,f=-1,x=Number.POSITIVE_INFINITY;for(let M=0;M<s.length;M+=1)if(d[M])for(let w=M+1;w<s.length;w+=1)d[w]&&l[M][w]<x&&(x=l[M][w],m=M,f=w);if(m===-1||f===-1)break;u.push({left:m<e?-(m+1):m,right:f<e?-(f+1):f,distance:x,size:s[m].length+s[f].length});let y=s[m].concat(s[f]);s[m]=y,d[f]=false,g-=1;for(let M=0;M<s.length;M+=1){if(!d[M]||M===m)continue;let w;switch(r){case "single":w=Math.min(l[m][M],l[f][M]);break;case "complete":w=Math.max(l[m][M],l[f][M]);break;case "ward":{let S=s[m].length-s[f].length,v=s[f].length,E=s[M].length,k=S+v+E;w=Math.sqrt(((S+E)*l[m][M]*l[m][M]+(v+E)*l[f][M]*l[f][M]-E*x*x)/k);break}default:{let S=s[m].length-s[f].length,v=s[f].length;w=(l[m][M]*S+l[f][M]*v)/(S+v);break}}l[m][M]=w,l[M][m]=w;}}let N=new Array(e).fill(-1),p=[],b=0;for(let m=0;m<s.length;m+=1)if(d[m]){p.push(s[m]);for(let f of s[m])N[f]=b;b+=1;}let I=we(c,N,p.length);return {clusters:p,assignments:N,dendrogram:u,silhouette:I}}function Tt(c,n,t,e={}){if(!Array.isArray(c)||c.length===0)throw new A("INVALID_ARGUMENT","dbscan requires at least one point.");let o=c.length,r=e.distanceMetric??"euclidean",i=(N,p)=>{switch(r){case "cosine":return 1-re(N,p);case "manhattan":return se(N,p);default:return U(N,p)}},a=-2,s=-1,d=new Array(o).fill(a),u=0,h=N=>{let p=[];for(let b=0;b<o;b+=1)i(c[N],c[b])<=n&&p.push(b);return p};for(let N=0;N<o;N+=1){if(d[N]!==a)continue;let p=h(N);if(p.length<t){d[N]=s;continue}d[N]=u;let b=[...p],I=0;for(;I<b.length;){let m=b[I];if(I+=1,d[m]===s&&(d[m]=u),d[m]!==a)continue;d[m]=u;let f=h(m);if(f.length>=t)for(let x of f)b.includes(x)||b.push(x);}u+=1;}let l=Array.from({length:u},()=>[]),g=[];for(let N=0;N<o;N+=1)d[N]===s?g.push(N):l[d[N]].push(N);return {clusters:l,assignments:d,noise:g,clusterCount:u}}function rt(c){return typeof c=="string"?c:c.id}function le(c,n,t){let e=new Set;for(let s of c)e.add(rt(s));for(let s of n)e.add(s.from),e.add(s.to);let o=Array.from(e).sort(),r=new Map,i=new Map,a=new Set;for(let s of o)r.set(s,new Set),i.set(s,new Set);for(let s of n){let d=s.from,u=s.to;r.get(d)?.add(u),i.get(u)?.add(d),a.add(`${d}\0${u}`),t||(r.get(u)?.add(d),i.get(d)?.add(u),a.add(`${u}\0${d}`));}return {nodeIds:o,outNeighbors:r,inNeighbors:i,edgeSet:a}}function Se(c,n,t={}){let e=t.directed??false,{nodeIds:o,outNeighbors:r,edgeSet:i}=le(c,n,e),a=new Map;for(let s of o){let d=r.get(s),u=d.size;if(u<2){a.set(s,0);continue}let h=Array.from(d),l=0;for(let N=0;N<h.length;N+=1)for(let p=N+1;p<h.length;p+=1){let b=h[N],I=h[p];e?(i.has(`${b}\0${I}`)&&(l+=1),i.has(`${I}\0${b}`)&&(l+=1)):(i.has(`${b}\0${I}`)||i.has(`${I}\0${b}`))&&(l+=1);}let g=e?u*(u-1):u*(u-1)/2;a.set(s,g>0?l/g:0);}return a}function Ct(c,n,t={}){let e=t.directed??false,{nodeIds:o,outNeighbors:r,inNeighbors:i,edgeSet:a}=le(c,n,e),s=o.length,d=n.length,u=e?s*(s-1):s*(s-1)/2,h=u>0?d/u:0,l=[],g=[],N=[];for(let T of o){let C=r.get(T)?.size??0,P=i.get(T)?.size??0;N.push(C),g.push(P),l.push(e?C+P:C);}let p=new O({data:l}),b=new O({data:g}),I=new O({data:N}),m=Se(c,n,{directed:e}),f=Array.from(m.values()),x=f.length>0?f.reduce((T,C)=>T+C,0)/f.length:0,y=new O({data:f.length>0?f:[0]}),M=0;if(e)for(let T of n)a.has(`${T.to}\0${T.from}`)&&(M+=1);let w=e&&d>0?M/d:e?0:1,S=Math.min(s,t.samplePathLength??Math.min(s,50)),v=0,E=0,k=0,L=Math.max(1,Math.floor(s/S));for(let T=0;T<s&&T/L<S;T+=L){let C=o[T],P=new Map;P.set(C,0);let _=[C],z=0;for(;z<_.length;){let j=_[z];z+=1;let X=P.get(j),J=r.get(j)??new Set;for(let K of J)if(!P.has(K)){let V=X+1;P.set(K,V),_.push(K),v+=V,E+=1,V>k&&(k=V);}}}let B=E>0?v/E:0,Y=0;if(n.length>1){let T=[],C=[];for(let D of n)T.push(r.get(D.from)?.size??0),C.push(r.get(D.to)?.size??0);let P=T.length,_=0,z=0,j=0,X=0,J=0;for(let D=0;D<P;D+=1)_+=T[D],z+=C[D],j+=T[D]*C[D],X+=T[D]*T[D],J+=C[D]*C[D];let K=P*j-_*z,V=Math.sqrt((P*X-_*_)*(P*J-z*z));Y=V>0?K/V:0;}return {nodeCount:s,edgeCount:d,density:h,degreeDistribution:p.describe(),inDegreeDistribution:b.describe(),outDegreeDistribution:I.describe(),clusteringCoefficients:m,globalClusteringCoefficient:x,clusteringDistribution:y.describe(),averagePathLength:B,diameter:k,reciprocity:w,degreeAssortativity:Y}}function Dt(c,n,t={}){let e=t.method??"combined",o=t.threshold??2,r=false,{nodeIds:i,outNeighbors:a}=le(c,n,r),s=[];if(e==="degree"||e==="combined"){let d=i.map(g=>a.get(g)?.size??0),u=new O({data:d}),h=u.mean(),l=u.stddev();if(l>0)for(let g=0;g<i.length;g+=1){let N=Math.abs(d[g]-h)/l;N>o&&s.push({nodeId:i[g],score:N,reason:`degree outlier (z=${N.toFixed(2)}, degree=${d[g]})`});}}if(e==="clustering"||e==="combined"){let d=Se(c,n,{directed:r}),u=Array.from(d.values()),h=new O({data:u.length>0?u:[0]}),l=h.mean(),g=h.stddev();if(g>0){for(let p of i){let b=d.get(p)??0,I=Math.abs(b-l)/g;if(I>o){let m=s.find(f=>f.nodeId===p);m?(m.score=Math.max(m.score,I),m.reason+=`; clustering outlier (z=${I.toFixed(2)}, cc=${b.toFixed(3)})`):s.push({nodeId:p,score:I,reason:`clustering outlier (z=${I.toFixed(2)}, cc=${b.toFixed(3)})`});}}}}return s.sort((d,u)=>u.score-d.score)}var H=100,st=0,Ie=1e3,he=1.5,ve=1,Ee=2,oe=2;function Re(c=H){return Math.floor(Math.random()*c)}function Ae(c=Ie,n=H){let t=[];for(let e=0;e<c;e++)t.push(Re(n));return t}function Te(c=oe,n=H){let t=[];for(let e=0;e<c;e++)t.push(Math.floor(Math.random()*(n/10)%n));return t}function me(c=Ie,n=oe,t=H){let e=[];for(let o=0;o<c;o++)e.push(Te(n,t));return e}var O=class{data;constructor(n={}){this.data={original:n.data??Ae()};}sorted(){return this.data.sorted||(this.data.sorted=this.getSorted(this.data.original)),this.data.sorted}getSorted(n){return [...n].sort((t,e)=>t>e?1:t===e?0:-1)}median(){return this.sorted(),this.data.median===void 0&&(this.data.median=this.getMedian(this.data.sorted)),this.data.medianDepth===void 0&&(this.data.medianDepth=this.getMedianDepth(this.data.sorted)),{datum:this.data.median,depth:this.data.medianDepth}}getMedianDepth(n,t=0){return n.length?t+(n.length+1)/2:NaN}getMedian(n){let t=n.length;if(!t)return NaN;if(t===1)return n[0];let e=Math.floor(t/2);return t%2===0?(n[e-1]+n[e])/2:n[e]}mean(){return this.data.mean===void 0&&(this.data.mean=this.getMean(this.data.original)),this.data.mean}getMean(n){if(!n.length)return NaN;let t=0;for(let e of n)t+=e;return t/n.length}variance(){if(this.data.variance===void 0){let n=this.mean(),t=this.data.original;if(t.length<2)this.data.variance=NaN;else {let e=0;for(let o of t){let r=o-n;e+=r*r;}this.data.variance=e/(t.length-1);}}return this.data.variance}stddev(){return this.data.stddev===void 0&&(this.data.stddev=Math.sqrt(this.variance())),this.data.stddev}ema(n){let t=this.data.original;if(t.length===0)return [];let e=[t[0]];for(let o=1;o<t.length;o+=1){let r=e[o-1];e.push(r*(1-n)+t[o]*n);}return e}zscore(){let n=this.mean(),t=this.stddev();return t===0||isNaN(t)?this.data.original.map(()=>0):this.data.original.map(e=>(e-n)/t)}skewness(){if(this.data.skewness===void 0){let n=this.data.original,t=n.length;if(t<3)this.data.skewness=NaN;else {let e=this.mean(),o=this.stddev();if(o===0)this.data.skewness=0;else {let r=0;for(let i of n){let a=(i-e)/o;r+=a*a*a;}this.data.skewness=t/((t-1)*(t-2))*r;}}}return this.data.skewness}kurtosis(){if(this.data.kurtosis===void 0){let n=this.data.original,t=n.length;if(t<4)this.data.kurtosis=NaN;else {let e=this.mean(),o=this.stddev();if(o===0)this.data.kurtosis=0;else {let r=0;for(let s of n){let d=(s-e)/o;r+=d*d*d*d;}let i=t*(t+1)/((t-1)*(t-2)*(t-3))*r,a=3*(t-1)*(t-1)/((t-2)*(t-3));this.data.kurtosis=i-a;}}}return this.data.kurtosis}mode(){return this.data.mode||(this.sorted(),this.data.mode=this.getMode(this.data.sorted)),this.data.mode}getMode(n){if(!n.length)return {count:0,data:[]};let t={},e=0;for(let r of n)t[r]=(t[r]||0)+1,t[r]>e&&(e=t[r]);let o=[];for(let[r,i]of Object.entries(t))i===e&&o.push(Number(r));return {count:e,data:o.sort((r,i)=>r-i)}}extremes(){return this.data.extremes||(this.sorted(),this.data.extremes=this.getExtremes(this.data.sorted)),this.data.extremes}getExtremes(n){return n.length?[n[0],n[n.length-1]]:[]}counts(){return this.data.counts||(this.sorted(),this.data.counts=this.getCounts(this.data.sorted)),this.data.counts}getCounts(n){let t=new Map;for(let o of n)t.set(o,(t.get(o)||0)+1);let e=[];for(let[o,r]of t)e.push([o,r]);return e.sort((o,r)=>o[0]-r[0])}hinges(){return this.data.hinges||(this.sorted(),this.data.hinges=this.getHinges(this.data.sorted)),this.data.hinges}getHinges(n,t=2,e=[]){let o=[...n],r=o.length,i=t;if(i%2!==0&&i++,r<=i||i<=0)return e;let a=Math.floor(r/i),s=Math.floor(r/a)-1;for(let d=0;d<=s;d++){let u=o.slice(d*a,d*a+a);e.push({datum:this.getMedian(u),depth:this.getMedianDepth(u,d*a)});}return e}iqr(){return this.data.iqr===void 0&&(this.hinges(),this.data.iqr=this.getIQR(this.data.hinges)),this.data.iqr}getIQR(n){let t=n[0]?.datum,e=n[1]?.datum;return t===void 0||e===void 0?NaN:Math.abs(t-e)}fences(){return this.data.fences||(this.median(),this.iqr(),this.data.fences=this.getFences()),this.data.fences}getFences(n=he){let t=this.data.median,e=this.data.iqr;if(t===void 0||e===void 0||isNaN(e))return [];let o=e*n;return [t-o,t+o]}outer(){return this.data.outer||(this.median(),this.iqr(),this.data.outer=this.getOuter()),this.data.outer}getOuter(n=he){let t=this.data.median,e=this.data.iqr;if(t===void 0||e===void 0||isNaN(e))return [];let o=2*e*n;return [t-o,t+o]}outside(){return this.data.outside||(this.outer(),this.data.outside=this.getOutside()),this.data.outside}getOutside(){let n=[],t=this.data.sorted,e=this.data.outer;if(!e||e.length===0)return [];let o=Math.min(...e),r=Math.max(...e);for(let i of t)(i>r||i<o)&&n.push(i);return n}inside(){return this.data.inside||(this.fences(),this.data.inside=this.getInside()),this.data.inside}getInside(){let n=[],t=this.data.sorted,e=this.data.fences;if(!e||e.length===0)return [];let o=Math.min(...e),r=Math.max(...e);for(let i of t)i<r&&i>o&&n.push(i);return n}outliers(){return this.data.outliers||(this.fences(),this.data.outliers=this.getOutliers()),this.data.outliers}getOutliers(){let n=[],t=this.data.sorted,e=this.data.fences;if(e.length===0)return [];let o=Math.min(...e),r=Math.max(...e);for(let i of t)(i>r||i<o)&&n.push(i);return n}ranked(){return this.data.ranked||(this.sorted(),this.data.ranked=this.getRanked(this.data.sorted)),this.data.ranked}getRanked(n,t=true){let e={},o={},r=n.length,i=[],a=NaN,s=[],d=()=>{a=NaN,s=[];};for(let h=0;h<n.length;h++){let l=n[h];if(!t)e[l]={rank:h+1,peers:0},o[l]={rank:r-h,peers:0};else {let g=h+1,N=h-1;l===n[N]?(!isNaN(a)&&s.length===0?(s.push(l),i.push(s),d()):(s.push(l),a=N),l!==n[g]&&(i.push(s),d())):l!==n[g]?s.length>0?(i.push(s),d()):i.push(l):s.push(l);}}let u=0;for(let h=0;h<i.length;h++){let l=i[h];if(typeof l=="number")o[l]={rank:h+1+u,peers:0},e[l]={rank:r-h-u,peers:0};else if(Array.isArray(l)){u+=l.length;let g=l[0];o[g]={rank:h+1+u,peers:l.length},e[g]={rank:r-h-u,peers:l.length};}else u+=1;}return {up:e,down:o,groups:{down:[...i],up:[...i].reverse()}}}adjacent(){return this.data.adjacent||(this.fences(),this.data.adjacent=this.getAdjacent(this.data.sorted,this.data.fences)),this.data.adjacent}getAdjacent(n,t){if(t.length===0)return [];let e=t[0],o=[],r=t[1],i=[];for(let a of n)a>e&&o.push(a),a<r&&i.push(a);return o.sort((a,s)=>a-s),i.sort((a,s)=>a-s),[o[0],i[i.length-1]]}binned(n=NaN){return this.data.binned||(this.sorted(),this.extremes(),this.data.binned=this.getBinned(this.data.sorted,n)),this.data.binned}getBinned(n,t=10,e=NaN,o=true){let r={},i=n.length,a=o?0:1;if(i===0)return {bins:0,width:NaN,binned:{}};let s=this.data.extremes,d=e;if(s&&isNaN(d)&&s.length===2){d=(s[1]-s[0])/(Math.log(n.length)/Math.LN2),d=Math.floor(d);let h=true;for(let l of n)if(l%1!==0){h=false;break}h&&(d=Math.floor(d));}let u=Math.floor(s[1]/d)+1;(!u||u<1)&&(u=1);for(let h of n){let l=Math.floor((h-a)/d);r[l]||(r[l]={from:l*d+a,to:(l+1)*d+a-1,data:[]}),r[l].data.push(h);}return {bins:u,width:d,binned:r}}logs(){return this.data.logs||(this.data.logs=this.getLogs(this.data.original)),this.data.logs}getLogs(n){return n.map(t=>Math.log(t))}roots(){return this.data.roots||(this.data.roots=this.getRoots(this.data.original)),this.data.roots}getRoots(n){return n.map(t=>Math.sqrt(t))}inverse(){return this.data.inverse||(this.data.inverse=this.getInverse(this.data.original)),this.data.inverse}getInverse(n){return n.map(t=>1/t)}hanning(){return this.data.hanning||(this.data.hanning=this.getSkipMeans(this.data.original)),this.data.hanning}getSkipMeans(n){let t=[];for(let e=0;e<n.length;e++)e!==0&&e!==n.length-1&&t.push((n[e]+n[e+1])/2);return t.unshift(n[0]),t.push(n[n.length-1]),t}smooth(){return this.data.smooth||(this.sorted(),this.data.smooth=this.getSmooth(this.data.original)),this.data.rough=this.getRough(this.data.original,this.data.smooth),this.data.smooth}getRough(n,t){let e=[];for(let o=0;o<n.length;o++)e.push(n[o]-t[o]);return e}getSmooth(n,t=3){let e=[...n];return e=this.smoothMedian(e,t),e=this.smoothExtremes(e,-1),e=this.smoothSplit(e,2),e=this.smoothMedian(e,t),e=this.smoothExtremes(e,-1),e=this.smoothMedian(e,t),e}smoothExtremes(n,t=1,e=0,o="both"){let r=n.length;if(r<=2)return [...n];let i=[...n];for(let a=e;a<t||t===-1;a++){let s=false;if(o==="both"||o==="head"){let d=i[0],u=i[1],h=i[2],l=u-2*(h-u),g=d<=u?u<=l?u:d<=l?l:d:d<=l?d:u<=l?l:u;i[0]!==g&&(i[0]=g,s=true);}if(o==="both"||o==="tail"){let d=i[r-3],u=i[r-2],h=i[r-1],l=u-2*(d-u),g=h<=u?u<=l?u:h<=l?l:h:h<=l?h:u<=l?l:u;i[r-1]!==g&&(i[r-1]=g,s=true);}if(t===-1&&!s)break}return i}smoothSplit(n,t=Ee,e=0){let o=[...n],r=n.length;for(let i=e;i<t||t===-1;i++){let a=false;for(let s=2;s<r-1;s++){let d=o[s],u=o[s-1],h=o[s-2],l=o[s+1];if(d===u&&(u>h&&d>l||u<h&&d<l)){let g=this.smoothExtremes(o.slice(0,s)),N=this.smoothExtremes(o.slice(s));o=g.concat(N),a=true;}}if(t===-1&&!a)return o}return o}smoothMedian(n,t=1,e=0){let o=n,r=n.length;if(r<=2)return [...n];for(let i=e;i<t||t===-1;i++){let a=new Array(r);a[0]=o[0],a[r-1]=o[r-1];let s=false;for(let d=1;d<r-1;d++){let u=o[d],h=Math.min(Math.max(o[d-1],u),o[d+1]);a[d]=h,h!==u&&(s=true);}if(t===-1&&!s)return o;o=a;}return o}jitter(n,t=1,e=NaN,o=ve,r=NaN,i=0){let a=i+1,s=[...n];if(a<=t){let d=[];for(let u of s){let h=r;!h&&!isNaN(h)&&(h=(1+Math.floor(u/10))*(Math.random()>.5?1:-1));let l=u+Math.floor(Math.random()*o*h);!isNaN(e)&&l<e&&(l=e),d.push(l);}return this.jitter(d,t,e,o,r,a)}return s}trimean(){let n=this.median(),t=this.hinges();return t.length<2?n.datum:(t[0].datum+2*n.datum+t[1].datum)/4}letterValues(){this.sorted();let n=this.data.sorted.length;if(n<2)return [];let t=["M","F","E","D","C","B","A","Z","Y","X","W","V","U","T","S"],e=[],o=(n+1)/2,r=this.median().datum;e.push({letter:"M",depth:o,lower:r,upper:r,mid:r,spread:0});let i=o,a=1;for(;i>1&&a<t.length&&(i=Math.floor((Math.floor(i)+1)/2),!(i<1));){let s=Math.ceil(i)-1,d=n-Math.ceil(i);if(s<0||d>=n||s>=d)break;let u=this.data.sorted[s],h=this.data.sorted[d],l=(u+h)/2,g=h-u;e.push({letter:t[a],depth:i,lower:u,upper:h,mid:l,spread:g}),a++;}return e}rough(){return this.data.rough||this.smooth(),this.data.rough||[]}stemLeaf(n=1){this.sorted();let t=this.data.sorted;if(!t.length)return {stems:[],leaves:{},display:[]};let e=Math.pow(10,n),o=new Map;for(let d of t){let u=Math.floor(d/e),h=Math.abs(Math.round(d%e));o.has(u)||o.set(u,[]),o.get(u).push(h);}let r=Array.from(o.keys()).sort((d,u)=>d-u),i=[],a={},s=[];for(let d of r){let u=String(d);i.push(u);let h=o.get(d).sort((l,g)=>l-g).map(String);a[u]=h,s.push(`${u.padStart(4)} | ${h.join(" ")}`);}return {stems:i,leaves:a,display:s}}midSummaries(){return this.letterValues().map(({depth:t,mid:e,spread:o})=>({depth:t,mid:e,spread:o}))}describe(){return this.data.description={original:this.data.original,summary:{median:this.median(),mean:this.mean(),mode:this.mode(),hinges:this.hinges(),adjacent:this.adjacent(),outliers:this.outliers(),outer:this.outer(),outside:this.outside(),inside:this.inside(),extremes:this.extremes(),iqr:this.iqr(),fences:this.fences()},smooths:{smooth:this.smooth(),hanning:this.hanning()},transforms:{logs:this.logs(),roots:this.roots(),inverse:this.inverse()},counts:this.counts(),sorted:this.sorted(),ranked:this.ranked(),binned:this.binned()},this.data.description}},fe=class c{data;dimension;count;constructor(n={}){typeof n=="number"?(this.count=n,this.dimension=oe,this.data={original:me(this.count,this.dimension)}):(this.dimension=n.dimensionality??2,this.count=n.count??100,this.data={original:n.data??me(this.count,this.dimension)},n.data&&n.data.length>0&&(this.dimension=n.data[0].length,this.count=n.data.length));}centroid(){if(!this.data.centroid){let n=this.data.original,t=this.dimension,e=n.length;if(e===0)return this.data.centroid=[],this.data.centroid;let o=new Array(t).fill(0);for(let r of n)for(let i=0;i<t;i+=1)o[i]+=r[i]??0;this.data.centroid=o.map(r=>r/e);}return this.data.centroid}variances(){if(!this.data.variances){let n=this.data.original,t=this.dimension,e=n.length;if(e<2)return this.data.variances=new Array(t).fill(NaN),this.data.variances;let o=this.centroid(),r=new Array(t).fill(0);for(let i of n)for(let a=0;a<t;a+=1){let s=(i[a]??0)-o[a];r[a]+=s*s;}this.data.variances=r.map(i=>i/(e-1));}return this.data.variances}standardDeviations(){return this.data.stddevs||(this.data.stddevs=this.variances().map(n=>Math.sqrt(n))),this.data.stddevs}covarianceMatrix(){if(!this.data.covarianceMatrix){let n=this.data.original,t=this.dimension,e=n.length,o=this.centroid(),r=Array.from({length:t},()=>new Array(t).fill(0));if(e<2)return this.data.covarianceMatrix=r,this.data.covarianceMatrix;for(let i of n)for(let a=0;a<t;a+=1){let s=(i[a]??0)-o[a];for(let d=a;d<t;d+=1){let u=(i[d]??0)-o[d];r[a][d]+=s*u;}}for(let i=0;i<t;i+=1)for(let a=i;a<t;a+=1)r[i][a]/=e-1,r[a][i]=r[i][a];this.data.covarianceMatrix=r;}return this.data.covarianceMatrix}correlationMatrix(){if(!this.data.correlationMatrix){let n=this.covarianceMatrix(),t=this.dimension,e=this.standardDeviations(),o=Array.from({length:t},()=>new Array(t).fill(0));for(let r=0;r<t;r+=1)for(let i=0;i<t;i+=1){let a=e[r]*e[i];o[r][i]=a===0?r===i?1:0:n[r][i]/a;}this.data.correlationMatrix=o;}return this.data.correlationMatrix}mahalanobis(n){let t=this.centroid(),e=this.variances(),o=Math.min(n.length,t.length,e.length);if(o===0)return 0;let r=0;for(let i=0;i<o;i+=1){let a=(n[i]??0)-t[i],s=Math.max(e[i],1e-8);r+=a*a/s;}return Math.sqrt(r)}mahalanobisAll(){if(!this.data.mahalanobisDistances){let n=this.centroid(),t=this.variances();this.data.mahalanobisDistances=this.data.original.map(e=>{let o=Math.min(e.length,n.length,t.length),r=0;for(let i=0;i<o;i+=1){let a=(e[i]??0)-n[i],s=Math.max(t[i],1e-8);r+=a*a/s;}return Math.sqrt(r)});}return this.data.mahalanobisDistances}outliersByMahalanobis(n=3){let t=this.mahalanobisAll(),e=[];for(let o=0;o<t.length;o+=1)t[o]>n&&e.push(this.data.original[o]);return e}normalizeL2(){let n=this.data.original.map(t=>{let e=0;for(let r of t)e+=r*r;let o=Math.sqrt(e);return o===0?t.map(()=>0):t.map(r=>r/o)});return new c({data:n})}normalizeZscore(){let n=this.centroid(),t=this.standardDeviations(),e=this.dimension,o=this.data.original.map(r=>{let i=new Array(e);for(let a=0;a<e;a+=1){let s=t[a];i[a]=s===0||isNaN(s)?0:((r[a]??0)-n[a])/s;}return i});return new c({data:o})}describe(){let n=this.mahalanobisAll(),t=n.filter(r=>r>3).length,e=this.dimension,o=[];for(let r=0;r<e;r+=1){let i=this.data.original.map(s=>s[r]??0),a=new O({data:i});o.push(a.describe());}return this.data.description={original:this.data.original,centroid:this.centroid(),variances:this.variances(),correlationMatrix:this.correlationMatrix(),mahalanobisDistances:n,outlierCount:t,dimensionSummaries:o},this.data.description}},ge=class{smoothed=false;static DEFAULT_MAX_RANDOM_INTEGER=H;static DEFAULT_MIN_RANDOM_INTEGER=st;static DEFAULT_RANDOM_SERIES_COUNT=Ie;static DEFAULT_OUTLIER_MULTIPLE=he;static DEFAULT_JITTER_MULTIPLIER=ve;static DEFAULT_SPLIT_PASSES=Ee;static DEFAULT_MAX_RANDOM_DIMENSIONALITY=oe;static Series=O;static Points=fe;static randomInteger=Re;static randomSeries=Ae;static randomPoint=Te;static randomPoints=me},Ft=ge;export{A as GraphAlgorithmError,fe as Points,O as Series,ge as Twokeys,Mt as aStarShortestPath,wt as allPairsShortestPaths,gt as analyzeGraph,tt as articulationPointsAndBridges,Ze as betweennessCentrality,G as buildGraphAdjacency,Qe as closenessCentrality,Se as clusteringCoefficient,re as cosineSimilarity,at as cosineSimilaritySparse,Tt as dbscan,Ft as default,Je as degreeCentrality,U as euclideanDistance,Ct as graphEda,Dt as graphOutliers,At as hierarchicalClustering,ct as jaccardSimilarity,Et as kMeansAuto,ot as kMeansClustering,pt as kNearestNeighbors,It as labelPropagationCommunities,xt as linkPrediction,Nt as louvainCommunities,it as mahalanobisDistance,se as manhattanDistance,St as maximumFlow,vt as minCostMaxFlow,ft as minimumSpanningTree,bt as nodeSimilarity,dt as normalizeL2,ut as overlapCoefficient,et as pageRank,nt as predictLinks,be as shortestPath,q as squaredEuclideanDistance,ye as stronglyConnectedComponents,mt as topologicalSort,Rt as travelingSalesmanApprox,Xe as weaklyConnectedComponents,yt as yenKShortestPaths};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map