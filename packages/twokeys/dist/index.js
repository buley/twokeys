function se(c,n){let t=Math.min(c.length,n.length);if(t===0)return 0;let e=0,o=0,r=0;for(let a=0;a<t;a+=1){let s=c[a]??0,d=n[a]??0;e+=s*d,o+=s*s,r+=d*d;}let i=Math.sqrt(o)*Math.sqrt(r);return i===0?0:e/i}function V(c,n){let t=0,e=Math.max(c.length,n.length);for(let o=0;o<e;o+=1){let r=(c[o]??0)-(n[o]??0);t+=r*r;}return t}function U(c,n){return Math.sqrt(V(c,n))}function ie(c,n){let t=0,e=Math.max(c.length,n.length);for(let o=0;o<e;o+=1)t+=Math.abs((c[o]??0)-(n[o]??0));return t}function It(c,n,t,e=1e-8){let o=Math.min(c.length,n.length,t.length);if(o===0)return 0;let r=0;for(let i=0;i<o;i+=1){let a=(c[i]??0)-(n[i]??0),s=Math.max(t[i]??0,e);r+=a*a/s;}return Math.sqrt(r)}function pt(c){let n=0;for(let e=0;e<c.length;e+=1){let o=c[e]??0;n+=o*o;}let t=Math.sqrt(n);return t===0?c.map(()=>0):c.map(e=>(e??0)/t)}function bt(c,n){if(c.size===0||n.size===0)return 0;let t=0,e=0,o=0,[r,i]=c.size<=n.size?[c,n]:[n,c];for(let[s,d]of r){let u=i.get(s);u!==void 0&&(t+=d*u),e+=d*d;}for(let s of i.values())o+=s*s;let a=Math.sqrt(e)*Math.sqrt(o);return a===0?0:t/a}function xt(c,n){if(c.size===0||n.size===0)return 0;let t=0,[e,o]=c.size<=n.size?[c,n]:[n,c];for(let i of e)o.has(i)&&(t+=1);let r=c.size+n.size-t;return r<=0?0:t/r}function Mt(c,n){if(c.size===0||n.size===0)return 0;let t=0,[e,o]=c.size<=n.size?[c,n]:[n,c];for(let i of e)o.has(i)&&(t+=1);let r=Math.min(c.size,n.size);return r<=0?0:t/r}var R=class extends Error{code;constructor(n,t){super(t),this.name="GraphAlgorithmError",this.code=n;}},W=class{heap=[];get size(){return this.heap.length}push(n,t){this.heap.push({priority:t,value:n}),this.siftUp(this.heap.length-1);}pop(){if(this.heap.length===0)return;let n=this.heap[0],t=this.heap.pop();return this.heap.length>0&&t&&(this.heap[0]=t,this.siftDown(0)),n}siftUp(n){let t=n;for(;t>0;){let e=Math.floor((t-1)/2),o=this.heap[t],r=this.heap[e];if(!o||!r||r.priority<=o.priority)return;this.heap[e]=o,this.heap[t]=r,t=e;}}siftDown(n){let t=n;for(;;){let e=t*2+1,o=t*2+2,r=t,i=this.heap[r],a=this.heap[e],s=this.heap[o];i&&a&&a.priority<i.priority&&(r=e);let d=this.heap[r];if(d&&s&&s.priority<d.priority&&(r=o),r===t)return;let u=this.heap[t],h=this.heap[r];if(!u||!h)return;this.heap[t]=h,this.heap[r]=u,t=r;}}};function A(c,n){return c.localeCompare(n)}function te(c,n){return A(c,n)<=0?{from:c,to:n}:{from:n,to:c}}function $(c,n){let t=te(c,n);return `${t.from}\0${t.to}`}function Ve(c){return typeof c=="string"?c:c.id}var de=class{parent=new Map;rank=new Map;constructor(n){for(let t of n)this.parent.set(t,t),this.rank.set(t,0);}find(n){let t=this.parent.get(n);if(!t||t===n)return n;let e=this.find(t);return this.parent.set(n,e),e}union(n,t){let e=this.find(n),o=this.find(t);if(e===o)return  false;let r=this.rank.get(e)??0,i=this.rank.get(o)??0;return r<i?(this.parent.set(e,o),true):r>i?(this.parent.set(o,e),true):(this.parent.set(o,e),this.rank.set(e,r+1),true)}};function ne(c,n){let t=new Set,e=[];for(let o of c){let r=Ve(o);t.has(r)||(t.add(r),e.push(r));}for(let o of n)t.has(o.from)||(t.add(o.from),e.push(o.from)),t.has(o.to)||(t.add(o.to),e.push(o.to));return e}function qe(c){if(c===void 0)return 1;if(!Number.isFinite(c))throw new R("INVALID_ARGUMENT",`Graph edge weight must be finite, received ${c}`);return c}function Ke(c){let n=new Map;for(let t of c)n.set(t,new Map);return n}function Me(c,n,t,e){let o=c.get(n);if(!o)return;let r=o.get(t);(r===void 0||e<r)&&o.set(t,e);}function Ye(c,n,t){let e=Ke(c);for(let o of n){if(o.from===o.to)continue;let r=qe(o.weight);!e.has(o.from)||!e.has(o.to)||(Me(e,o.from,o.to,r),t||Me(e,o.to,o.from,r));}return e}function Ue(c){let n=new Map;for(let[t,e]of c.entries()){let o=[];for(let[r,i]of e.entries())o.push({id:r,weight:i});n.set(t,o);}return n}function We(c,n){let t=new Map;for(let e of c)t.set(e,[]);for(let[e,o]of n.entries())for(let r of o){let i=t.get(r.id);i&&i.push({id:e,weight:r.weight});}return t}function $e(c){let n=[];for(let[t,e]of c.entries())for(let o of e)n.push({from:t,to:o.id,weight:o.weight});return n}function D(c){for(let n of c.edges)if(n.weight<0)return  true;return  false}function ue(c,n,t){if(c===n)return [c];let e=[n],o=n;for(;o&&o!==c;){let r=t.get(o);if(!r)return [];e.push(r),o=r;}return e.reverse(),e[0]===c?e:[]}function ye(c){return c.reduce((n,t)=>n+t.weight,0)}function He(c){let n=new Map;for(let t of c.edges){let e=te(t.from,t.to),o=$(e.from,e.to),r=n.get(o);(!r||t.weight<r.weight-1e-12)&&n.set(o,{from:e.from,to:e.to,weight:t.weight});}return Array.from(n.values())}function Xe(c,n){let t=He(c),e=0;for(let s of t)e+=s.weight;if(!Number.isFinite(e)||e<=0)return 0;let o=new Map;for(let s of c.nodes)o.set(s,ye(c.neighborsByNode.get(s)??[]));let r=new Map,i=new Map;for(let s of c.nodes){let d=n.get(s);if(d===void 0)continue;let u=o.get(s)??0;r.set(d,(r.get(d)??0)+u);}for(let s of t){let d=n.get(s.from),u=n.get(s.to);d===void 0||u===void 0||d===u&&i.set(d,(i.get(d)??0)+s.weight);}let a=0;for(let[s,d]of r.entries()){let u=i.get(s)??0;a+=u/e-Math.pow(d/(2*e),2);}return a}function ae(c,n,t,e,o){let r=new Map;for(let s of c.nodes){let d=n.get(s);if(d===void 0)continue;let u=r.get(d)??[];u.push(s),r.set(d,u);}let i=Array.from(r.values()).map(s=>[...s].sort(A));i.sort((s,d)=>A(s[0]??"",d[0]??""));let a=new Map;for(let s=0;s<i.length;s+=1)for(let d of i[s]??[])a.set(d,s);return {communities:i,communityByNode:a,iterations:t,converged:e,algorithm:o,modularity:Xe(c,a)}}function le(c){let n=new Map;for(let t of c.nodes)n.set(t,new Set);for(let[t,e]of c.neighborsByNode.entries()){let o=n.get(t);if(o)for(let r of e)o.add(r.id);}return n}function Z(c,n,t,e){let o=t.get(c)??new Set,r=t.get(n)??new Set,i=o.size,a=r.size,s=i<=a?o:r,d=s===o?r:o,u=0,h=0,l=0;for(let I of s){if(!d.has(I))continue;u+=1;let b=t.get(I)?.size??0;b>1&&(h+=1/Math.log(b)),b>0&&(l+=1/b);}if(e==="common-neighbors")return u;if(e==="preferential-attachment")return i*a;if(e==="adamic-adar")return h;if(e==="resource-allocation")return l;if(e==="jaccard"){let I=i+a-u;return I>0?u/I:0}if(e==="cosine")return i>0&&a>0?u/Math.sqrt(i*a):0;let f=Math.min(i,a);return f>0?u/f:0}function Je(c,n){if(c.length<=1)return 0;let t=0;for(let e=1;e<c.length;e+=1){let o=c[e-1],r=c[e];if(!o||!r)return Number.POSITIVE_INFINITY;let i=n.neighborsByNode.get(o)?.find(a=>a.id===r)?.weight;if(i===void 0||!Number.isFinite(i))return Number.POSITIVE_INFINITY;t+=i;}return t}function Q(c){return c.join("\0")}function Qe(c,n){if(n.length>c.length)return  false;for(let t=0;t<n.length;t+=1)if(c[t]!==n[t])return  false;return  true}function we(c,n){return c==="auto"?n?"bellman-ford":"dijkstra":c}function Ze(c,n){if(D(c))throw new R("NEGATIVE_WEIGHT","Dijkstra cannot run on negative graph weights.");let t=new Map,e=new Map,o=new Set,r=new W;for(let i of c.nodes)t.set(i,Number.POSITIVE_INFINITY);for(t.set(n,0),r.push(n,0);r.size>0;){let i=r.pop();if(!i)break;let a=i.value;if(o.has(a))continue;o.add(a);let s=t.get(a);if(s===void 0||!Number.isFinite(s))continue;let d=c.neighborsByNode.get(a)??[];for(let u of d){let h=s+u.weight,l=t.get(u.id);(l===void 0||h<l-1e-12)&&(t.set(u.id,h),e.set(u.id,a),r.push(u.id,h));}}return {distanceByNode:t,previousByNode:e,explored:o.size,negativeCycleNodes:new Set}}function et(c,n){let t=new Map,e=new Map;for(let d of c.nodes)t.set(d,Number.POSITIVE_INFINITY);t.set(n,0);let o=c.nodes.length;for(let d=0;d<o-1;d+=1){let u=false;for(let h of c.edges){let l=t.get(h.from);if(l===void 0||!Number.isFinite(l))continue;let f=l+h.weight,I=t.get(h.to);(I===void 0||f<I-1e-12)&&(t.set(h.to,f),e.set(h.to,h.from),u=true);}if(!u)break}let r=new Set,i=[];for(let d of c.edges){let u=t.get(d.from),h=t.get(d.to);u!==void 0&&Number.isFinite(u)&&h!==void 0&&u+d.weight<h-1e-12&&(r.has(d.to)||(r.add(d.to),i.push(d.to)),r.has(d.from)||(r.add(d.from),i.push(d.from)));}let a=0;for(;a<i.length;){let d=i[a];if(a+=1,!!d)for(let u of c.neighborsByNode.get(d)??[])r.has(u.id)||(r.add(u.id),i.push(u.id));}if(r.size>0)for(let d of r)t.set(d,Number.NEGATIVE_INFINITY),e.delete(d);let s=0;for(let d of c.nodes){let u=t.get(d);u!==void 0&&Number.isFinite(u)&&(s+=1);}return {distanceByNode:t,previousByNode:e,explored:s,negativeCycleNodes:r}}function oe(c,n,t){let e=D(c),o=we(t,e);return o==="dijkstra"?{algorithm:o,result:Ze(c,n),hasNegativeWeights:e}:{algorithm:o,result:et(c,n),hasNegativeWeights:e}}function Se(c){if(c===void 0||!Number.isFinite(c))return Math.random;let n=Math.floor(c)>>>0||1;return ()=>(n=n*1664525+1013904223>>>0,n/4294967296)}function tt(c,n){let t=c[0]?.length??0;if(n==="none")return {normalize:s=>[...s],denormalize:s=>[...s]};let e=new Array(t).fill(0),o=new Array(t).fill(Number.POSITIVE_INFINITY),r=new Array(t).fill(Number.NEGATIVE_INFINITY);for(let s of c)for(let d=0;d<t;d+=1){let u=s[d]??0;e[d]=(e[d]??0)+u,o[d]=Math.min(o[d]??u,u),r[d]=Math.max(r[d]??u,u);}for(let s=0;s<t;s+=1)e[s]=(e[s]??0)/c.length;if(n==="minmax"){let s=r.map((d,u)=>{let h=o[u]??0;return d-h});return {normalize:d=>d.map((u,h)=>{let l=o[h]??0,f=s[h]??0;return Math.abs(f)<1e-12?0:(u-l)/f}),denormalize:d=>d.map((u,h)=>{let l=o[h]??0,f=s[h]??0;return u*f+l})}}let i=new Array(t).fill(0);for(let s of c)for(let d=0;d<t;d+=1){let u=(s[d]??0)-(e[d]??0);i[d]=(i[d]??0)+u*u;}let a=i.map(s=>Math.sqrt(s/c.length));return {normalize:s=>s.map((d,u)=>{let h=a[u]??0;return h<1e-12?0:(d-(e[u]??0))/h}),denormalize:s=>s.map((d,u)=>{let h=a[u]??0;return d*h+(e[u]??0)})}}function nt(c,n,t,e){if(c.length===0)return [];if(!e){let a=[],s=new Set;for(;a.length<n;){let d=Math.floor(t()*c.length);s.has(d)||(s.add(d),a.push([...c[d]??c[0]??[]]));}return a}let o=[],r=new Set,i=Math.floor(t()*c.length);for(r.add(i),o.push([...c[i]??c[0]??[]]);o.length<n;){let a=new Array(c.length).fill(0),s=0;for(let l=0;l<c.length;l+=1){if(r.has(l))continue;let f=c[l];if(!f)continue;let I=Number.POSITIVE_INFINITY;for(let b of o)I=Math.min(I,V(f,b));a[l]=I,s+=I;}if(!Number.isFinite(s)||s<=0){for(let l=0;l<c.length;l+=1)if(!r.has(l)){r.add(l),o.push([...c[l]??c[0]??[]]);break}continue}let d=t()*s,u=0,h=-1;for(let l=0;l<c.length;l+=1)if(!r.has(l)&&(u+=a[l]??0,u>=d)){h=l;break}if(h<0){for(let l=0;l<c.length;l+=1)if(!r.has(l)){h=l;break}}if(h<0)break;r.add(h),o.push([...c[h]??c[0]??[]]);}return o}function ot(c,n,t,e,o,r){let i=c[0]?.length??0,a=nt(c,n,t,r);if(a.length!==n)throw new R("INVALID_ARGUMENT","Unable to initialize centroids for k-means.");let s=new Array(c.length).fill(-1),d=0,u=false,h=Number.POSITIVE_INFINITY;for(;d<e;){d+=1;let l=false;h=0;for(let p=0;p<c.length;p+=1){let N=c[p];if(!N)continue;let m=0,g=Number.POSITIVE_INFINITY;for(let x=0;x<a.length;x+=1){let w=a[x];if(!w)continue;let M=V(N,w);M<g&&(g=M,m=x);}h+=g,s[p]!==m&&(s[p]=m,l=true);}let f=new Array(n),I=new Array(n).fill(0);for(let p=0;p<n;p+=1)f[p]=new Array(i).fill(0);for(let p=0;p<c.length;p+=1){let N=s[p];if(N<0)continue;let m=c[p],g=f[N];if(!(!m||!g)){I[N]=(I[N]??0)+1;for(let x=0;x<i;x+=1)g[x]=(g[x]??0)+(m[x]??0);}}for(let p=0;p<n;p+=1){let N=I[p]??0;if(N>0){let m=f[p];if(!m)continue;for(let g=0;g<i;g+=1)m[g]=(m[g]??0)/N;}else {let m=0,g=-1;for(let x=0;x<c.length;x+=1){let w=s[x],M=a[w],y=c[x];if(!M||!y)continue;let S=V(y,M);S>g&&(g=S,m=x);}f[p]=[...c[m]??c[0]??[]];}}let b=0;for(let p=0;p<n;p+=1){let N=a[p],m=f[p];!N||!m||(b=Math.max(b,Math.sqrt(V(N,m))));}if(a=f,!l||b<=o){u=true;break}}return {assignments:s,centroidsNormalized:a,iterations:d,inertia:h,converged:u}}function ve(c,n,t){if(c.length<=1||t<=1)return null;let e=Array.from({length:t},()=>[]);for(let i=0;i<n.length;i+=1){let a=n[i]??-1;if(a>=0&&a<t){let s=e[a];s&&s.push(i);}}let o=0,r=0;for(let i=0;i<c.length;i+=1){let a=c[i],s=n[i]??-1;if(!a||s<0||s>=t)continue;let d=e[s]??[];if(d.length<=1)continue;let u=0;for(let f of d){if(f===i)continue;let I=c[f];I&&(u+=U(a,I));}u/=d.length-1;let h=Number.POSITIVE_INFINITY;for(let f=0;f<t;f+=1){if(f===s)continue;let I=e[f]??[];if(I.length===0)continue;let b=0;for(let p of I){let N=c[p];N&&(b+=U(a,N));}b/=I.length,h=Math.min(h,b);}if(!Number.isFinite(h))continue;let l=Math.max(u,h);l<=0||(o+=(h-u)/l,r+=1);}return r===0?null:o/r}function ce(c,n){let t=0;for(let e=1;e<c.length;e+=1){let o=c[e-1],r=c[e];if(!o||!r)return Number.POSITIVE_INFINITY;let i=n.get(o)?.get(r);if(i===void 0||!Number.isFinite(i))return Number.POSITIVE_INFINITY;t+=i;}return t}function rt(c,n,t){if(c.length<4||t<=0)return c;let e=[...c],o=ce(e,n);if(!Number.isFinite(o))return e;for(let r=0;r<t;r+=1){let i=false;for(let a=1;a<e.length-2;a+=1)for(let s=a+1;s<e.length-1;s+=1){let d=e.slice(0,a),u=e.slice(a,s+1).reverse(),h=e.slice(s+1),l=d.concat(u,h),f=ce(l,n);f+1e-9<o&&(e=l,o=f,i=true);}if(!i)break}return e}function st(c,n){let t=[],e=new Set;n.start&&c.includes(n.start)&&(t.push(n.start),e.add(n.start));for(let a of n.startCandidates??[])c.includes(a)&&!e.has(a)&&(t.push(a),e.add(a));let o=Se(n.seed),r=c.filter(a=>!e.has(a));for(let a=r.length-1;a>0;a-=1){let s=Math.floor(o()*(a+1)),d=r[a],u=r[s];d!==void 0&&u!==void 0&&(r[a]=u,r[s]=d);}let i=Math.max(1,Math.min(c.length,n.multiStartCount??Math.min(8,c.length)));for(let a of r){if(t.length>=i)break;t.push(a);}return t.length===0&&c.length>0&&t.push(c[0]),t}function it(c,n,t,e){let o=[c],r=new Set(n.filter(a=>a!==c)),i=c;for(;r.size>0;){let a=null,s=Number.POSITIVE_INFINITY,d=t.get(i);for(let u of r){let h=d?.get(u)??Number.POSITIVE_INFINITY;h<s&&(s=h,a=u);}if(!a||!Number.isFinite(s))break;o.push(a),r.delete(a),i=a;}return e&&o.length>1&&o.push(c),o}function dt(c,n){if(c.length<=1)return 0;let t=new Set;t.add(c[0]);let e=0;for(;t.size<c.length;){let o=Number.POSITIVE_INFINITY,r=null;for(let i of t){let a=n.get(i);for(let s of c){if(t.has(s))continue;let d=a?.get(s)??Number.POSITIVE_INFINITY;d<o&&(o=d,r=s);}}if(!r||!Number.isFinite(o))return Number.POSITIVE_INFINITY;t.add(r),e+=o;}return e}function k(c,n,t={}){let e=t.directed??true,o=ne(c,n),r=Ye(o,n,e),i=Ue(r),a=We(o,i);return {nodes:o,neighborsByNode:i,incomingByNode:a,edges:$e(i),directed:e}}function Re(c,n,t={}){let e=k(c,n,t),o=[];if(e.directed){let i=0,a=new Map,s=new Map,d=[],u=new Set,h=l=>{a.set(l,i),s.set(l,i),i+=1,d.push(l),u.add(l);for(let f of e.neighborsByNode.get(l)??[])if(a.has(f.id)){if(u.has(f.id)){let I=s.get(l)??0,b=a.get(f.id)??0;s.set(l,Math.min(I,b));}}else {h(f.id);let I=s.get(l)??0,b=s.get(f.id)??0;s.set(l,Math.min(I,b));}if((s.get(l)??-1)===(a.get(l)??-2)){let f=[];for(;d.length>0;){let I=d.pop();if(!I||(u.delete(I),f.push(I),I===l))break}f.sort(A),o.push(f);}};for(let l of e.nodes)a.has(l)||h(l);}else {let i=new Set;for(let a of e.nodes){if(i.has(a))continue;let s=[a];i.add(a);let d=[],u=0;for(;u<s.length;){let h=s[u];if(u+=1,!!h){d.push(h);for(let l of e.neighborsByNode.get(h)??[])i.has(l.id)||(i.add(l.id),s.push(l.id));}}d.sort(A),o.push(d);}}o.sort((i,a)=>{let s=i[0]??"",d=a[0]??"";return A(s,d)});let r=new Map;for(let i=0;i<o.length;i+=1)for(let a of o[i]??[])r.set(a,i);return {components:o,componentByNode:r}}function at(c,n){let t=k(c,n,{directed:false}),e=[],o=new Map,r=new Set;for(let i of t.nodes){if(r.has(i))continue;let a=[i];r.add(i);let s=[],d=0;for(;d<a.length;){let h=a[d];if(d+=1,!!h){s.push(h);for(let l of t.neighborsByNode.get(h)??[])r.has(l.id)||(r.add(l.id),a.push(l.id));}}s.sort(A);let u=e.length;e.push(s);for(let h of s)o.set(h,u);}e.sort((i,a)=>{let s=i[0]??"",d=a[0]??"";return A(s,d)}),o.clear();for(let i=0;i<e.length;i+=1){let a=e[i]??[];for(let s of a)o.set(s,i);}return {components:e,componentByNode:o}}function St(c,n,t={}){let e=ne(c,n),o=t.tieBreaker??((N,m)=>A(N,m)),r=t.priorityByNode,i=t.priority??(N=>r instanceof Map?r.get(N)??0:r?r[N]??0:0),a=(N,m)=>{let g=i(m)-i(N);return Math.abs(g)>1e-12?g:o(N,m)},s=new Map,d=new Map;for(let N of e)s.set(N,new Set),d.set(N,0);for(let N of n){if(N.from===N.to||!s.has(N.from)||!s.has(N.to))continue;let m=s.get(N.from);!m||m.has(N.to)||(m.add(N.to),d.set(N.to,(d.get(N.to)??0)+1));}let u=e.filter(N=>(d.get(N)??0)===0).sort(a),h=[];for(;u.length>0;){let N=u.shift();if(!N)continue;h.push(N);let m=Array.from(s.get(N)??[]).sort(a);for(let g of m){let x=(d.get(g)??0)-1;d.set(g,x),x===0&&u.push(g);}u.sort(a);}let l=new Set(h),f=e.filter(N=>!l.has(N));f.sort(a);let I=Re(e,n,{directed:true}),b=new Set(n.filter(N=>N.from===N.to).map(N=>N.from)),p=new Set;for(let N of I.components)if(N.length>1)for(let m of N)p.add(m);else if(N.length===1){let m=N[0];m&&b.has(m)&&p.add(m);}for(let N of f)p.add(N);for(let N of f)l.has(N)||(h.push(N),l.add(N));return {order:h,cycleNodes:Array.from(p).sort(a),isDag:p.size===0}}function ct(c,n,t={}){let e=k(c,n,t),o=e.nodes.length,r=o<=1?1:e.directed?2*(o-1):Math.max(1,o-1),i=new Map;for(let a of e.nodes){let s=e.neighborsByNode.get(a)?.length??0,d=e.incomingByNode.get(a)?.length??0,u=e.directed?d+s:s;i.set(a,{inDegree:d,outDegree:s,degree:u,normalized:u/r});}return i}function ut(c,n,t={}){let e=k(c,n,t),o=e.nodes.length,r=Math.max(0,o-1),i=t.mode??"harmonic",a=new Map;for(let s of e.nodes){let d=oe(e,s,t.shortestPathAlgorithm??"auto"),u=d.result.distanceByNode,h=d.result.negativeCycleNodes.size>0,l=0,f=0,I=0;for(let N of e.nodes){if(N===s)continue;let m=u.get(N);m===void 0||!Number.isFinite(m)||m<=0||(l+=1,f+=m,I+=1/m);}let b=0,p=0;h||(i==="classic"?(b=l>0&&f>0?l/f:0,p=r>0?b*(l/r):0):(b=I,p=r>0?I/r:0)),a.set(s,{reachableCount:l,distanceSum:f,score:b,normalized:p,mode:i,negativeCycle:h});}return a}function lt(c,n,t={}){let e=k(c,n,t);if(D(e))throw new R("NEGATIVE_WEIGHT","Betweenness centrality requires non-negative graph weights.");let o=new Map;for(let s of e.nodes)o.set(s,0);for(let s of e.nodes){let d=[],u=new Map,h=new Map,l=new Map,f=new W,I=new Set;for(let p of e.nodes)u.set(p,[]),h.set(p,0),l.set(p,Number.POSITIVE_INFINITY);for(h.set(s,1),l.set(s,0),f.push(s,0);f.size>0;){let p=f.pop();if(!p)break;let N=p.value;if(I.has(N))continue;I.add(N),d.push(N);let m=l.get(N);if(m===void 0||!Number.isFinite(m))continue;let g=h.get(N)??0;for(let x of e.neighborsByNode.get(N)??[]){let w=m+x.weight,M=l.get(x.id);M===void 0||w<M-1e-12?(l.set(x.id,w),f.push(x.id,w),h.set(x.id,g),u.set(x.id,[N])):M!==void 0&&Math.abs(w-M)<=1e-12&&(h.set(x.id,(h.get(x.id)??0)+g),u.get(x.id)?.push(N));}}let b=new Map;for(let p of e.nodes)b.set(p,0);for(;d.length>0;){let p=d.pop();if(!p)continue;let N=h.get(p)??0,m=b.get(p)??0;for(let g of u.get(p)??[]){let x=h.get(g)??0;if(N<=0)continue;let w=x/N*(1+m);b.set(g,(b.get(g)??0)+w);}p!==s&&o.set(p,(o.get(p)??0)+m);}}if(!e.directed)for(let s of e.nodes)o.set(s,(o.get(s)??0)/2);let r=e.nodes.length,i=r<=2?Number.POSITIVE_INFINITY:e.directed?(r-1)*(r-2):(r-1)*(r-2)/2,a=new Map;for(let s of e.nodes){let d=o.get(s)??0;a.set(s,{raw:d,normalized:Number.isFinite(i)&&i>0?d/i:0});}return a}function he(c,n,t={}){let e=k(c,n,t);if(D(e))throw new R("NEGATIVE_WEIGHT","PageRank requires non-negative graph weights.");let o=e.nodes.length;if(o===0)return {byNode:new Map,order:[],iterations:0,converged:true,dampingFactor:t.dampingFactor??.85};let r=t.dampingFactor??.85;if(!Number.isFinite(r)||r<0||r>=1)throw new R("INVALID_ARGUMENT",`PageRank dampingFactor must be in [0, 1), received ${r}.`);let i=Math.max(0,t.tolerance??1e-9),a=Math.max(1,Math.floor(t.maxIterations??200)),s=1/o,d=new Map;for(let N of e.nodes){let m=(e.neighborsByNode.get(N)??[]).reduce((g,x)=>g+x.weight,0);d.set(N,m);}let u=new Map;for(let N of e.nodes)u.set(N,s);let h=0,l=false;for(let N=0;N<a;N+=1){h=N+1;let m=new Map,g=(1-r)/o,x=0;for(let y of e.nodes)(d.get(y)??0)<=1e-12&&(x+=u.get(y)??0),m.set(y,g);let w=r*x/o;if(w>0)for(let y of e.nodes)m.set(y,(m.get(y)??0)+w);for(let y of e.nodes){let S=d.get(y)??0;if(S<=1e-12)continue;let v=u.get(y)??0;for(let E of e.neighborsByNode.get(y)??[]){let G=r*v*E.weight/S;m.set(E.id,(m.get(E.id)??0)+G);}}let M=0;for(let y of e.nodes){let S=u.get(y)??0,v=m.get(y)??0;M+=Math.abs(S-v);}if(u=m,M<=i){l=true;break}}let f=0;for(let N of e.nodes)f+=u.get(N)??0;if(!Number.isFinite(f)||f<=0){u=new Map;for(let N of e.nodes)u.set(N,s);f=1;}else if(Math.abs(f-1)>1e-12)for(let N of e.nodes)u.set(N,(u.get(N)??0)/f);let I=[...e.nodes].sort((N,m)=>{let g=(u.get(m)??0)-(u.get(N)??0);return Math.abs(g)>1e-12?g:A(N,m)}),b=I.length>0?u.get(I[0])??0:0,p=new Map;for(let N=0;N<I.length;N+=1){let m=I[N];if(!m)continue;let g=u.get(m)??0;p.set(m,{score:g,normalized:b>0?g/b:0,rank:N+1});}return {byNode:p,order:I,iterations:h,converged:l,dampingFactor:r}}function vt(c,n,t={}){let e=k(c,n,{directed:false}),o=t.tieBreaker??((l,f)=>A(l,f)),r=new Map;for(let l of e.edges){if(l.from===l.to)continue;let f=te(l.from,l.to),I=$(f.from,f.to),b=r.get(I);(!b||l.weight<b.weight-1e-12)&&r.set(I,{from:f.from,to:f.to,weight:l.weight});}let i=Array.from(r.values());i.sort((l,f)=>{let I=l.weight-f.weight;if(Math.abs(I)>1e-12)return I;let b=o(l.from,f.from);return b!==0?b:o(l.to,f.to)});let a=new de(e.nodes),s=[],d=0;for(let l of i)a.union(l.from,l.to)&&(s.push(l),d+=l.weight);let u=new Set;for(let l of e.nodes)u.add(a.find(l));let h=u.size;return {edges:s,totalWeight:d,componentCount:h,spanning:e.nodes.length<=1||h===1&&s.length===e.nodes.length-1}}function ht(c,n){let t=k(c,n,{directed:false}),e=new Map,o=new Map,r=new Map,i=new Set,a=new Map,s=0,d=h=>{e.set(h,s),o.set(h,s),s+=1;let l=0,f=r.get(h)??null;for(let I of t.neighborsByNode.get(h)??[]){let b=e.get(I.id);if(b===void 0){r.set(I.id,h),l+=1,d(I.id);let p=o.get(h)??0,N=o.get(I.id)??0;o.set(h,Math.min(p,N));let m=e.get(h)??0;if(f===null&&l>1&&i.add(h),f!==null&&N>=m&&i.add(h),N>m){let g=te(h,I.id),x=$(g.from,g.to),w=a.get(x);(!w||I.weight<w.weight-1e-12)&&a.set(x,{from:g.from,to:g.to,weight:I.weight});}}else if(I.id!==f){let p=o.get(h)??0;o.set(h,Math.min(p,b));}}};for(let h of t.nodes)e.has(h)||(r.set(h,null),d(h));let u=Array.from(a.values());return u.sort((h,l)=>{let f=A(h.from,l.from);if(f!==0)return f;let I=A(h.to,l.to);return I!==0?I:h.weight-l.weight}),{articulationPoints:Array.from(i).sort(A),bridges:u}}function Rt(c,n,t={}){let e=Re(c,n,t),o=at(c,n),r=ht(c,n),i=ne(c,n),a=[...i].sort(A),s=new Map,d=new Map;try{s=lt(c,n,t);}catch(u){if(!(u instanceof R)||u.code!=="NEGATIVE_WEIGHT")throw u;s=new Map;for(let h of a)s.set(h,{raw:0,normalized:0});}try{d=he(c,n,{directed:t.directed??!0,...t.pageRankOptions??{}}).byNode;}catch(u){if(!(u instanceof R)||u.code!=="NEGATIVE_WEIGHT")throw u;let h=i.length>0?1/i.length:0;d=new Map;for(let l=0;l<a.length;l+=1){let f=a[l];f&&d.set(f,{score:h,normalized:1,rank:l+1});}}return {degree:ct(c,n,t),closeness:ut(c,n,{...t,mode:t.closenessMode??"harmonic",shortestPathAlgorithm:t.shortestPathAlgorithm}),betweenness:s,pageRank:d,stronglyConnectedComponents:e.components,weaklyConnectedComponents:o.components,articulationPoints:r.articulationPoints,bridges:r.bridges}}function ee(c,n,t,e,o={}){let r=k(c,n,o);if(!r.neighborsByNode.has(t)||!r.neighborsByNode.has(e))return {source:t,target:e,path:[],distance:Number.POSITIVE_INFINITY,reachable:false,explored:0,algorithm:o.algorithm??"auto",hasNegativeWeights:D(r),negativeCycle:false};let i=oe(r,t,o.algorithm??"auto");if(i.result.negativeCycleNodes.has(e)){if(o.failOnNegativeCycle??false)throw new R("NEGATIVE_CYCLE",`Negative cycle reaches target node "${e}".`);return {source:t,target:e,path:[],distance:Number.NEGATIVE_INFINITY,reachable:false,explored:i.result.explored,algorithm:i.algorithm,hasNegativeWeights:i.hasNegativeWeights,negativeCycle:true}}let a=i.result.distanceByNode.get(e)??Number.POSITIVE_INFINITY,s=Number.isFinite(a),d=s?ue(t,e,i.result.previousByNode):[];return {source:t,target:e,path:d,distance:a,reachable:s&&d.length>0,explored:i.result.explored,algorithm:i.algorithm,hasNegativeWeights:i.hasNegativeWeights,negativeCycle:i.result.negativeCycleNodes.size>0}}function Ee(c,n,t={}){let e=k(c,n,{directed:t.directed??false});if(D(e))throw new R("NEGATIVE_WEIGHT","Label propagation requires non-negative graph weights.");let o=t.tieBreaker??((u,h)=>A(u,h)),r=[...e.nodes].sort(o),i=new Map;for(let u=0;u<r.length;u+=1){let h=r[u];h&&i.set(h,u);}let a=Math.max(1,t.maxIterations??100),s=0,d=false;for(let u=0;u<a;u+=1){s=u+1;let h=false;for(let l of r){let f=e.neighborsByNode.get(l)??[];if(f.length===0)continue;let I=new Map;for(let m of f){let g=i.get(m.id);g!==void 0&&I.set(g,(I.get(g)??0)+m.weight);}let b=i.get(l);if(b===void 0||I.size===0)continue;let p=b,N=Number.NEGATIVE_INFINITY;for(let[m,g]of I.entries()){if(g>N+1e-12){N=g,p=m;continue}Math.abs(g-N)<=1e-12&&m<p&&(p=m);}p!==b&&(i.set(l,p),h=true);}if(!h){d=true;break}}return ae(e,i,s,d,"label-propagation")}function Ae(c,n,t={}){let e=k(c,n,{directed:t.directed??false});if(D(e))throw new R("NEGATIVE_WEIGHT","Louvain requires non-negative graph weights.");let o=t.tieBreaker??((I,b)=>A(I,b)),r=[...e.nodes].sort(o),i=Math.max(1,t.maxPasses??32),a=Math.max(0,t.tolerance??1e-9),s=new Map;for(let I of e.nodes)s.set(I,ye(e.neighborsByNode.get(I)??[]));let d=0;for(let I of s.values())d+=I;let u=new Map,h=new Map;for(let I=0;I<r.length;I+=1){let b=r[I];if(!b)continue;u.set(b,I);let p=s.get(b)??0;h.set(I,p);}if(d<=1e-12)return ae(e,u,0,true,"louvain");let l=0,f=false;for(let I=0;I<i;I+=1){l=I+1;let b=false;for(let p of r){let N=u.get(p);if(N===void 0)continue;let m=s.get(p)??0;h.set(N,(h.get(N)??0)-m);let g=new Map;for(let M of e.neighborsByNode.get(p)??[]){let y=u.get(M.id);y!==void 0&&g.set(y,(g.get(y)??0)+M.weight);}let x=N,w=0;for(let[M,y]of g.entries()){let S=h.get(M)??0,v=y-S*m/d;if(v>w+a){w=v,x=M;continue}Math.abs(v-w)<=a&&M<x&&(x=M);}x!==N&&w>a?(u.set(p,x),h.set(x,(h.get(x)??0)+m),b=true):h.set(N,(h.get(N)??0)+m);}if(!b){f=true;break}}return ae(e,u,l,f,"louvain")}function Pe(c,n,t={}){let e=k(c,n,{directed:t.directed??false}),o=t.metric??"jaccard",r=t.minScore??0,i=le(e),a=[...e.nodes].sort(A),s=[];for(let d=0;d<a.length;d+=1){let u=a[d];if(u)for(let h=d+1;h<a.length;h+=1){let l=a[h];if(!l)continue;let f=Z(u,l,i,o);f<r-1e-12||s.push({left:u,right:l,score:f,metric:o});}}return s.sort((d,u)=>{let h=u.score-d.score;if(Math.abs(h)>1e-12)return h;let l=A(d.left,u.left);return l!==0?l:A(d.right,u.right)}),{metric:o,pairs:s.map((d,u)=>({...d,rank:u+1}))}}function ke(c,n,t={}){let e=k(c,n,{directed:t.directed??false}),o=t.metric??"jaccard",r=t.minScore??0,i=Math.max(1,Math.floor(t.k??5)),a=le(e),s=[...e.nodes].sort(A),d=new Map;for(let u of s){let h=[];for(let l of s){if(u===l)continue;let f=Z(u,l,a,o);f<r-1e-12||h.push({nodeId:l,score:f});}h.sort((l,f)=>{let I=f.score-l.score;return Math.abs(I)>1e-12?I:A(l.nodeId,f.nodeId)}),d.set(u,h.slice(0,i));}return {metric:o,k:i,neighborsByNode:d}}function me(c,n,t={}){let e=t.directed??false,o=k(c,n,{directed:e}),r=t.metric??"jaccard",i=t.minScore??0,a=Math.max(1,Math.floor(t.limit??20)),s=t.allowExistingEdges??false,d=le(o),u=[...o.nodes].sort(A),h=t.sourceFilter?new Set(t.sourceFilter):null,l=t.targetFilter?new Set(t.targetFilter):null,f=new Set;for(let b of o.edges)e?f.add(`${b.from}\0${b.to}`):f.add($(b.from,b.to));let I=[];if(e){for(let b of u)if(!(h&&!h.has(b)))for(let p of u){if(b===p||l&&!l.has(p)||!s&&f.has(`${b}\0${p}`))continue;let N=Z(b,p,d,r);N<i-1e-12||I.push({from:b,to:p,score:N,metric:r});}}else for(let b=0;b<u.length;b+=1){let p=u[b];if(p)for(let N=b+1;N<u.length;N+=1){let m=u[N];if(!m||h&&!h.has(p)&&!h.has(m)||l&&!l.has(p)&&!l.has(m)||!s&&f.has($(p,m)))continue;let g=Z(p,m,d,r);g<i-1e-12||I.push({from:p,to:m,score:g,metric:r});}}return I.sort((b,p)=>{let N=p.score-b.score;if(Math.abs(N)>1e-12)return N;let m=A(b.from,p.from);return m!==0?m:A(b.to,p.to)}),{metric:r,predictions:I.slice(0,a).map((b,p)=>({...b,rank:p+1}))}}function Et(c,n,t={}){return me(c,n,t)}function Ge(c,n,t,e,o={}){let r=k(c,n,o);if(D(r))throw new R("NEGATIVE_WEIGHT","A* requires non-negative graph weights.");if(!r.neighborsByNode.has(t)||!r.neighborsByNode.has(e))return {source:t,target:e,path:[],distance:Number.POSITIVE_INFINITY,reachable:false,explored:0,estimatedDistance:Number.POSITIVE_INFINITY};let i=o.heuristic??((p,N)=>0),a=new W,s=new Map,d=new Map,u=new Set;for(let p of r.nodes)s.set(p,Number.POSITIVE_INFINITY);s.set(t,0);let h=i(t,e);if(!Number.isFinite(h))throw new R("INVALID_ARGUMENT","A* heuristic must return finite values.");a.push(t,h);let l=0;for(;a.size>0;){let p=a.pop();if(!p)break;let N=p.value;if(u.has(N))continue;if(u.add(N),l+=1,N===e)break;let m=s.get(N);if(!(m===void 0||!Number.isFinite(m)))for(let g of r.neighborsByNode.get(N)??[]){let x=m+g.weight,w=s.get(g.id)??Number.POSITIVE_INFINITY;if(x>=w-1e-12)continue;let M=i(g.id,e);if(!Number.isFinite(M))throw new R("INVALID_ARGUMENT","A* heuristic must return finite values.");s.set(g.id,x),d.set(g.id,N),a.push(g.id,x+M);}}let f=s.get(e)??Number.POSITIVE_INFINITY,I=Number.isFinite(f),b=I?ue(t,e,d):[];return {source:t,target:e,path:b,distance:f,reachable:I&&b.length>0,explored:l,estimatedDistance:f}}function Ce(c,n,t={}){let e=k(c,n,t),o=t.algorithm??"auto",r=we(o,D(e)),i=new Map,a=new Map,s=false;for(let d of e.nodes){let u=oe(e,d,r);if(u.result.negativeCycleNodes.size>0&&(s=true,t.failOnNegativeCycle??false))throw new R("NEGATIVE_CYCLE",`Negative cycle reaches source node "${d}".`);let h=new Map,l=new Map;for(let f of e.nodes){h.set(f,u.result.distanceByNode.get(f)??Number.POSITIVE_INFINITY);let I=u.result.previousByNode.get(f);I&&l.set(f,I);}i.set(d,h),a.set(d,l);}return {nodes:e.nodes,distanceBySource:i,previousBySource:a,algorithm:r,hasNegativeWeights:D(e),negativeCycle:s}}function Te(c,n,t,e,o={}){let r=o.directed??true,i=Math.max(1,Math.floor(o.k??3)),a=o.shortestPathAlgorithm??"auto",s=k(c,n,{directed:r});if(!s.neighborsByNode.has(t)||!s.neighborsByNode.has(e))return {source:t,target:e,paths:[],complete:false};let d=ee(s.nodes,s.edges,t,e,{directed:r,algorithm:a});if(!d.reachable||d.path.length===0)return {source:t,target:e,paths:[],complete:false};let u=[{path:d.path,distance:d.distance}],h=new Map;for(let l=1;l<i;l+=1){let f=u[l-1]?.path??[];if(f.length<2)break;for(let b=0;b<f.length-1;b+=1){let p=f[b];if(!p)continue;let N=f.slice(0,b+1),m=new Set(N.slice(0,-1)),g=new Set;for(let v of u)if(v.path.length>b+1&&Qe(v.path,N)){let E=v.path[b],G=v.path[b+1];E&&G&&g.add(`${E}\0${G}`);}let x=s.edges.filter(v=>!(g.has(`${v.from}\0${v.to}`)||m.has(v.from)||m.has(v.to))),w=ee(s.nodes,x,p,e,{directed:r,algorithm:a});if(!w.reachable||w.path.length===0)continue;let M=N.slice(0,-1).concat(w.path),y=Je(M,s);if(!Number.isFinite(y))continue;let S=Q(M);h.has(S)||h.set(S,{path:M,distance:y});}if(h.size===0)break;let I=Array.from(h.values()).sort((b,p)=>{let N=b.distance-p.distance;return Math.abs(N)>1e-12?N:A(Q(b.path),Q(p.path))})[0];if(!I)break;u.push(I),h.delete(Q(I.path));}return {source:t,target:e,paths:u,complete:u.length>=i}}function Oe(c,n,t,e,o={}){let r=k(c,n,o);if(!r.neighborsByNode.has(t)||!r.neighborsByNode.has(e))return {source:t,sink:e,maxFlow:0,augmentations:0,flowByEdge:[],sourcePartition:[],sinkPartition:[],cutEdges:[]};let i=[];for(let g of r.edges){if(g.weight<0)throw new R("NEGATIVE_WEIGHT","Maximum flow requires non-negative capacities.");i.push(g);}let a=new Map;for(let g of r.nodes)a.set(g,[]);let s=(g,x,w,M)=>{let y=a.get(g),S=a.get(x);if(!y||!S)return;let v=y.length,E=S.length;y.push({to:x,reverseIndex:E,capacity:w,originalIndex:M}),S.push({to:g,reverseIndex:v,capacity:0,originalIndex:null});};for(let g=0;g<i.length;g+=1){let x=i[g];x&&s(x.from,x.to,x.weight,g);}let d=0,u=0,h=new Array(i.length).fill(0);for(;;){let g=new Map,x=[t];g.set(t,{from:t,edgeIndex:-1});let w=0;for(;w<x.length&&!g.has(e);){let S=x[w];if(w+=1,!S)continue;let v=a.get(S)??[];for(let E=0;E<v.length;E+=1){let G=v[E];!G||G.capacity<=1e-12||g.has(G.to)||(g.set(G.to,{from:S,edgeIndex:E}),x.push(G.to));}}if(!g.has(e))break;let M=Number.POSITIVE_INFINITY,y=e;for(;y!==t;){let S=g.get(y);if(!S){M=0;break}let v=a.get(S.from)?.[S.edgeIndex];if(!v){M=0;break}M=Math.min(M,v.capacity),y=S.from;}if(!Number.isFinite(M)||M<=1e-12)break;for(y=e;y!==t;){let S=g.get(y);if(!S)break;let v=a.get(S.from)?.[S.edgeIndex],E=v?a.get(v.to)?.[v.reverseIndex]:void 0;if(!v||!E)break;v.capacity-=M,E.capacity+=M,v.originalIndex!==null?h[v.originalIndex]=(h[v.originalIndex]??0)+M:E.originalIndex!==null&&(h[E.originalIndex]=(h[E.originalIndex]??0)-M),y=S.from;}d+=M,u+=1;}let l=new Set,f=[t];l.add(t);let I=0;for(;I<f.length;){let g=f[I];if(I+=1,!!g)for(let x of a.get(g)??[])x.capacity<=1e-12||l.has(x.to)||(l.add(x.to),f.push(x.to));}let b=r.nodes.filter(g=>l.has(g)).sort(A),p=r.nodes.filter(g=>!l.has(g)).sort(A),N=i.filter(g=>l.has(g.from)&&!l.has(g.to)).sort((g,x)=>{let w=A(g.from,x.from);return w!==0?w:A(g.to,x.to)}),m=i.map((g,x)=>({from:g.from,to:g.to,flow:Math.max(0,h[x]??0),capacity:g.weight})).sort((g,x)=>{let w=A(g.from,x.from);return w!==0?w:A(g.to,x.to)});return {source:t,sink:e,maxFlow:d,augmentations:u,flowByEdge:m,sourcePartition:b,sinkPartition:p,cutEdges:N}}function De(c,n,t,e,o={}){let r=n.map(m=>({from:m.from,to:m.to,weight:m.capacity})),i=ne(c,r),a=o.directed??true;if(!i.includes(t)||!i.includes(e))return {source:t,sink:e,flow:0,cost:0,complete:false,augmentations:0,flowByEdge:[]};let s=[];for(let m of n){if(!Number.isFinite(m.capacity)||m.capacity<0)throw new R("INVALID_ARGUMENT",`Flow edge capacity must be non-negative and finite, received ${m.capacity}.`);let g=m.cost??0;if(!Number.isFinite(g))throw new R("INVALID_ARGUMENT",`Flow edge cost must be finite, received ${g}.`);s.push({from:m.from,to:m.to,capacity:m.capacity,cost:g}),a||s.push({from:m.to,to:m.from,capacity:m.capacity,cost:g});}let d=new Map;for(let m of i)d.set(m,[]);let u=(m,g,x,w,M)=>{let y=d.get(m),S=d.get(g);if(!y||!S)return;let v=y.length,E=S.length;y.push({to:g,reverseIndex:E,capacity:x,cost:w,originalIndex:M}),S.push({to:m,reverseIndex:v,capacity:0,cost:-w,originalIndex:null});};for(let m=0;m<s.length;m+=1){let g=s[m];g&&u(g.from,g.to,g.capacity,g.cost,m);}let h=o.targetFlow,l=h===void 0?Number.POSITIVE_INFINITY:h;if(!Number.isFinite(l)&&l!==Number.POSITIVE_INFINITY)throw new R("INVALID_ARGUMENT",`targetFlow must be finite or omitted, received ${l}.`);if(l<0)throw new R("INVALID_ARGUMENT",`targetFlow must be non-negative, received ${l}.`);let f=0,I=0,b=0,p=new Array(s.length).fill(0);for(;f<l-1e-12;){let m=new Map,g=new Map;for(let y of i)m.set(y,Number.POSITIVE_INFINITY);m.set(t,0);for(let y=0;y<i.length-1;y+=1){let S=false;for(let v of i){let E=m.get(v);if(E===void 0||!Number.isFinite(E))continue;let G=d.get(v)??[];for(let z=0;z<G.length;z+=1){let B=G[z];if(!B||B.capacity<=1e-12)continue;let q=E+B.cost,P=m.get(B.to)??Number.POSITIVE_INFINITY;q<P-1e-12&&(m.set(B.to,q),g.set(B.to,{from:v,edgeIndex:z}),S=true);}}if(!S)break}let x=m.get(e)??Number.POSITIVE_INFINITY;if(!Number.isFinite(x))break;let w=Math.min(l-f,Number.POSITIVE_INFINITY),M=e;for(;M!==t;){let y=g.get(M);if(!y){w=0;break}let S=d.get(y.from)?.[y.edgeIndex];if(!S){w=0;break}w=Math.min(w,S.capacity),M=y.from;}if(!Number.isFinite(w)||w<=1e-12)break;for(M=e;M!==t;){let y=g.get(M);if(!y)break;let S=d.get(y.from)?.[y.edgeIndex],v=S?d.get(S.to)?.[S.reverseIndex]:void 0;if(!S||!v)break;S.capacity-=w,v.capacity+=w,S.originalIndex!==null?p[S.originalIndex]=(p[S.originalIndex]??0)+w:v.originalIndex!==null&&(p[v.originalIndex]=(p[v.originalIndex]??0)-w),M=y.from;}f+=w,I+=w*x,b+=1;}let N=s.map((m,g)=>({from:m.from,to:m.to,flow:Math.max(0,p[g]??0),capacity:m.capacity,cost:m.cost})).sort((m,g)=>{let x=A(m.from,g.from);return x!==0?x:A(m.to,g.to)});return {source:t,sink:e,flow:f,cost:I,complete:l===Number.POSITIVE_INFINITY?true:f>=l-1e-12,augmentations:b,flowByEdge:N}}function mt(c,n,t={}){if(!Array.isArray(c)||c.length===0)throw new R("INVALID_ARGUMENT","kMeansClustering requires at least one point.");let e=c[0]?.length??0;if(e===0)throw new R("INVALID_ARGUMENT","kMeansClustering requires points with at least one axis.");for(let N of c)if(N.length!==e)throw new R("INVALID_ARGUMENT","kMeansClustering requires all points to share dimensionality.");let o=Math.max(1,Math.min(c.length,Math.floor(n))),r=Math.max(1,t.maxIterations??120),i=Math.max(0,t.tolerance??1e-5),a=Math.max(1,t.nInit??8),s=t.normalization??"zscore",d=t.useKMeansPlusPlus??true,u=t.seed===void 0||!Number.isFinite(t.seed)?Math.floor(Math.random()*4294967295):Math.floor(t.seed),h=tt(c,s),l=c.map(N=>h.normalize(N)),f=null,I=u;for(let N=0;N<a;N+=1){let m=u+N*2654435761>>>0,g=Se(m),x=ot(l,o,g,r,i,d);(!f||x.inertia<f.inertia-1e-9)&&(f=x,I=m);}if(!f)throw new R("INVALID_ARGUMENT","kMeansClustering failed to produce a valid run.");let b=[];for(let N=0;N<o;N+=1){let m=[];for(let g=0;g<f.assignments.length;g+=1)f.assignments[g]===N&&m.push(g);b.push({centroid:h.denormalize(f.centroidsNormalized[N]??[]),indices:m});}let p=ve(l,f.assignments,o);return {assignments:f.assignments,clusters:b,iterations:f.iterations,inertia:f.inertia,converged:f.converged,silhouette:p,selectedSeed:I}}function At(c,n={}){if(!Array.isArray(c)||c.length===0)throw new R("INVALID_ARGUMENT","kMeansAuto requires at least one point.");let t=Math.max(2,n.kMin??2),e=Math.max(t,Math.min(c.length,n.kMax??Math.min(10,Math.ceil(Math.sqrt(c.length))+2))),o=null,r=t,i=[];for(let a=t;a<=e;a+=1){let s=mt(c,a,{...n,seed:n.seed===void 0||!Number.isFinite(n.seed)?void 0:n.seed+a*997});if(i.push({k:a,silhouette:s.silhouette,inertia:s.inertia}),!o){o=s,r=a;continue}let d=s.silhouette??Number.NEGATIVE_INFINITY,u=o.silhouette??Number.NEGATIVE_INFINITY;if(d>u+1e-9){o=s,r=a;continue}Math.abs(d-u)<=1e-9&&s.inertia<o.inertia-1e-9&&(o=s,r=a);}if(!o)throw new R("INVALID_ARGUMENT","kMeansAuto failed to choose a cluster configuration.");return {...o,selectedK:r,candidates:i}}function Pt(c,n,t={}){let e=k(c,n,t);if(e.nodes.length===0)return {order:[],distance:0,segments:[],visitedCount:0,complete:true,unreachableNodes:[],lowerBound:0,optimalityGap:0};if(D(e))throw new R("NEGATIVE_WEIGHT","TSP approximation requires non-negative graph weights.");let o=t.returnToStart??true,r=Math.max(0,t.twoOptPasses??3),i=st(e.nodes,t),a=new Map,s=new Map;for(let m of e.nodes){let g=oe(e,m,t.shortestPathAlgorithm??"auto");if(g.result.negativeCycleNodes.size>0)throw new R("NEGATIVE_CYCLE","TSP approximation cannot run when negative cycles are reachable.");a.set(m,g.result.distanceByNode),s.set(m,g.result.previousByNode);}let d=[],u=Number.POSITIVE_INFINITY;for(let m of i){let x=it(m,e.nodes,a,o);x.length>2&&(x=rt(x,a,r));let w=ce(x,a);w<u&&(u=w,d=x);}let h=new Set(d),l=e.nodes.filter(m=>!h.has(m)),f=l.length===0&&Number.isFinite(u),I=[],b=0;for(let m=1;m<d.length;m+=1){let g=d[m-1],x=d[m];if(!g||!x)continue;let w=a.get(g)?.get(x)??Number.POSITIVE_INFINITY,M=s.get(g)??new Map,y=ue(g,x,M);!Number.isFinite(w)||y.length===0||(b+=w,I.push({from:g,to:x,distance:w,path:y}));}f||(b=Number.POSITIVE_INFINITY);let p=dt(e.nodes,a),N=f&&Number.isFinite(b)&&Number.isFinite(p)&&p>0?(b-p)/p:null;return {order:d,distance:b,segments:I,visitedCount:h.size,complete:f,unreachableNodes:l,lowerBound:p,optimalityGap:N}}function kt(c,n,t={}){if(!Array.isArray(c)||c.length===0)throw new R("INVALID_ARGUMENT","hierarchicalClustering requires at least one point.");let e=c.length,o=Math.max(1,Math.min(e,Math.floor(n))),r=t.linkage??"average",i=t.distanceMetric??"euclidean",a=(m,g)=>{switch(i){case "cosine":return 1-se(m,g);case "manhattan":return ie(m,g);default:return U(m,g)}},s=c.map((m,g)=>[g]),d=new Array(e).fill(true),u=[],h=Array.from({length:e},()=>new Array(e).fill(0));for(let m=0;m<e;m+=1)for(let g=m+1;g<e;g+=1){let x=a(c[m],c[g]);h[m][g]=x,h[g][m]=x;}let l=Array.from({length:e},(m,g)=>[...h[g]]),f=e;for(;f>o;){let m=-1,g=-1,x=Number.POSITIVE_INFINITY;for(let M=0;M<s.length;M+=1)if(d[M])for(let y=M+1;y<s.length;y+=1)d[y]&&l[M][y]<x&&(x=l[M][y],m=M,g=y);if(m===-1||g===-1)break;u.push({left:m<e?-(m+1):m,right:g<e?-(g+1):g,distance:x,size:s[m].length+s[g].length});let w=s[m].concat(s[g]);s[m]=w,d[g]=false,f-=1;for(let M=0;M<s.length;M+=1){if(!d[M]||M===m)continue;let y;switch(r){case "single":y=Math.min(l[m][M],l[g][M]);break;case "complete":y=Math.max(l[m][M],l[g][M]);break;case "ward":{let S=s[m].length-s[g].length,v=s[g].length,E=s[M].length,G=S+v+E;y=Math.sqrt(((S+E)*l[m][M]*l[m][M]+(v+E)*l[g][M]*l[g][M]-E*x*x)/G);break}default:{let S=s[m].length-s[g].length,v=s[g].length;y=(l[m][M]*S+l[g][M]*v)/(S+v);break}}l[m][M]=y,l[M][m]=y;}}let I=new Array(e).fill(-1),b=[],p=0;for(let m=0;m<s.length;m+=1)if(d[m]){b.push(s[m]);for(let g of s[m])I[g]=p;p+=1;}let N=ve(c,I,b.length);return {clusters:b,assignments:I,dendrogram:u,silhouette:N}}function Gt(c,n,t,e={}){if(!Array.isArray(c)||c.length===0)throw new R("INVALID_ARGUMENT","dbscan requires at least one point.");let o=c.length,r=e.distanceMetric??"euclidean",i=(I,b)=>{switch(r){case "cosine":return 1-se(I,b);case "manhattan":return ie(I,b);default:return U(I,b)}},a=-2,s=-1,d=new Array(o).fill(a),u=0,h=I=>{let b=[];for(let p=0;p<o;p+=1)i(c[I],c[p])<=n&&b.push(p);return b};for(let I=0;I<o;I+=1){if(d[I]!==a)continue;let b=h(I);if(b.length<t){d[I]=s;continue}d[I]=u;let p=[...b],N=0;for(;N<p.length;){let m=p[N];if(N+=1,d[m]===s&&(d[m]=u),d[m]!==a)continue;d[m]=u;let g=h(m);if(g.length>=t)for(let x of g)p.includes(x)||p.push(x);}u+=1;}let l=Array.from({length:u},()=>[]),f=[];for(let I=0;I<o;I+=1)d[I]===s?f.push(I):l[d[I]].push(I);return {clusters:l,assignments:d,noise:f,clusterCount:u}}function gt(c){return typeof c=="string"?c:c.id}function ge(c,n,t){let e=new Set;for(let s of c)e.add(gt(s));for(let s of n)e.add(s.from),e.add(s.to);let o=Array.from(e).sort(),r=new Map,i=new Map,a=new Set;for(let s of o)r.set(s,new Set),i.set(s,new Set);for(let s of n){let d=s.from,u=s.to;r.get(d)?.add(u),i.get(u)?.add(d),a.add(`${d}\0${u}`),t||(r.get(u)?.add(d),i.get(d)?.add(u),a.add(`${u}\0${d}`));}return {nodeIds:o,outNeighbors:r,inNeighbors:i,edgeSet:a}}function Fe(c,n,t={}){let e=t.directed??false,{nodeIds:o,outNeighbors:r,edgeSet:i}=ge(c,n,e),a=new Map;for(let s of o){let d=r.get(s),u=d.size;if(u<2){a.set(s,0);continue}let h=Array.from(d),l=0;for(let I=0;I<h.length;I+=1)for(let b=I+1;b<h.length;b+=1){let p=h[I],N=h[b];e?(i.has(`${p}\0${N}`)&&(l+=1),i.has(`${N}\0${p}`)&&(l+=1)):(i.has(`${p}\0${N}`)||i.has(`${N}\0${p}`))&&(l+=1);}let f=e?u*(u-1):u*(u-1)/2;a.set(s,f>0?l/f:0);}return a}function Ot(c,n,t={}){let e=t.directed??false,{nodeIds:o,outNeighbors:r,inNeighbors:i,edgeSet:a}=ge(c,n,e),s=o.length,d=n.length,u=e?s*(s-1):s*(s-1)/2,h=u>0?d/u:0,l=[],f=[],I=[];for(let P of o){let C=r.get(P)?.size??0,O=i.get(P)?.size??0;I.push(C),f.push(O),l.push(e?C+O:C);}let b=new F({data:l}),p=new F({data:f}),N=new F({data:I}),m=Fe(c,n,{directed:e}),g=Array.from(m.values()),x=g.length>0?g.reduce((P,C)=>P+C,0)/g.length:0,w=new F({data:g.length>0?g:[0]}),M=0;if(e)for(let P of n)a.has(`${P.to}\0${P.from}`)&&(M+=1);let y=e&&d>0?M/d:e?0:1,S=Math.min(s,t.samplePathLength??Math.min(s,50)),v=0,E=0,G=0,z=Math.max(1,Math.floor(s/S));for(let P=0;P<s&&P/z<S;P+=z){let C=o[P],O=new Map;O.set(C,0);let _=[C],L=0;for(;L<_.length;){let K=_[L];L+=1;let X=O.get(K),J=r.get(K)??new Set;for(let Y of J)if(!O.has(Y)){let j=X+1;O.set(Y,j),_.push(Y),v+=j,E+=1,j>G&&(G=j);}}}let B=E>0?v/E:0,q=0;if(n.length>1){let P=[],C=[];for(let T of n)P.push(r.get(T.from)?.size??0),C.push(r.get(T.to)?.size??0);let O=P.length,_=0,L=0,K=0,X=0,J=0;for(let T=0;T<O;T+=1)_+=P[T],L+=C[T],K+=P[T]*C[T],X+=P[T]*P[T],J+=C[T]*C[T];let Y=O*K-_*L,j=Math.sqrt((O*X-_*_)*(O*J-L*L));q=j>0?Y/j:0;}return {nodeCount:s,edgeCount:d,density:h,degreeDistribution:b.describe(),inDegreeDistribution:p.describe(),outDegreeDistribution:N.describe(),clusteringCoefficients:m,globalClusteringCoefficient:x,clusteringDistribution:w.describe(),averagePathLength:B,diameter:G,reciprocity:y,degreeAssortativity:q}}function Dt(c,n,t={}){let e=t.method??"combined",o=t.threshold??2,r=false,{nodeIds:i,outNeighbors:a}=ge(c,n,r),s=[];if(e==="degree"||e==="combined"){let d=i.map(f=>a.get(f)?.size??0),u=new F({data:d}),h=u.mean(),l=u.stddev();if(l>0)for(let f=0;f<i.length;f+=1){let I=Math.abs(d[f]-h)/l;I>o&&s.push({nodeId:i[f],score:I,reason:`degree outlier (z=${I.toFixed(2)}, degree=${d[f]})`});}}if(e==="clustering"||e==="combined"){let d=Fe(c,n,{directed:r}),u=Array.from(d.values()),h=new F({data:u.length>0?u:[0]}),l=h.mean(),f=h.stddev();if(f>0){for(let b of i){let p=d.get(b)??0,N=Math.abs(p-l)/f;if(N>o){let m=s.find(g=>g.nodeId===b);m?(m.score=Math.max(m.score,N),m.reason+=`; clustering outlier (z=${N.toFixed(2)}, cc=${p.toFixed(3)})`):s.push({nodeId:b,score:N,reason:`clustering outlier (z=${N.toFixed(2)}, cc=${p.toFixed(3)})`});}}}}return s.sort((d,u)=>u.score-d.score)}var fe=class{projections=new Map;project(n,t,e,o={}){let r=n.trim();if(!r)throw new R("INVALID_ARGUMENT","Projection name must be non-empty.");if(this.projections.has(r)&&!(o.replace??false))throw new R("INVALID_ARGUMENT",`Projection "${r}" already exists.`);let i=o.directed??true,a=k(t,e,{directed:i}),s={name:r,nodes:a.nodes,edges:a.edges,directed:i,createdAt:Date.now(),metadata:o.metadata??{}};return this.projections.set(r,s),s}drop(n){return this.projections.delete(n)}clear(){this.projections.clear();}exists(n){return this.projections.has(n)}get(n){return this.projections.get(n)??null}list(){return Array.from(this.projections.values()).map(n=>({name:n.name,nodeCount:n.nodes.length,edgeCount:n.edges.length,directed:n.directed,createdAt:n.createdAt,metadata:n.metadata})).sort((n,t)=>n.name.localeCompare(t.name))}pageRank(n,t={}){let e=this.requireProjection(n);return he(e.nodes,e.edges,{directed:e.directed,...t})}louvain(n,t={}){let e=this.requireProjection(n);return Ae(e.nodes,e.edges,{directed:e.directed,...t})}labelPropagation(n,t={}){let e=this.requireProjection(n);return Ee(e.nodes,e.edges,{directed:e.directed,...t})}similarity(n,t={}){let e=this.requireProjection(n);return Pe(e.nodes,e.edges,{directed:e.directed,...t})}knn(n,t={}){let e=this.requireProjection(n);return ke(e.nodes,e.edges,{directed:e.directed,...t})}linkPrediction(n,t={}){let e=this.requireProjection(n);return me(e.nodes,e.edges,{directed:e.directed,...t})}shortestPath(n,t,e,o={}){let r=this.requireProjection(n);return ee(r.nodes,r.edges,t,e,{directed:r.directed,...o})}aStar(n,t,e,o={}){let r=this.requireProjection(n);return Ge(r.nodes,r.edges,t,e,{directed:r.directed,...o})}yen(n,t,e,o={}){let r=this.requireProjection(n);return Te(r.nodes,r.edges,t,e,{directed:r.directed,...o})}allPairs(n,t={}){let e=this.requireProjection(n);return Ce(e.nodes,e.edges,{directed:e.directed,...t})}maxFlow(n,t,e,o={}){let r=this.requireProjection(n);return Oe(r.nodes,r.edges,t,e,{directed:r.directed,...o})}minCostMaxFlow(n,t,e,o=null,r={}){let i=this.requireProjection(n),a=o??i.edges.map(s=>({from:s.from,to:s.to,capacity:s.weight,cost:s.weight}));return De(i.nodes,a,t,e,{directed:i.directed,...r})}runPipeline(n,t){let e=new Map;for(let o of t){let r=o.id.trim();if(!r)throw new R("INVALID_ARGUMENT","Pipeline step id must be non-empty.");if(e.has(r))throw new R("INVALID_ARGUMENT",`Duplicate pipeline step id "${r}".`);if(o.kind==="page-rank"){e.set(r,this.pageRank(n,o.options));continue}if(o.kind==="louvain"){e.set(r,this.louvain(n,o.options));continue}if(o.kind==="label-propagation"){e.set(r,this.labelPropagation(n,o.options));continue}if(o.kind==="similarity"){e.set(r,this.similarity(n,o.options));continue}if(o.kind==="knn"){e.set(r,this.knn(n,o.options));continue}if(o.kind==="link-prediction"){e.set(r,this.linkPrediction(n,o.options));continue}if(o.kind==="shortest-path"){e.set(r,this.shortestPath(n,o.source,o.target,o.options));continue}if(o.kind==="a-star"){e.set(r,this.aStar(n,o.source,o.target,o.options));continue}if(o.kind==="yen-k-shortest-paths"){e.set(r,this.yen(n,o.source,o.target,o.options));continue}if(o.kind==="max-flow"){e.set(r,this.maxFlow(n,o.source,o.sink,o.options));continue}if(o.kind==="min-cost-max-flow"){e.set(r,this.minCostMaxFlow(n,o.source,o.sink,o.edges??null,o.options));continue}if(o.kind==="all-pairs-shortest-paths"){e.set(r,this.allPairs(n,o.options));continue}let i=o;throw new R("INVALID_ARGUMENT",`Unsupported pipeline step kind "${String(i)}".`)}return e}requireProjection(n){let t=this.projections.get(n);if(!t)throw new R("INVALID_ARGUMENT",`Projection "${n}" does not exist.`);return t}};function ft(){return new fe}var _t=ft();var H=100,Nt=0,xe=1e3,Ne=1.5,Be=1,_e=2,re=2;function Le(c=H){return Math.floor(Math.random()*c)}function ze(c=xe,n=H){let t=[];for(let e=0;e<c;e++)t.push(Le(n));return t}function je(c=re,n=H){let t=[];for(let e=0;e<c;e++)t.push(Math.floor(Math.random()*(n/10)%n));return t}function Ie(c=xe,n=re,t=H){let e=[];for(let o=0;o<c;o++)e.push(je(n,t));return e}var F=class{data;constructor(n={}){this.data={original:n.data??ze()};}sorted(){return this.data.sorted||(this.data.sorted=this.getSorted(this.data.original)),this.data.sorted}getSorted(n){return [...n].sort((t,e)=>t>e?1:t===e?0:-1)}median(){return this.sorted(),this.data.median===void 0&&(this.data.median=this.getMedian(this.data.sorted)),this.data.medianDepth===void 0&&(this.data.medianDepth=this.getMedianDepth(this.data.sorted)),{datum:this.data.median,depth:this.data.medianDepth}}getMedianDepth(n,t=0){return n.length?t+(n.length+1)/2:NaN}getMedian(n){let t=n.length;if(!t)return NaN;if(t===1)return n[0];let e=Math.floor(t/2);return t%2===0?(n[e-1]+n[e])/2:n[e]}mean(){return this.data.mean===void 0&&(this.data.mean=this.getMean(this.data.original)),this.data.mean}getMean(n){if(!n.length)return NaN;let t=0;for(let e of n)t+=e;return t/n.length}variance(){if(this.data.variance===void 0){let n=this.mean(),t=this.data.original;if(t.length<2)this.data.variance=NaN;else {let e=0;for(let o of t){let r=o-n;e+=r*r;}this.data.variance=e/(t.length-1);}}return this.data.variance}stddev(){return this.data.stddev===void 0&&(this.data.stddev=Math.sqrt(this.variance())),this.data.stddev}ema(n){let t=this.data.original;if(t.length===0)return [];let e=[t[0]];for(let o=1;o<t.length;o+=1){let r=e[o-1];e.push(r*(1-n)+t[o]*n);}return e}zscore(){let n=this.mean(),t=this.stddev();return t===0||isNaN(t)?this.data.original.map(()=>0):this.data.original.map(e=>(e-n)/t)}skewness(){if(this.data.skewness===void 0){let n=this.data.original,t=n.length;if(t<3)this.data.skewness=NaN;else {let e=this.mean(),o=this.stddev();if(o===0)this.data.skewness=0;else {let r=0;for(let i of n){let a=(i-e)/o;r+=a*a*a;}this.data.skewness=t/((t-1)*(t-2))*r;}}}return this.data.skewness}kurtosis(){if(this.data.kurtosis===void 0){let n=this.data.original,t=n.length;if(t<4)this.data.kurtosis=NaN;else {let e=this.mean(),o=this.stddev();if(o===0)this.data.kurtosis=0;else {let r=0;for(let s of n){let d=(s-e)/o;r+=d*d*d*d;}let i=t*(t+1)/((t-1)*(t-2)*(t-3))*r,a=3*(t-1)*(t-1)/((t-2)*(t-3));this.data.kurtosis=i-a;}}}return this.data.kurtosis}mode(){return this.data.mode||(this.sorted(),this.data.mode=this.getMode(this.data.sorted)),this.data.mode}getMode(n){if(!n.length)return {count:0,data:[]};let t={},e=0;for(let r of n)t[r]=(t[r]||0)+1,t[r]>e&&(e=t[r]);let o=[];for(let[r,i]of Object.entries(t))i===e&&o.push(Number(r));return {count:e,data:o.sort((r,i)=>r-i)}}extremes(){return this.data.extremes||(this.sorted(),this.data.extremes=this.getExtremes(this.data.sorted)),this.data.extremes}getExtremes(n){return n.length?[n[0],n[n.length-1]]:[]}counts(){return this.data.counts||(this.sorted(),this.data.counts=this.getCounts(this.data.sorted)),this.data.counts}getCounts(n){let t=new Map;for(let o of n)t.set(o,(t.get(o)||0)+1);let e=[];for(let[o,r]of t)e.push([o,r]);return e.sort((o,r)=>o[0]-r[0])}hinges(){return this.data.hinges||(this.sorted(),this.data.hinges=this.getHinges(this.data.sorted)),this.data.hinges}getHinges(n,t=2,e=[]){let o=[...n],r=o.length,i=t;if(i%2!==0&&i++,r<=i||i<=0)return e;let a=Math.floor(r/i),s=Math.floor(r/a)-1;for(let d=0;d<=s;d++){let u=o.slice(d*a,d*a+a);e.push({datum:this.getMedian(u),depth:this.getMedianDepth(u,d*a)});}return e}iqr(){return this.data.iqr===void 0&&(this.hinges(),this.data.iqr=this.getIQR(this.data.hinges)),this.data.iqr}getIQR(n){let t=n[0]?.datum,e=n[1]?.datum;return t===void 0||e===void 0?NaN:Math.abs(t-e)}fences(){return this.data.fences||(this.median(),this.iqr(),this.data.fences=this.getFences()),this.data.fences}getFences(n=Ne){let t=this.data.median,e=this.data.iqr;if(t===void 0||e===void 0||isNaN(e))return [];let o=e*n;return [t-o,t+o]}outer(){return this.data.outer||(this.median(),this.iqr(),this.data.outer=this.getOuter()),this.data.outer}getOuter(n=Ne){let t=this.data.median,e=this.data.iqr;if(t===void 0||e===void 0||isNaN(e))return [];let o=2*e*n;return [t-o,t+o]}outside(){return this.data.outside||(this.outer(),this.data.outside=this.getOutside()),this.data.outside}getOutside(){let n=[],t=this.data.sorted,e=this.data.outer;if(!e||e.length===0)return [];let o=Math.min(...e),r=Math.max(...e);for(let i of t)(i>r||i<o)&&n.push(i);return n}inside(){return this.data.inside||(this.fences(),this.data.inside=this.getInside()),this.data.inside}getInside(){let n=[],t=this.data.sorted,e=this.data.fences;if(!e||e.length===0)return [];let o=Math.min(...e),r=Math.max(...e);for(let i of t)i<r&&i>o&&n.push(i);return n}outliers(){return this.data.outliers||(this.fences(),this.data.outliers=this.getOutliers()),this.data.outliers}getOutliers(){let n=[],t=this.data.sorted,e=this.data.fences;if(e.length===0)return [];let o=Math.min(...e),r=Math.max(...e);for(let i of t)(i>r||i<o)&&n.push(i);return n}ranked(){return this.data.ranked||(this.sorted(),this.data.ranked=this.getRanked(this.data.sorted)),this.data.ranked}getRanked(n,t=true){let e={},o={},r=n.length,i=[],a=NaN,s=[],d=()=>{a=NaN,s=[];};for(let h=0;h<n.length;h++){let l=n[h];if(!t)e[l]={rank:h+1,peers:0},o[l]={rank:r-h,peers:0};else {let f=h+1,I=h-1;l===n[I]?(!isNaN(a)&&s.length===0?(s.push(l),i.push(s),d()):(s.push(l),a=I),l!==n[f]&&(i.push(s),d())):l!==n[f]?s.length>0?(i.push(s),d()):i.push(l):s.push(l);}}let u=0;for(let h=0;h<i.length;h++){let l=i[h];if(typeof l=="number")o[l]={rank:h+1+u,peers:0},e[l]={rank:r-h-u,peers:0};else if(Array.isArray(l)){u+=l.length;let f=l[0];o[f]={rank:h+1+u,peers:l.length},e[f]={rank:r-h-u,peers:l.length};}else u+=1;}return {up:e,down:o,groups:{down:[...i],up:[...i].reverse()}}}adjacent(){return this.data.adjacent||(this.fences(),this.data.adjacent=this.getAdjacent(this.data.sorted,this.data.fences)),this.data.adjacent}getAdjacent(n,t){if(t.length===0)return [];let e=t[0],o=[],r=t[1],i=[];for(let a of n)a>e&&o.push(a),a<r&&i.push(a);return o.sort((a,s)=>a-s),i.sort((a,s)=>a-s),[o[0],i[i.length-1]]}binned(n=NaN){return this.data.binned||(this.sorted(),this.extremes(),this.data.binned=this.getBinned(this.data.sorted,n)),this.data.binned}getBinned(n,t=10,e=NaN,o=true){let r={},i=n.length,a=o?0:1;if(i===0)return {bins:0,width:NaN,binned:{}};let s=this.data.extremes,d=e;if(s&&isNaN(d)&&s.length===2){d=(s[1]-s[0])/(Math.log(n.length)/Math.LN2),d=Math.floor(d);let h=true;for(let l of n)if(l%1!==0){h=false;break}h&&(d=Math.floor(d));}let u=Math.floor(s[1]/d)+1;(!u||u<1)&&(u=1);for(let h of n){let l=Math.floor((h-a)/d);r[l]||(r[l]={from:l*d+a,to:(l+1)*d+a-1,data:[]}),r[l].data.push(h);}return {bins:u,width:d,binned:r}}logs(){return this.data.logs||(this.data.logs=this.getLogs(this.data.original)),this.data.logs}getLogs(n){return n.map(t=>Math.log(t))}roots(){return this.data.roots||(this.data.roots=this.getRoots(this.data.original)),this.data.roots}getRoots(n){return n.map(t=>Math.sqrt(t))}inverse(){return this.data.inverse||(this.data.inverse=this.getInverse(this.data.original)),this.data.inverse}getInverse(n){return n.map(t=>1/t)}hanning(){return this.data.hanning||(this.data.hanning=this.getSkipMeans(this.data.original)),this.data.hanning}getSkipMeans(n){let t=[];for(let e=0;e<n.length;e++)e!==0&&e!==n.length-1&&t.push((n[e]+n[e+1])/2);return t.unshift(n[0]),t.push(n[n.length-1]),t}smooth(){return this.data.smooth||(this.sorted(),this.data.smooth=this.getSmooth(this.data.original)),this.data.rough=this.getRough(this.data.original,this.data.smooth),this.data.smooth}getRough(n,t){let e=[];for(let o=0;o<n.length;o++)e.push(n[o]-t[o]);return e}getSmooth(n,t=3){let e=[...n];return e=this.smoothMedian(e,t),e=this.smoothExtremes(e,-1),e=this.smoothSplit(e,2),e=this.smoothMedian(e,t),e=this.smoothExtremes(e,-1),e=this.smoothMedian(e,t),e}smoothExtremes(n,t=1,e=0,o="both"){let r=n.length;if(r<=2)return [...n];let i=[...n];for(let a=e;a<t||t===-1;a++){let s=false;if(o==="both"||o==="head"){let d=i[0],u=i[1],h=i[2],l=u-2*(h-u),f=d<=u?u<=l?u:d<=l?l:d:d<=l?d:u<=l?l:u;i[0]!==f&&(i[0]=f,s=true);}if(o==="both"||o==="tail"){let d=i[r-3],u=i[r-2],h=i[r-1],l=u-2*(d-u),f=h<=u?u<=l?u:h<=l?l:h:h<=l?h:u<=l?l:u;i[r-1]!==f&&(i[r-1]=f,s=true);}if(t===-1&&!s)break}return i}smoothSplit(n,t=_e,e=0){let o=[...n],r=n.length;for(let i=e;i<t||t===-1;i++){let a=false;for(let s=2;s<r-1;s++){let d=o[s],u=o[s-1],h=o[s-2],l=o[s+1];if(d===u&&(u>h&&d>l||u<h&&d<l)){let f=this.smoothExtremes(o.slice(0,s)),I=this.smoothExtremes(o.slice(s));o=f.concat(I),a=true;}}if(t===-1&&!a)return o}return o}smoothMedian(n,t=1,e=0){let o=n,r=n.length;if(r<=2)return [...n];for(let i=e;i<t||t===-1;i++){let a=new Array(r);a[0]=o[0],a[r-1]=o[r-1];let s=false;for(let d=1;d<r-1;d++){let u=o[d],h=Math.min(Math.max(o[d-1],u),o[d+1]);a[d]=h,h!==u&&(s=true);}if(t===-1&&!s)return o;o=a;}return o}jitter(n,t=1,e=NaN,o=Be,r=NaN,i=0){let a=i+1,s=[...n];if(a<=t){let d=[];for(let u of s){let h=r;!h&&!isNaN(h)&&(h=(1+Math.floor(u/10))*(Math.random()>.5?1:-1));let l=u+Math.floor(Math.random()*o*h);!isNaN(e)&&l<e&&(l=e),d.push(l);}return this.jitter(d,t,e,o,r,a)}return s}trimean(){let n=this.median(),t=this.hinges();return t.length<2?n.datum:(t[0].datum+2*n.datum+t[1].datum)/4}letterValues(){this.sorted();let n=this.data.sorted.length;if(n<2)return [];let t=["M","F","E","D","C","B","A","Z","Y","X","W","V","U","T","S"],e=[],o=(n+1)/2,r=this.median().datum;e.push({letter:"M",depth:o,lower:r,upper:r,mid:r,spread:0});let i=o,a=1;for(;i>1&&a<t.length&&(i=Math.floor((Math.floor(i)+1)/2),!(i<1));){let s=Math.ceil(i)-1,d=n-Math.ceil(i);if(s<0||d>=n||s>=d)break;let u=this.data.sorted[s],h=this.data.sorted[d],l=(u+h)/2,f=h-u;e.push({letter:t[a],depth:i,lower:u,upper:h,mid:l,spread:f}),a++;}return e}rough(){return this.data.rough||this.smooth(),this.data.rough||[]}stemLeaf(n=1){this.sorted();let t=this.data.sorted;if(!t.length)return {stems:[],leaves:{},display:[]};let e=Math.pow(10,n),o=new Map;for(let d of t){let u=Math.floor(d/e),h=Math.abs(Math.round(d%e));o.has(u)||o.set(u,[]),o.get(u).push(h);}let r=Array.from(o.keys()).sort((d,u)=>d-u),i=[],a={},s=[];for(let d of r){let u=String(d);i.push(u);let h=o.get(d).sort((l,f)=>l-f).map(String);a[u]=h,s.push(`${u.padStart(4)} | ${h.join(" ")}`);}return {stems:i,leaves:a,display:s}}midSummaries(){return this.letterValues().map(({depth:t,mid:e,spread:o})=>({depth:t,mid:e,spread:o}))}describe(){return this.data.description={original:this.data.original,summary:{median:this.median(),mean:this.mean(),mode:this.mode(),hinges:this.hinges(),adjacent:this.adjacent(),outliers:this.outliers(),outer:this.outer(),outside:this.outside(),inside:this.inside(),extremes:this.extremes(),iqr:this.iqr(),fences:this.fences()},smooths:{smooth:this.smooth(),hanning:this.hanning()},transforms:{logs:this.logs(),roots:this.roots(),inverse:this.inverse()},counts:this.counts(),sorted:this.sorted(),ranked:this.ranked(),binned:this.binned()},this.data.description}},pe=class c{data;dimension;count;constructor(n={}){typeof n=="number"?(this.count=n,this.dimension=re,this.data={original:Ie(this.count,this.dimension)}):(this.dimension=n.dimensionality??2,this.count=n.count??100,this.data={original:n.data??Ie(this.count,this.dimension)},n.data&&n.data.length>0&&(this.dimension=n.data[0].length,this.count=n.data.length));}centroid(){if(!this.data.centroid){let n=this.data.original,t=this.dimension,e=n.length;if(e===0)return this.data.centroid=[],this.data.centroid;let o=new Array(t).fill(0);for(let r of n)for(let i=0;i<t;i+=1)o[i]+=r[i]??0;this.data.centroid=o.map(r=>r/e);}return this.data.centroid}variances(){if(!this.data.variances){let n=this.data.original,t=this.dimension,e=n.length;if(e<2)return this.data.variances=new Array(t).fill(NaN),this.data.variances;let o=this.centroid(),r=new Array(t).fill(0);for(let i of n)for(let a=0;a<t;a+=1){let s=(i[a]??0)-o[a];r[a]+=s*s;}this.data.variances=r.map(i=>i/(e-1));}return this.data.variances}standardDeviations(){return this.data.stddevs||(this.data.stddevs=this.variances().map(n=>Math.sqrt(n))),this.data.stddevs}covarianceMatrix(){if(!this.data.covarianceMatrix){let n=this.data.original,t=this.dimension,e=n.length,o=this.centroid(),r=Array.from({length:t},()=>new Array(t).fill(0));if(e<2)return this.data.covarianceMatrix=r,this.data.covarianceMatrix;for(let i of n)for(let a=0;a<t;a+=1){let s=(i[a]??0)-o[a];for(let d=a;d<t;d+=1){let u=(i[d]??0)-o[d];r[a][d]+=s*u;}}for(let i=0;i<t;i+=1)for(let a=i;a<t;a+=1)r[i][a]/=e-1,r[a][i]=r[i][a];this.data.covarianceMatrix=r;}return this.data.covarianceMatrix}correlationMatrix(){if(!this.data.correlationMatrix){let n=this.covarianceMatrix(),t=this.dimension,e=this.standardDeviations(),o=Array.from({length:t},()=>new Array(t).fill(0));for(let r=0;r<t;r+=1)for(let i=0;i<t;i+=1){let a=e[r]*e[i];o[r][i]=a===0?r===i?1:0:n[r][i]/a;}this.data.correlationMatrix=o;}return this.data.correlationMatrix}mahalanobis(n){let t=this.centroid(),e=this.variances(),o=Math.min(n.length,t.length,e.length);if(o===0)return 0;let r=0;for(let i=0;i<o;i+=1){let a=(n[i]??0)-t[i],s=Math.max(e[i],1e-8);r+=a*a/s;}return Math.sqrt(r)}mahalanobisAll(){if(!this.data.mahalanobisDistances){let n=this.centroid(),t=this.variances();this.data.mahalanobisDistances=this.data.original.map(e=>{let o=Math.min(e.length,n.length,t.length),r=0;for(let i=0;i<o;i+=1){let a=(e[i]??0)-n[i],s=Math.max(t[i],1e-8);r+=a*a/s;}return Math.sqrt(r)});}return this.data.mahalanobisDistances}outliersByMahalanobis(n=3){let t=this.mahalanobisAll(),e=[];for(let o=0;o<t.length;o+=1)t[o]>n&&e.push(this.data.original[o]);return e}normalizeL2(){let n=this.data.original.map(t=>{let e=0;for(let r of t)e+=r*r;let o=Math.sqrt(e);return o===0?t.map(()=>0):t.map(r=>r/o)});return new c({data:n})}normalizeZscore(){let n=this.centroid(),t=this.standardDeviations(),e=this.dimension,o=this.data.original.map(r=>{let i=new Array(e);for(let a=0;a<e;a+=1){let s=t[a];i[a]=s===0||isNaN(s)?0:((r[a]??0)-n[a])/s;}return i});return new c({data:o})}describe(){let n=this.mahalanobisAll(),t=n.filter(r=>r>3).length,e=this.dimension,o=[];for(let r=0;r<e;r+=1){let i=this.data.original.map(s=>s[r]??0),a=new F({data:i});o.push(a.describe());}return this.data.description={original:this.data.original,centroid:this.centroid(),variances:this.variances(),correlationMatrix:this.correlationMatrix(),mahalanobisDistances:n,outlierCount:t,dimensionSummaries:o},this.data.description}},be=class{smoothed=false;static DEFAULT_MAX_RANDOM_INTEGER=H;static DEFAULT_MIN_RANDOM_INTEGER=Nt;static DEFAULT_RANDOM_SERIES_COUNT=xe;static DEFAULT_OUTLIER_MULTIPLE=Ne;static DEFAULT_JITTER_MULTIPLIER=Be;static DEFAULT_SPLIT_PASSES=_e;static DEFAULT_MAX_RANDOM_DIMENSIONALITY=re;static Series=F;static Points=pe;static randomInteger=Le;static randomSeries=ze;static randomPoint=je;static randomPoints=Ie},zt=be;export{R as GraphAlgorithmError,fe as GraphCatalog,pe as Points,F as Series,be as Twokeys,Ge as aStarShortestPath,Ce as allPairsShortestPaths,Rt as analyzeGraph,ht as articulationPointsAndBridges,lt as betweennessCentrality,k as buildGraphAdjacency,ut as closenessCentrality,Fe as clusteringCoefficient,se as cosineSimilarity,bt as cosineSimilaritySparse,ft as createGraphCatalog,Gt as dbscan,zt as default,ct as degreeCentrality,U as euclideanDistance,_t as gds,Ot as graphEda,Dt as graphOutliers,kt as hierarchicalClustering,xt as jaccardSimilarity,At as kMeansAuto,mt as kMeansClustering,ke as kNearestNeighbors,Ee as labelPropagationCommunities,Et as linkPrediction,Ae as louvainCommunities,It as mahalanobisDistance,ie as manhattanDistance,Oe as maximumFlow,De as minCostMaxFlow,vt as minimumSpanningTree,Pe as nodeSimilarity,pt as normalizeL2,Mt as overlapCoefficient,he as pageRank,me as predictLinks,ee as shortestPath,V as squaredEuclideanDistance,Re as stronglyConnectedComponents,St as topologicalSort,Pt as travelingSalesmanApprox,at as weaklyConnectedComponents,Te as yenKShortestPaths};//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map