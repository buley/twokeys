{"version":3,"sources":["../src/distance.ts","../src/graph.ts","../src/graph-eda.ts","../src/gds.ts","../src/index.ts"],"names":["cosineSimilarity","a","b","len","dot","magA","magB","i","ai","bi","denom","squaredEuclideanDistance","sum","delta","euclideanDistance","manhattanDistance","mahalanobisDistance","point","means","variances","epsilon","variance","normalizeL2","vector","sumSq","v","mag","cosineSimilaritySparse","small","large","key","val","other","jaccardSimilarity","intersection","value","union","overlapCoefficient","minSize","GraphAlgorithmError","code","message","MinPriorityQueue","priority","top","last","index","cursor","parent","current","parentItem","left","right","smallest","leftItem","rightItem","currentSmallest","cursorItem","smallestItem","defaultTieBreaker","canonicalUndirectedEdge","undirectedEdgeKey","edge","asNodeId","input","DisjointSet","nodes","nodeId","root","leftRoot","rightRoot","leftRank","rightRank","dedupeNodeList","edges","seen","ordered","node","normalizeWeight","weight","initializeNeighborMap","nodeIds","map","maybeUpdateEdge","from","to","outgoing","existing","buildNormalizedEdgeMap","directed","neighbors","toNeighborList","edgeMap","neighborsByNode","targetId","createIncomingByNode","incomingByNode","fromId","neighbor","incoming","toEdgeList","hasNegativeWeights","adjacency","reconstructPath","source","target","previousByNode","reversed","previous","sumNeighborWeights","collectUniqueUndirectedEdges","byKey","canonical","computeModularity","communityByNode","uniqueEdges","totalEdgeWeight","degreeByNode","totalWeightByCommunity","internalWeightByCommunity","community","degree","fromCommunity","toCommunity","modularity","totalWeight","internal","buildCommunityResult","labelsByNode","iterations","converged","algorithm","communitiesRaw","label","members","communities","buildNeighborIdSetMap","output","set","computeSimilarityScore","leftId","rightId","neighborSets","metric","leftSize","rightSize","iterate","lookup","common","adamicAdar","resourceAllocation","overlapDenominator","routeDistanceForPath","path","total","toId","pathKey","hasSamePrefix","prefix","chooseShortestPathAlgorithm","requested","hasNegative","runDijkstra","distanceByNode","settled","queue","item","currentDistance","nextDistance","existingDistance","runBellmanFord","totalNodes","iteration","changed","fromDistance","candidate","negativeCycleNodes","toDistance","explored","distance","runShortestPathEngine","requestedAlgorithm","createRandom","seed","state","normalizePoints","points","mode","dimensionality","mins","maxs","axis","ranges","max","min","range","stdDevs","stdDev","initializeCentroids","k","random","useKMeansPlusPlus","centroids","selected","first","distanceWeights","pointIndex","bestDistance","centroid","threshold","running","pickedIndex","runSingleKMeans","maxIterations","tolerance","assignments","inertia","bestCluster","clusterIndex","nextCentroids","counts","count","farthestIndex","farthestDistance","assigned","maxShift","next","computeSilhouette","clusters","cluster","clusterMembers","counted","ownCluster","ownMembers","neighborIndex","distanceToCluster","denominator","routeDistanceFromMatrix","route","distanceMatrix","optimizeRouteTwoOpt","passes","best","pass","improved","start","end","head","middle","tail","candidateDistance","createDeterministicStartList","options","starts","used","pool","swapIndex","desiredCount","buildGreedyRoute","returnToStart","unvisited","nextNode","distances","computeMstLowerBound","visited","buildGraphAdjacency","stronglyConnectedComponents","components","indexByNode","lowLinkByNode","stack","inStack","strongConnect","currentLow","neighborLow","component","member","firstLeft","firstRight","componentByNode","componentIndex","weaklyConnectedComponents","topologicalSort","tieBreaker","priorityByNode","priorityAccessor","compareNodes","priorityDelta","indegree","targets","order","orderSet","leftovers","directedScc","selfLoopNodes","cycleNodes","degreeCentrality","outDegree","inDegree","closenessCentrality","totalOthers","engine","negativeCycle","reachableCount","distanceSum","harmonicSum","score","normalized","betweennessCentrality","predecessors","sigma","distanceToNode","sigmaToNode","knownDistance","dependency","sigmaNode","dependencyNode","predecessor","sigmaPredecessor","contribution","normalization","records","raw","pageRank","dampingFactor","initialScore","outgoingWeightSum","scores","teleportMass","sinkMass","sinkContribution","outgoingWeight","transfer","scoreSum","scoreDelta","maxScore","byNode","minimumSpanningTree","candidateByKey","candidates","weightDelta","fromDelta","disjointSet","roots","componentCount","articulationPointsAndBridges","discoveredAt","lowLink","parentByNode","articulationPoints","bridgeByKey","discoveryCounter","visit","childCount","discoveredNeighbor","lowNode","lowNeighbor","discoveredNode","bridges","toDelta","analyzeGraph","scc","weak","articulation","dedupedNodes","orderedNodeIds","betweennessByNode","pageRankByNode","error","defaultScore","shortestPath","reachable","labelPropagationCommunities","nodeOrder","labelByNode","scoreByLabel","neighborLabel","currentLabel","bestLabel","bestScore","candidateLabel","louvainCommunities","maxPasses","totalDegree","communityWeight","nodeDegree","edgeWeightByCommunity","bestGain","edgeWeight","candidateWeight","gain","nodeSimilarity","minScore","orderedNodes","pairs","leftIndex","rightIndex","leftDelta","pair","kNearestNeighbors","otherId","predictLinks","limit","allowExistingEdges","sourceFilterSet","targetFilterSet","existingEdgeKeys","predictions","prediction","linkPrediction","aStarShortestPath","heuristic","_nodeId","_targetId","gScore","closedSet","startHeuristic","known","estimate","allPairsShortestPaths","chosenAlgorithm","distanceBySource","previousBySource","prev","yenKShortestPaths","shortestPathAlgorithm","accepted","pathIndex","spurIndex","spurNode","rootPath","rootNodeExclusion","removedEdgeKeys","pathRecord","filteredEdges","spurPath","totalPath","totalDistance","distanceDelta","maximumFlow","sink","originalEdges","residual","addResidualEdge","capacity","originalIndex","fromEdges","toEdges","forwardIndex","reverseIndex","maxFlow","augmentations","flowByOriginal","queueIndex","edgesFromNode","edgeIndex","bottleneck","parentEntry","reverse","reachableFromSource","partitionQueue","partitionCursor","sourcePartition","sinkPartition","cutEdges","flowByEdge","minCostMaxFlow","edgeProjection","originals","cost","targetFlowRaw","targetFlow","flow","sinkDistance","kMeansClustering","clusterCount","nInit","baseSeed","transform","normalizedPoints","bestSeed","attempt","run","indices","silhouette","kMeansAuto","minK","maxK","bestResult","bestK","result","currentSilhouette","bestSilhouette","travelingSalesmanApprox","twoOptPasses","previousMatrix","bestRoute","candidateRoute","unreachableNodes","complete","segments","lowerBound","optimalityGap","hierarchicalClustering","n","linkage","distFn","_","active","dendrogram","distMatrix","j","d","clusterDist","activeCount","bestI","bestJ","bestDist","mergedMembers","newDist","ni","nj","nk","sizeI","sizeJ","clusterIdx","ptIdx","dbscan","minPoints","UNVISITED","NOISE","currentCluster","regionQuery","pointIdx","seedIdx","jNeighbors","noise","resolveNodeId","buildAdjacencyMaps","nodeIdSet","outNeighbors","inNeighbors","edgeSet","id","clusteringCoefficient","neighborArr","triangles","maxTriangles","graphEda","nodeCount","edgeCount","maxEdges","density","degrees","inDegrees","outDegrees","outDeg","inDeg","degreeSeries","Series","inDegreeSeries","outDegreeSeries","cc","ccValues","globalCC","ccSeries","reciprocalCount","reciprocity","sampleSize","totalPathLength","pathCount","diameter","sampleStep","si","dist","qi","currentDist","averagePathLength","assortativity","sourceDegrees","targetDegrees","sumX","sumY","sumXY","sumX2","sumY2","numerator","graphOutliers","method","results","mean","std","zscore","r","GraphCatalog","name","normalizedName","projection","flowEdges","steps","step","stepId","exhaustiveKind","createGraphCatalog","gds","DEFAULT_MAX_RANDOM_INTEGER","DEFAULT_MIN_RANDOM_INTEGER","DEFAULT_RANDOM_SERIES_COUNT","DEFAULT_OUTLIER_MULTIPLE","DEFAULT_JITTER_MULTIPLIER","DEFAULT_SPLIT_PASSES","DEFAULT_MAX_RANDOM_DIMENSIONALITY","randomInteger","randomSeries","series","randomPoint","dimension","randomPoints","arr","offset","mid","num","m","alpha","s","z","rawKurt","correction","data","freq","maxCount","modes","hinges","copy","hingeCount","per","howMany","fragment","second","multiple","base","iqr","extra","sorted","outer","fences","ties","up","down","ranked","tiedRank","tiedNumbers","reset","incr","decr","usable","low","lows","high","highs","bins","width","includeZero","binned","zeroOffset","extremes","calculatedWidth","areIntegers","binCount","bin","original","smoothed","residuals","x","third","tmp","median","antepenultimate","penultimate","t1","t2","f1","floor","multiplier","nextCurrent","jittered","w","med","h","letters","medDepth","medValue","depth","letterIdx","lowerIdx","upperIdx","lower","upper","spread","leafDigits","scale","stems","stem","leaf","sortedStems","stemStrings","leavesRecord","display","stemStr","leaves","Points","_Points","pts","dim","sums","pt","cov","di","dj","stddevs","corr","vars","outlierCount","dimensionSummaries","values","Twokeys","index_default"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Vector Distance & Similarity Functions\n *\n * Standalone functions for vector math  zero dependencies.\n * These are the workhorses that Points, graph algorithms, and consumers all use.\n */\n\n//  Dense vector operations \n\n/**\n * Cosine similarity between two dense vectors.\n * Returns a value in [-1, 1] where 1 means identical direction.\n */\nexport function cosineSimilarity(a: number[], b: number[]): number {\n  const len = Math.min(a.length, b.length);\n  if (len === 0) return 0;\n\n  let dot = 0;\n  let magA = 0;\n  let magB = 0;\n\n  for (let i = 0; i < len; i += 1) {\n    const ai = a[i] ?? 0;\n    const bi = b[i] ?? 0;\n    dot += ai * bi;\n    magA += ai * ai;\n    magB += bi * bi;\n  }\n\n  const denom = Math.sqrt(magA) * Math.sqrt(magB);\n  if (denom === 0) return 0;\n  return dot / denom;\n}\n\n/**\n * Squared Euclidean distance between two dense vectors.\n * Avoids the sqrt for performance-sensitive comparisons.\n */\nexport function squaredEuclideanDistance(a: number[], b: number[]): number {\n  let sum = 0;\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i += 1) {\n    const delta = (a[i] ?? 0) - (b[i] ?? 0);\n    sum += delta * delta;\n  }\n  return sum;\n}\n\n/**\n * Euclidean (L2) distance between two dense vectors.\n */\nexport function euclideanDistance(a: number[], b: number[]): number {\n  return Math.sqrt(squaredEuclideanDistance(a, b));\n}\n\n/**\n * Manhattan (L1) distance between two dense vectors.\n */\nexport function manhattanDistance(a: number[], b: number[]): number {\n  let sum = 0;\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i += 1) {\n    sum += Math.abs((a[i] ?? 0) - (b[i] ?? 0));\n  }\n  return sum;\n}\n\n/**\n * Mahalanobis distance of a point from a distribution described by\n * per-dimension means and variances.\n *\n * This is the diagonal-covariance special case (dimensions are independent),\n * which is what most embedding-space consumers need.\n *\n * d = sqrt(  (x_i - _i) / max(_i, ) )\n */\nexport function mahalanobisDistance(\n  point: number[],\n  means: number[],\n  variances: number[],\n  epsilon: number = 1e-8,\n): number {\n  const len = Math.min(point.length, means.length, variances.length);\n  if (len === 0) return 0;\n\n  let sum = 0;\n  for (let i = 0; i < len; i += 1) {\n    const delta = (point[i] ?? 0) - (means[i] ?? 0);\n    const variance = Math.max(variances[i] ?? 0, epsilon);\n    sum += (delta * delta) / variance;\n  }\n  return Math.sqrt(sum);\n}\n\n/**\n * L2-normalize a dense vector (unit vector in same direction).\n * Returns the zero vector if the input has zero magnitude.\n */\nexport function normalizeL2(vector: number[]): number[] {\n  let sumSq = 0;\n  for (let i = 0; i < vector.length; i += 1) {\n    const v = vector[i] ?? 0;\n    sumSq += v * v;\n  }\n  const mag = Math.sqrt(sumSq);\n  if (mag === 0) return vector.map(() => 0);\n  return vector.map((v) => (v ?? 0) / mag);\n}\n\n//  Sparse vector operations \n\n/**\n * Cosine similarity between two sparse vectors represented as Map<string, number>.\n */\nexport function cosineSimilaritySparse(\n  a: Map<string, number>,\n  b: Map<string, number>,\n): number {\n  if (a.size === 0 || b.size === 0) return 0;\n\n  let dot = 0;\n  let magA = 0;\n  let magB = 0;\n\n  // Iterate over the smaller map for efficiency\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\n\n  for (const [key, val] of small) {\n    const other = large.get(key);\n    if (other !== undefined) {\n      dot += val * other;\n    }\n    magA += val * val;\n  }\n\n  for (const val of large.values()) {\n    magB += val * val;\n  }\n\n  // If we iterated the smaller as `a`, magA is correct.\n  // If we swapped, magA holds the smaller's magnitude and magB holds the larger's.\n  // Since cosine similarity is symmetric, the result is the same.\n\n  const denom = Math.sqrt(magA) * Math.sqrt(magB);\n  if (denom === 0) return 0;\n  return dot / denom;\n}\n\n//  Set operations \n\n/**\n * Jaccard similarity between two sets: |A  B| / |A  B|.\n * Returns 0 for empty sets.\n */\nexport function jaccardSimilarity<T>(a: Set<T>, b: Set<T>): number {\n  if (a.size === 0 || b.size === 0) return 0;\n\n  let intersection = 0;\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\n  for (const value of small) {\n    if (large.has(value)) {\n      intersection += 1;\n    }\n  }\n\n  const union = a.size + b.size - intersection;\n  if (union <= 0) return 0;\n  return intersection / union;\n}\n\n/**\n * Overlap coefficient: |A  B| / min(|A|, |B|).\n * Returns 0 for empty sets.\n */\nexport function overlapCoefficient<T>(a: Set<T>, b: Set<T>): number {\n  if (a.size === 0 || b.size === 0) return 0;\n\n  let intersection = 0;\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\n  for (const value of small) {\n    if (large.has(value)) {\n      intersection += 1;\n    }\n  }\n\n  const minSize = Math.min(a.size, b.size);\n  if (minSize <= 0) return 0;\n  return intersection / minSize;\n}\n","import {\n  squaredEuclideanDistance as squaredDistance,\n  euclideanDistance,\n  cosineSimilarity as distanceCosineSimilarity,\n  manhattanDistance,\n} from './distance';\n\nexport type GraphNodeInput<NodeId extends string = string> =\n  | NodeId\n  | { id: NodeId };\n\nexport interface GraphEdge<NodeId extends string = string> {\n  from: NodeId;\n  to: NodeId;\n  weight?: number;\n}\n\nexport interface GraphBuildOptions {\n  directed?: boolean;\n}\n\nexport interface GraphNeighbor<NodeId extends string = string> {\n  id: NodeId;\n  weight: number;\n}\n\nexport interface GraphAdjacency<NodeId extends string = string> {\n  nodes: NodeId[];\n  neighborsByNode: Map<NodeId, GraphNeighbor<NodeId>[]>;\n  incomingByNode: Map<NodeId, GraphNeighbor<NodeId>[]>;\n  edges: Array<Required<GraphEdge<NodeId>>>;\n  directed: boolean;\n}\n\nexport type GraphAlgorithmErrorCode =\n  | 'NEGATIVE_WEIGHT'\n  | 'NEGATIVE_CYCLE'\n  | 'INVALID_ARGUMENT';\n\nexport class GraphAlgorithmError extends Error {\n  readonly code: GraphAlgorithmErrorCode;\n\n  constructor(code: GraphAlgorithmErrorCode, message: string) {\n    super(message);\n    this.name = 'GraphAlgorithmError';\n    this.code = code;\n  }\n}\n\nexport interface TopologicalSortOptions<NodeId extends string = string> {\n  tieBreaker?: (left: NodeId, right: NodeId) => number;\n  priority?: (nodeId: NodeId) => number;\n  priorityByNode?: Map<NodeId, number> | Partial<Record<NodeId, number>>;\n}\n\nexport interface TopologicalSortResult<NodeId extends string = string> {\n  order: NodeId[];\n  cycleNodes: NodeId[];\n  isDag: boolean;\n}\n\nexport interface StronglyConnectedComponentsOptions extends GraphBuildOptions {}\n\nexport interface StronglyConnectedComponentsResult<NodeId extends string = string> {\n  components: NodeId[][];\n  componentByNode: Map<NodeId, number>;\n}\n\nexport interface WeaklyConnectedComponentsResult<NodeId extends string = string> {\n  components: NodeId[][];\n  componentByNode: Map<NodeId, number>;\n}\n\nexport interface DegreeCentralityRecord {\n  inDegree: number;\n  outDegree: number;\n  degree: number;\n  normalized: number;\n}\n\nexport type ClosenessCentralityMode = 'classic' | 'harmonic';\n\nexport interface ClosenessCentralityRecord {\n  reachableCount: number;\n  distanceSum: number;\n  score: number;\n  normalized: number;\n  mode: ClosenessCentralityMode;\n  negativeCycle: boolean;\n}\n\nexport interface BetweennessCentralityRecord {\n  raw: number;\n  normalized: number;\n}\n\nexport interface PageRankOptions extends GraphBuildOptions {\n  dampingFactor?: number;\n  tolerance?: number;\n  maxIterations?: number;\n}\n\nexport interface PageRankRecord {\n  score: number;\n  normalized: number;\n  rank: number;\n}\n\nexport interface PageRankResult<NodeId extends string = string> {\n  byNode: Map<NodeId, PageRankRecord>;\n  order: NodeId[];\n  iterations: number;\n  converged: boolean;\n  dampingFactor: number;\n}\n\nexport interface MinimumSpanningTreeOptions<NodeId extends string = string> {\n  tieBreaker?: (left: NodeId, right: NodeId) => number;\n}\n\nexport interface MinimumSpanningTreeResult<NodeId extends string = string> {\n  edges: Array<Required<GraphEdge<NodeId>>>;\n  totalWeight: number;\n  componentCount: number;\n  spanning: boolean;\n}\n\nexport interface ArticulationBridgeResult<NodeId extends string = string> {\n  articulationPoints: NodeId[];\n  bridges: Array<Required<GraphEdge<NodeId>>>;\n}\n\nexport interface GraphAnalysisResult<NodeId extends string = string> {\n  degree: Map<NodeId, DegreeCentralityRecord>;\n  closeness: Map<NodeId, ClosenessCentralityRecord>;\n  betweenness: Map<NodeId, BetweennessCentralityRecord>;\n  pageRank: Map<NodeId, PageRankRecord>;\n  stronglyConnectedComponents: NodeId[][];\n  weaklyConnectedComponents: NodeId[][];\n  articulationPoints: NodeId[];\n  bridges: Array<Required<GraphEdge<NodeId>>>;\n}\n\nexport interface GraphAnalysisOptions extends GraphBuildOptions {\n  closenessMode?: ClosenessCentralityMode;\n  shortestPathAlgorithm?: ShortestPathAlgorithm;\n  pageRankOptions?: Omit<PageRankOptions, 'directed'>;\n}\n\nexport type ShortestPathAlgorithm = 'auto' | 'dijkstra' | 'bellman-ford';\n\nexport interface ShortestPathOptions extends GraphBuildOptions {\n  algorithm?: ShortestPathAlgorithm;\n  failOnNegativeCycle?: boolean;\n}\n\nexport interface ShortestPathResult<NodeId extends string = string> {\n  source: NodeId;\n  target: NodeId;\n  path: NodeId[];\n  distance: number;\n  reachable: boolean;\n  explored: number;\n  algorithm: ShortestPathAlgorithm;\n  hasNegativeWeights: boolean;\n  negativeCycle: boolean;\n}\n\nexport interface LabelPropagationOptions<NodeId extends string = string>\n  extends GraphBuildOptions {\n  maxIterations?: number;\n  tieBreaker?: (left: NodeId, right: NodeId) => number;\n}\n\nexport interface LouvainOptions<NodeId extends string = string>\n  extends GraphBuildOptions {\n  maxPasses?: number;\n  tolerance?: number;\n  tieBreaker?: (left: NodeId, right: NodeId) => number;\n}\n\nexport interface CommunityDetectionResult<NodeId extends string = string> {\n  communities: NodeId[][];\n  communityByNode: Map<NodeId, number>;\n  iterations: number;\n  converged: boolean;\n  algorithm: 'label-propagation' | 'louvain';\n  modularity: number;\n}\n\nexport type SimilarityMetric =\n  | 'common-neighbors'\n  | 'jaccard'\n  | 'cosine'\n  | 'overlap'\n  | 'adamic-adar'\n  | 'resource-allocation'\n  | 'preferential-attachment';\n\nexport interface SimilarityOptions extends GraphBuildOptions {\n  metric?: SimilarityMetric;\n  minScore?: number;\n}\n\nexport interface NodeSimilarityRecord<NodeId extends string = string> {\n  left: NodeId;\n  right: NodeId;\n  score: number;\n  metric: SimilarityMetric;\n  rank: number;\n}\n\nexport interface NodeSimilarityResult<NodeId extends string = string> {\n  metric: SimilarityMetric;\n  pairs: NodeSimilarityRecord<NodeId>[];\n}\n\nexport interface KNearestNeighborsOptions extends GraphBuildOptions {\n  metric?: SimilarityMetric;\n  k?: number;\n  minScore?: number;\n}\n\nexport interface KNearestNeighbor<NodeId extends string = string> {\n  nodeId: NodeId;\n  score: number;\n}\n\nexport interface KNearestNeighborsResult<NodeId extends string = string> {\n  metric: SimilarityMetric;\n  k: number;\n  neighborsByNode: Map<NodeId, KNearestNeighbor<NodeId>[]>;\n}\n\nexport interface LinkPredictionOptions<NodeId extends string = string>\n  extends GraphBuildOptions {\n  metric?: SimilarityMetric;\n  limit?: number;\n  minScore?: number;\n  allowExistingEdges?: boolean;\n  sourceFilter?: NodeId[];\n  targetFilter?: NodeId[];\n}\n\nexport interface LinkPredictionRecord<NodeId extends string = string> {\n  from: NodeId;\n  to: NodeId;\n  score: number;\n  metric: SimilarityMetric;\n  rank: number;\n}\n\nexport interface LinkPredictionResult<NodeId extends string = string> {\n  metric: SimilarityMetric;\n  predictions: LinkPredictionRecord<NodeId>[];\n}\n\nexport interface AStarOptions<NodeId extends string = string>\n  extends GraphBuildOptions {\n  heuristic?: (nodeId: NodeId, targetId: NodeId) => number;\n}\n\nexport interface AStarResult<NodeId extends string = string> {\n  source: NodeId;\n  target: NodeId;\n  path: NodeId[];\n  distance: number;\n  reachable: boolean;\n  explored: number;\n  estimatedDistance: number;\n}\n\nexport interface PathRecord<NodeId extends string = string> {\n  path: NodeId[];\n  distance: number;\n}\n\nexport interface YenKShortestPathsOptions extends GraphBuildOptions {\n  k?: number;\n  shortestPathAlgorithm?: ShortestPathAlgorithm;\n}\n\nexport interface YenKShortestPathsResult<NodeId extends string = string> {\n  source: NodeId;\n  target: NodeId;\n  paths: PathRecord<NodeId>[];\n  complete: boolean;\n}\n\nexport interface AllPairsShortestPathsOptions extends GraphBuildOptions {\n  algorithm?: ShortestPathAlgorithm;\n  failOnNegativeCycle?: boolean;\n}\n\nexport interface AllPairsShortestPathsResult<NodeId extends string = string> {\n  nodes: NodeId[];\n  distanceBySource: Map<NodeId, Map<NodeId, number>>;\n  previousBySource: Map<NodeId, Map<NodeId, NodeId>>;\n  algorithm: ShortestPathAlgorithm;\n  hasNegativeWeights: boolean;\n  negativeCycle: boolean;\n}\n\nexport interface FlowEdge<NodeId extends string = string> {\n  from: NodeId;\n  to: NodeId;\n  capacity: number;\n  cost?: number;\n}\n\nexport interface FlowEdgeResult<NodeId extends string = string> {\n  from: NodeId;\n  to: NodeId;\n  flow: number;\n  capacity: number;\n}\n\nexport interface MaximumFlowOptions extends GraphBuildOptions {}\n\nexport interface MaximumFlowResult<NodeId extends string = string> {\n  source: NodeId;\n  sink: NodeId;\n  maxFlow: number;\n  augmentations: number;\n  flowByEdge: FlowEdgeResult<NodeId>[];\n  sourcePartition: NodeId[];\n  sinkPartition: NodeId[];\n  cutEdges: Array<Required<GraphEdge<NodeId>>>;\n}\n\nexport interface MinCostMaxFlowOptions extends GraphBuildOptions {\n  targetFlow?: number;\n}\n\nexport interface MinCostFlowEdgeResult<NodeId extends string = string>\n  extends FlowEdgeResult<NodeId> {\n  cost: number;\n}\n\nexport interface MinCostMaxFlowResult<NodeId extends string = string> {\n  source: NodeId;\n  sink: NodeId;\n  flow: number;\n  cost: number;\n  complete: boolean;\n  augmentations: number;\n  flowByEdge: MinCostFlowEdgeResult<NodeId>[];\n}\n\nexport type KMeansNormalization = 'none' | 'zscore' | 'minmax';\n\nexport interface KMeansOptions {\n  maxIterations?: number;\n  tolerance?: number;\n  seed?: number;\n  nInit?: number;\n  normalization?: KMeansNormalization;\n  useKMeansPlusPlus?: boolean;\n}\n\nexport interface KMeansCluster {\n  centroid: number[];\n  indices: number[];\n}\n\nexport interface KMeansResult {\n  assignments: number[];\n  clusters: KMeansCluster[];\n  iterations: number;\n  inertia: number;\n  converged: boolean;\n  silhouette: number | null;\n  selectedSeed: number;\n}\n\nexport interface KMeansAutoOptions extends KMeansOptions {\n  kMin?: number;\n  kMax?: number;\n}\n\nexport interface KMeansAutoCandidate {\n  k: number;\n  silhouette: number | null;\n  inertia: number;\n}\n\nexport interface KMeansAutoResult extends KMeansResult {\n  selectedK: number;\n  candidates: KMeansAutoCandidate[];\n}\n\nexport interface TravelingSalesmanOptions<NodeId extends string = string>\n  extends GraphBuildOptions {\n  start?: NodeId;\n  returnToStart?: boolean;\n  twoOptPasses?: number;\n  multiStartCount?: number;\n  startCandidates?: NodeId[];\n  seed?: number;\n  shortestPathAlgorithm?: ShortestPathAlgorithm;\n}\n\nexport interface TravelingSalesmanSegment<NodeId extends string = string> {\n  from: NodeId;\n  to: NodeId;\n  distance: number;\n  path: NodeId[];\n}\n\nexport interface TravelingSalesmanResult<NodeId extends string = string> {\n  order: NodeId[];\n  distance: number;\n  segments: TravelingSalesmanSegment<NodeId>[];\n  visitedCount: number;\n  complete: boolean;\n  unreachableNodes: NodeId[];\n  lowerBound: number;\n  optimalityGap: number | null;\n}\n\ninterface SingleSourceShortestResult<NodeId extends string = string> {\n  distanceByNode: Map<NodeId, number>;\n  previousByNode: Map<NodeId, NodeId>;\n  explored: number;\n  negativeCycleNodes: Set<NodeId>;\n}\n\ninterface ShortestPathEngineResult<NodeId extends string = string> {\n  algorithm: ShortestPathAlgorithm;\n  result: SingleSourceShortestResult<NodeId>;\n  hasNegativeWeights: boolean;\n}\n\ninterface PointNormalizationTransform {\n  normalize: (point: number[]) => number[];\n  denormalize: (point: number[]) => number[];\n}\n\ninterface KMeansRunResult {\n  assignments: number[];\n  centroidsNormalized: number[][];\n  iterations: number;\n  inertia: number;\n  converged: boolean;\n}\n\nclass MinPriorityQueue<Value> {\n  private heap: Array<{ priority: number; value: Value }> = [];\n\n  get size(): number {\n    return this.heap.length;\n  }\n\n  push(value: Value, priority: number): void {\n    this.heap.push({ priority, value });\n    this.siftUp(this.heap.length - 1);\n  }\n\n  pop(): { priority: number; value: Value } | undefined {\n    if (this.heap.length === 0) {\n      return undefined;\n    }\n\n    const top = this.heap[0];\n    const last = this.heap.pop();\n\n    if (this.heap.length > 0 && last) {\n      this.heap[0] = last;\n      this.siftDown(0);\n    }\n\n    return top;\n  }\n\n  private siftUp(index: number): void {\n    let cursor = index;\n\n    while (cursor > 0) {\n      const parent = Math.floor((cursor - 1) / 2);\n      const current = this.heap[cursor];\n      const parentItem = this.heap[parent];\n\n      if (!current || !parentItem) {\n        return;\n      }\n      if (parentItem.priority <= current.priority) {\n        return;\n      }\n\n      this.heap[parent] = current;\n      this.heap[cursor] = parentItem;\n      cursor = parent;\n    }\n  }\n\n  private siftDown(index: number): void {\n    let cursor = index;\n\n    while (true) {\n      const left = cursor * 2 + 1;\n      const right = cursor * 2 + 2;\n      let smallest = cursor;\n\n      const current = this.heap[smallest];\n      const leftItem = this.heap[left];\n      const rightItem = this.heap[right];\n\n      if (current && leftItem && leftItem.priority < current.priority) {\n        smallest = left;\n      }\n\n      const currentSmallest = this.heap[smallest];\n      if (\n        currentSmallest &&\n        rightItem &&\n        rightItem.priority < currentSmallest.priority\n      ) {\n        smallest = right;\n      }\n\n      if (smallest === cursor) {\n        return;\n      }\n\n      const cursorItem = this.heap[cursor];\n      const smallestItem = this.heap[smallest];\n      if (!cursorItem || !smallestItem) {\n        return;\n      }\n\n      this.heap[cursor] = smallestItem;\n      this.heap[smallest] = cursorItem;\n      cursor = smallest;\n    }\n  }\n}\n\nfunction defaultTieBreaker(left: string, right: string): number {\n  return left.localeCompare(right);\n}\n\nfunction canonicalUndirectedEdge<NodeId extends string>(\n  left: NodeId,\n  right: NodeId,\n): { from: NodeId; to: NodeId } {\n  return defaultTieBreaker(left, right) <= 0\n    ? { from: left, to: right }\n    : { from: right, to: left };\n}\n\nfunction undirectedEdgeKey<NodeId extends string>(left: NodeId, right: NodeId): string {\n  const edge = canonicalUndirectedEdge(left, right);\n  return `${edge.from}\\u0000${edge.to}`;\n}\n\nfunction asNodeId<NodeId extends string>(input: GraphNodeInput<NodeId>): NodeId {\n  return typeof input === 'string' ? input : input.id;\n}\n\nclass DisjointSet<NodeId extends string> {\n  private parent = new Map<NodeId, NodeId>();\n\n  private rank = new Map<NodeId, number>();\n\n  constructor(nodes: NodeId[]) {\n    for (const nodeId of nodes) {\n      this.parent.set(nodeId, nodeId);\n      this.rank.set(nodeId, 0);\n    }\n  }\n\n  find(nodeId: NodeId): NodeId {\n    const parent = this.parent.get(nodeId);\n    if (!parent || parent === nodeId) {\n      return nodeId;\n    }\n\n    const root = this.find(parent);\n    this.parent.set(nodeId, root);\n    return root;\n  }\n\n  union(left: NodeId, right: NodeId): boolean {\n    const leftRoot = this.find(left);\n    const rightRoot = this.find(right);\n    if (leftRoot === rightRoot) {\n      return false;\n    }\n\n    const leftRank = this.rank.get(leftRoot) ?? 0;\n    const rightRank = this.rank.get(rightRoot) ?? 0;\n\n    if (leftRank < rightRank) {\n      this.parent.set(leftRoot, rightRoot);\n      return true;\n    }\n\n    if (leftRank > rightRank) {\n      this.parent.set(rightRoot, leftRoot);\n      return true;\n    }\n\n    this.parent.set(rightRoot, leftRoot);\n    this.rank.set(leftRoot, leftRank + 1);\n    return true;\n  }\n}\n\nfunction dedupeNodeList<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n): NodeId[] {\n  const seen = new Set<NodeId>();\n  const ordered: NodeId[] = [];\n\n  for (const node of nodes) {\n    const nodeId = asNodeId(node);\n    if (!seen.has(nodeId)) {\n      seen.add(nodeId);\n      ordered.push(nodeId);\n    }\n  }\n\n  for (const edge of edges) {\n    if (!seen.has(edge.from)) {\n      seen.add(edge.from);\n      ordered.push(edge.from);\n    }\n    if (!seen.has(edge.to)) {\n      seen.add(edge.to);\n      ordered.push(edge.to);\n    }\n  }\n\n  return ordered;\n}\n\nfunction normalizeWeight(weight: number | undefined): number {\n  if (weight === undefined) {\n    return 1;\n  }\n\n  if (!Number.isFinite(weight)) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      `Graph edge weight must be finite, received ${weight}`,\n    );\n  }\n\n  return weight;\n}\n\nfunction initializeNeighborMap<NodeId extends string>(\n  nodeIds: NodeId[],\n): Map<NodeId, Map<NodeId, number>> {\n  const map = new Map<NodeId, Map<NodeId, number>>();\n  for (const nodeId of nodeIds) {\n    map.set(nodeId, new Map<NodeId, number>());\n  }\n  return map;\n}\n\nfunction maybeUpdateEdge<NodeId extends string>(\n  map: Map<NodeId, Map<NodeId, number>>,\n  from: NodeId,\n  to: NodeId,\n  weight: number,\n): void {\n  const outgoing = map.get(from);\n  if (!outgoing) {\n    return;\n  }\n\n  const existing = outgoing.get(to);\n  if (existing === undefined || weight < existing) {\n    outgoing.set(to, weight);\n  }\n}\n\nfunction buildNormalizedEdgeMap<NodeId extends string>(\n  nodeIds: NodeId[],\n  edges: GraphEdge<NodeId>[],\n  directed: boolean,\n): Map<NodeId, Map<NodeId, number>> {\n  const neighbors = initializeNeighborMap(nodeIds);\n\n  for (const edge of edges) {\n    if (edge.from === edge.to) {\n      continue;\n    }\n\n    const weight = normalizeWeight(edge.weight);\n    if (!neighbors.has(edge.from) || !neighbors.has(edge.to)) {\n      continue;\n    }\n\n    maybeUpdateEdge(neighbors, edge.from, edge.to, weight);\n    if (!directed) {\n      maybeUpdateEdge(neighbors, edge.to, edge.from, weight);\n    }\n  }\n\n  return neighbors;\n}\n\nfunction toNeighborList<NodeId extends string>(\n  edgeMap: Map<NodeId, Map<NodeId, number>>,\n): Map<NodeId, GraphNeighbor<NodeId>[]> {\n  const neighborsByNode = new Map<NodeId, GraphNeighbor<NodeId>[]>();\n\n  for (const [nodeId, outgoing] of edgeMap.entries()) {\n    const neighbors: GraphNeighbor<NodeId>[] = [];\n    for (const [targetId, weight] of outgoing.entries()) {\n      neighbors.push({ id: targetId, weight });\n    }\n    neighborsByNode.set(nodeId, neighbors);\n  }\n\n  return neighborsByNode;\n}\n\nfunction createIncomingByNode<NodeId extends string>(\n  nodeIds: NodeId[],\n  neighborsByNode: Map<NodeId, GraphNeighbor<NodeId>[]>,\n): Map<NodeId, GraphNeighbor<NodeId>[]> {\n  const incomingByNode = new Map<NodeId, GraphNeighbor<NodeId>[]>();\n  for (const nodeId of nodeIds) {\n    incomingByNode.set(nodeId, []);\n  }\n\n  for (const [fromId, neighbors] of neighborsByNode.entries()) {\n    for (const neighbor of neighbors) {\n      const incoming = incomingByNode.get(neighbor.id);\n      if (!incoming) {\n        continue;\n      }\n      incoming.push({ id: fromId, weight: neighbor.weight });\n    }\n  }\n\n  return incomingByNode;\n}\n\nfunction toEdgeList<NodeId extends string>(\n  neighborsByNode: Map<NodeId, GraphNeighbor<NodeId>[]>,\n): Array<Required<GraphEdge<NodeId>>> {\n  const edges: Array<Required<GraphEdge<NodeId>>> = [];\n  for (const [fromId, neighbors] of neighborsByNode.entries()) {\n    for (const neighbor of neighbors) {\n      edges.push({\n        from: fromId,\n        to: neighbor.id,\n        weight: neighbor.weight,\n      });\n    }\n  }\n  return edges;\n}\n\nfunction hasNegativeWeights<NodeId extends string>(\n  adjacency: GraphAdjacency<NodeId>,\n): boolean {\n  for (const edge of adjacency.edges) {\n    if (edge.weight < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction reconstructPath<NodeId extends string>(\n  source: NodeId,\n  target: NodeId,\n  previousByNode: Map<NodeId, NodeId>,\n): NodeId[] {\n  if (source === target) {\n    return [source];\n  }\n\n  const reversed: NodeId[] = [target];\n  let cursor: NodeId | undefined = target;\n\n  while (cursor && cursor !== source) {\n    const previous = previousByNode.get(cursor);\n    if (!previous) {\n      return [];\n    }\n    reversed.push(previous);\n    cursor = previous;\n  }\n\n  reversed.reverse();\n  return reversed[0] === source ? reversed : [];\n}\n\nfunction sumNeighborWeights<NodeId extends string>(\n  neighbors: GraphNeighbor<NodeId>[],\n): number {\n  return neighbors.reduce((sum, neighbor) => sum + neighbor.weight, 0);\n}\n\nfunction collectUniqueUndirectedEdges<NodeId extends string>(\n  adjacency: GraphAdjacency<NodeId>,\n): Array<Required<GraphEdge<NodeId>>> {\n  const byKey = new Map<string, Required<GraphEdge<NodeId>>>();\n\n  for (const edge of adjacency.edges) {\n    const canonical = canonicalUndirectedEdge(edge.from, edge.to);\n    const key = undirectedEdgeKey(canonical.from, canonical.to);\n    const existing = byKey.get(key);\n    if (!existing || edge.weight < existing.weight - 1e-12) {\n      byKey.set(key, {\n        from: canonical.from,\n        to: canonical.to,\n        weight: edge.weight,\n      });\n    }\n  }\n\n  return Array.from(byKey.values());\n}\n\nfunction computeModularity<NodeId extends string>(\n  adjacency: GraphAdjacency<NodeId>,\n  communityByNode: Map<NodeId, number>,\n): number {\n  const uniqueEdges = collectUniqueUndirectedEdges(adjacency);\n  let totalEdgeWeight = 0;\n  for (const edge of uniqueEdges) {\n    totalEdgeWeight += edge.weight;\n  }\n\n  if (!Number.isFinite(totalEdgeWeight) || totalEdgeWeight <= 0) {\n    return 0;\n  }\n\n  const degreeByNode = new Map<NodeId, number>();\n  for (const nodeId of adjacency.nodes) {\n    degreeByNode.set(\n      nodeId,\n      sumNeighborWeights(adjacency.neighborsByNode.get(nodeId) ?? []),\n    );\n  }\n\n  const totalWeightByCommunity = new Map<number, number>();\n  const internalWeightByCommunity = new Map<number, number>();\n\n  for (const nodeId of adjacency.nodes) {\n    const community = communityByNode.get(nodeId);\n    if (community === undefined) {\n      continue;\n    }\n    const degree = degreeByNode.get(nodeId) ?? 0;\n    totalWeightByCommunity.set(\n      community,\n      (totalWeightByCommunity.get(community) ?? 0) + degree,\n    );\n  }\n\n  for (const edge of uniqueEdges) {\n    const fromCommunity = communityByNode.get(edge.from);\n    const toCommunity = communityByNode.get(edge.to);\n    if (fromCommunity === undefined || toCommunity === undefined) {\n      continue;\n    }\n    if (fromCommunity !== toCommunity) {\n      continue;\n    }\n\n    internalWeightByCommunity.set(\n      fromCommunity,\n      (internalWeightByCommunity.get(fromCommunity) ?? 0) + edge.weight,\n    );\n  }\n\n  let modularity = 0;\n  for (const [community, totalWeight] of totalWeightByCommunity.entries()) {\n    const internal = internalWeightByCommunity.get(community) ?? 0;\n    modularity +=\n      internal / totalEdgeWeight -\n      Math.pow(totalWeight / (2 * totalEdgeWeight), 2);\n  }\n\n  return modularity;\n}\n\nfunction buildCommunityResult<NodeId extends string>(\n  adjacency: GraphAdjacency<NodeId>,\n  labelsByNode: Map<NodeId, number>,\n  iterations: number,\n  converged: boolean,\n  algorithm: CommunityDetectionResult<NodeId>['algorithm'],\n): CommunityDetectionResult<NodeId> {\n  const communitiesRaw = new Map<number, NodeId[]>();\n  for (const nodeId of adjacency.nodes) {\n    const label = labelsByNode.get(nodeId);\n    if (label === undefined) {\n      continue;\n    }\n    const members = communitiesRaw.get(label) ?? [];\n    members.push(nodeId);\n    communitiesRaw.set(label, members);\n  }\n\n  const communities = Array.from(communitiesRaw.values()).map((members) =>\n    [...members].sort(defaultTieBreaker),\n  );\n  communities.sort((left, right) =>\n    defaultTieBreaker(left[0] ?? '', right[0] ?? ''),\n  );\n\n  const communityByNode = new Map<NodeId, number>();\n  for (let index = 0; index < communities.length; index += 1) {\n    for (const nodeId of communities[index] ?? []) {\n      communityByNode.set(nodeId, index);\n    }\n  }\n\n  return {\n    communities,\n    communityByNode,\n    iterations,\n    converged,\n    algorithm,\n    modularity: computeModularity(adjacency, communityByNode),\n  };\n}\n\nfunction buildNeighborIdSetMap<NodeId extends string>(\n  adjacency: GraphAdjacency<NodeId>,\n): Map<NodeId, Set<NodeId>> {\n  const output = new Map<NodeId, Set<NodeId>>();\n\n  for (const nodeId of adjacency.nodes) {\n    output.set(nodeId, new Set<NodeId>());\n  }\n\n  for (const [nodeId, neighbors] of adjacency.neighborsByNode.entries()) {\n    const set = output.get(nodeId);\n    if (!set) {\n      continue;\n    }\n    for (const neighbor of neighbors) {\n      set.add(neighbor.id);\n    }\n  }\n\n  return output;\n}\n\nfunction computeSimilarityScore<NodeId extends string>(\n  leftId: NodeId,\n  rightId: NodeId,\n  neighborSets: Map<NodeId, Set<NodeId>>,\n  metric: SimilarityMetric,\n): number {\n  const left = neighborSets.get(leftId) ?? new Set<NodeId>();\n  const right = neighborSets.get(rightId) ?? new Set<NodeId>();\n  const leftSize = left.size;\n  const rightSize = right.size;\n\n  const iterate = leftSize <= rightSize ? left : right;\n  const lookup = iterate === left ? right : left;\n  let common = 0;\n  let adamicAdar = 0;\n  let resourceAllocation = 0;\n\n  for (const neighbor of iterate) {\n    if (!lookup.has(neighbor)) {\n      continue;\n    }\n\n    common += 1;\n    const degree = neighborSets.get(neighbor)?.size ?? 0;\n    if (degree > 1) {\n      adamicAdar += 1 / Math.log(degree);\n    }\n    if (degree > 0) {\n      resourceAllocation += 1 / degree;\n    }\n  }\n\n  if (metric === 'common-neighbors') {\n    return common;\n  }\n  if (metric === 'preferential-attachment') {\n    return leftSize * rightSize;\n  }\n  if (metric === 'adamic-adar') {\n    return adamicAdar;\n  }\n  if (metric === 'resource-allocation') {\n    return resourceAllocation;\n  }\n  if (metric === 'jaccard') {\n    const union = leftSize + rightSize - common;\n    return union > 0 ? common / union : 0;\n  }\n  if (metric === 'cosine') {\n    return leftSize > 0 && rightSize > 0\n      ? common / Math.sqrt(leftSize * rightSize)\n      : 0;\n  }\n\n  const overlapDenominator = Math.min(leftSize, rightSize);\n  return overlapDenominator > 0 ? common / overlapDenominator : 0;\n}\n\nfunction routeDistanceForPath<NodeId extends string>(\n  path: NodeId[],\n  adjacency: GraphAdjacency<NodeId>,\n): number {\n  if (path.length <= 1) {\n    return 0;\n  }\n\n  let total = 0;\n  for (let index = 1; index < path.length; index += 1) {\n    const fromId = path[index - 1];\n    const toId = path[index];\n    if (!fromId || !toId) {\n      return Number.POSITIVE_INFINITY;\n    }\n\n    const weight = adjacency.neighborsByNode\n      .get(fromId)\n      ?.find((neighbor) => neighbor.id === toId)?.weight;\n    if (weight === undefined || !Number.isFinite(weight)) {\n      return Number.POSITIVE_INFINITY;\n    }\n    total += weight;\n  }\n\n  return total;\n}\n\nfunction pathKey<NodeId extends string>(path: NodeId[]): string {\n  return path.join('\\u0000');\n}\n\nfunction hasSamePrefix<NodeId extends string>(\n  path: NodeId[],\n  prefix: NodeId[],\n): boolean {\n  if (prefix.length > path.length) {\n    return false;\n  }\n  for (let index = 0; index < prefix.length; index += 1) {\n    if (path[index] !== prefix[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction chooseShortestPathAlgorithm(\n  requested: ShortestPathAlgorithm,\n  hasNegative: boolean,\n): ShortestPathAlgorithm {\n  if (requested === 'auto') {\n    return hasNegative ? 'bellman-ford' : 'dijkstra';\n  }\n  return requested;\n}\n\nfunction runDijkstra<NodeId extends string>(\n  adjacency: GraphAdjacency<NodeId>,\n  source: NodeId,\n): SingleSourceShortestResult<NodeId> {\n  if (hasNegativeWeights(adjacency)) {\n    throw new GraphAlgorithmError(\n      'NEGATIVE_WEIGHT',\n      'Dijkstra cannot run on negative graph weights.',\n    );\n  }\n\n  const distanceByNode = new Map<NodeId, number>();\n  const previousByNode = new Map<NodeId, NodeId>();\n  const settled = new Set<NodeId>();\n  const queue = new MinPriorityQueue<NodeId>();\n\n  for (const nodeId of adjacency.nodes) {\n    distanceByNode.set(nodeId, Number.POSITIVE_INFINITY);\n  }\n\n  distanceByNode.set(source, 0);\n  queue.push(source, 0);\n\n  while (queue.size > 0) {\n    const item = queue.pop();\n    if (!item) {\n      break;\n    }\n\n    const nodeId = item.value;\n    if (settled.has(nodeId)) {\n      continue;\n    }\n    settled.add(nodeId);\n\n    const currentDistance = distanceByNode.get(nodeId);\n    if (currentDistance === undefined || !Number.isFinite(currentDistance)) {\n      continue;\n    }\n\n    const neighbors = adjacency.neighborsByNode.get(nodeId) ?? [];\n    for (const neighbor of neighbors) {\n      const nextDistance = currentDistance + neighbor.weight;\n      const existingDistance = distanceByNode.get(neighbor.id);\n\n      if (\n        existingDistance === undefined ||\n        nextDistance < existingDistance - 1e-12\n      ) {\n        distanceByNode.set(neighbor.id, nextDistance);\n        previousByNode.set(neighbor.id, nodeId);\n        queue.push(neighbor.id, nextDistance);\n      }\n    }\n  }\n\n  return {\n    distanceByNode,\n    previousByNode,\n    explored: settled.size,\n    negativeCycleNodes: new Set<NodeId>(),\n  };\n}\n\nfunction runBellmanFord<NodeId extends string>(\n  adjacency: GraphAdjacency<NodeId>,\n  source: NodeId,\n): SingleSourceShortestResult<NodeId> {\n  const distanceByNode = new Map<NodeId, number>();\n  const previousByNode = new Map<NodeId, NodeId>();\n\n  for (const nodeId of adjacency.nodes) {\n    distanceByNode.set(nodeId, Number.POSITIVE_INFINITY);\n  }\n  distanceByNode.set(source, 0);\n\n  const totalNodes = adjacency.nodes.length;\n\n  for (let iteration = 0; iteration < totalNodes - 1; iteration += 1) {\n    let changed = false;\n\n    for (const edge of adjacency.edges) {\n      const fromDistance = distanceByNode.get(edge.from);\n      if (fromDistance === undefined || !Number.isFinite(fromDistance)) {\n        continue;\n      }\n\n      const candidate = fromDistance + edge.weight;\n      const current = distanceByNode.get(edge.to);\n      if (current === undefined || candidate < current - 1e-12) {\n        distanceByNode.set(edge.to, candidate);\n        previousByNode.set(edge.to, edge.from);\n        changed = true;\n      }\n    }\n\n    if (!changed) {\n      break;\n    }\n  }\n\n  const negativeCycleNodes = new Set<NodeId>();\n  const queue: NodeId[] = [];\n\n  for (const edge of adjacency.edges) {\n    const fromDistance = distanceByNode.get(edge.from);\n    const toDistance = distanceByNode.get(edge.to);\n\n    if (\n      fromDistance !== undefined &&\n      Number.isFinite(fromDistance) &&\n      toDistance !== undefined &&\n      fromDistance + edge.weight < toDistance - 1e-12\n    ) {\n      if (!negativeCycleNodes.has(edge.to)) {\n        negativeCycleNodes.add(edge.to);\n        queue.push(edge.to);\n      }\n      if (!negativeCycleNodes.has(edge.from)) {\n        negativeCycleNodes.add(edge.from);\n        queue.push(edge.from);\n      }\n    }\n  }\n\n  let cursor = 0;\n  while (cursor < queue.length) {\n    const nodeId = queue[cursor];\n    cursor += 1;\n    if (!nodeId) {\n      continue;\n    }\n\n    for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n      if (!negativeCycleNodes.has(neighbor.id)) {\n        negativeCycleNodes.add(neighbor.id);\n        queue.push(neighbor.id);\n      }\n    }\n  }\n\n  if (negativeCycleNodes.size > 0) {\n    for (const nodeId of negativeCycleNodes) {\n      distanceByNode.set(nodeId, Number.NEGATIVE_INFINITY);\n      previousByNode.delete(nodeId);\n    }\n  }\n\n  let explored = 0;\n  for (const nodeId of adjacency.nodes) {\n    const distance = distanceByNode.get(nodeId);\n    if (distance !== undefined && Number.isFinite(distance)) {\n      explored += 1;\n    }\n  }\n\n  return {\n    distanceByNode,\n    previousByNode,\n    explored,\n    negativeCycleNodes,\n  };\n}\n\nfunction runShortestPathEngine<NodeId extends string>(\n  adjacency: GraphAdjacency<NodeId>,\n  source: NodeId,\n  requestedAlgorithm: ShortestPathAlgorithm,\n): ShortestPathEngineResult<NodeId> {\n  const hasNegative = hasNegativeWeights(adjacency);\n  const algorithm = chooseShortestPathAlgorithm(requestedAlgorithm, hasNegative);\n\n  if (algorithm === 'dijkstra') {\n    return {\n      algorithm,\n      result: runDijkstra(adjacency, source),\n      hasNegativeWeights: hasNegative,\n    };\n  }\n\n  return {\n    algorithm,\n    result: runBellmanFord(adjacency, source),\n    hasNegativeWeights: hasNegative,\n  };\n}\n\nfunction createRandom(seed: number | undefined): () => number {\n  if (seed === undefined || !Number.isFinite(seed)) {\n    return Math.random;\n  }\n\n  let state = (Math.floor(seed) >>> 0) || 1;\n  return () => {\n    state = (state * 1664525 + 1013904223) >>> 0;\n    return state / 4294967296;\n  };\n}\n\n// squaredDistance and euclideanDistance are now imported from './distance'\n\nfunction normalizePoints(\n  points: number[][],\n  mode: KMeansNormalization,\n): PointNormalizationTransform {\n  const dimensionality = points[0]?.length ?? 0;\n\n  if (mode === 'none') {\n    return {\n      normalize: (point) => [...point],\n      denormalize: (point) => [...point],\n    };\n  }\n\n  const means = new Array<number>(dimensionality).fill(0);\n  const mins = new Array<number>(dimensionality).fill(Number.POSITIVE_INFINITY);\n  const maxs = new Array<number>(dimensionality).fill(Number.NEGATIVE_INFINITY);\n\n  for (const point of points) {\n    for (let axis = 0; axis < dimensionality; axis += 1) {\n      const value = point[axis] ?? 0;\n      means[axis] = (means[axis] ?? 0) + value;\n      mins[axis] = Math.min(mins[axis] ?? value, value);\n      maxs[axis] = Math.max(maxs[axis] ?? value, value);\n    }\n  }\n\n  for (let axis = 0; axis < dimensionality; axis += 1) {\n    means[axis] = (means[axis] ?? 0) / points.length;\n  }\n\n  if (mode === 'minmax') {\n    const ranges = maxs.map((max, axis) => {\n      const min = mins[axis] ?? 0;\n      return max - min;\n    });\n\n    return {\n      normalize: (point) =>\n        point.map((value, axis) => {\n          const min = mins[axis] ?? 0;\n          const range = ranges[axis] ?? 0;\n          if (Math.abs(range) < 1e-12) {\n            return 0;\n          }\n          return (value - min) / range;\n        }),\n      denormalize: (point) =>\n        point.map((value, axis) => {\n          const min = mins[axis] ?? 0;\n          const range = ranges[axis] ?? 0;\n          return value * range + min;\n        }),\n    };\n  }\n\n  const variances = new Array<number>(dimensionality).fill(0);\n  for (const point of points) {\n    for (let axis = 0; axis < dimensionality; axis += 1) {\n      const delta = (point[axis] ?? 0) - (means[axis] ?? 0);\n      variances[axis] = (variances[axis] ?? 0) + delta * delta;\n    }\n  }\n\n  const stdDevs = variances.map((variance) => Math.sqrt(variance / points.length));\n\n  return {\n    normalize: (point) =>\n      point.map((value, axis) => {\n        const stdDev = stdDevs[axis] ?? 0;\n        if (stdDev < 1e-12) {\n          return 0;\n        }\n        return (value - (means[axis] ?? 0)) / stdDev;\n      }),\n    denormalize: (point) =>\n      point.map((value, axis) => {\n        const stdDev = stdDevs[axis] ?? 0;\n        return value * stdDev + (means[axis] ?? 0);\n      }),\n  };\n}\n\nfunction initializeCentroids(\n  points: number[][],\n  k: number,\n  random: () => number,\n  useKMeansPlusPlus: boolean,\n): number[][] {\n  if (points.length === 0) {\n    return [];\n  }\n\n  if (!useKMeansPlusPlus) {\n    const centroids: number[][] = [];\n    const selected = new Set<number>();\n    while (centroids.length < k) {\n      const index = Math.floor(random() * points.length);\n      if (selected.has(index)) {\n        continue;\n      }\n      selected.add(index);\n      centroids.push([...(points[index] ?? points[0] ?? [])]);\n    }\n    return centroids;\n  }\n\n  const centroids: number[][] = [];\n  const selected = new Set<number>();\n\n  const first = Math.floor(random() * points.length);\n  selected.add(first);\n  centroids.push([...(points[first] ?? points[0] ?? [])]);\n\n  while (centroids.length < k) {\n    const distanceWeights = new Array<number>(points.length).fill(0);\n    let totalWeight = 0;\n\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\n      if (selected.has(pointIndex)) {\n        continue;\n      }\n\n      const point = points[pointIndex];\n      if (!point) {\n        continue;\n      }\n\n      let bestDistance = Number.POSITIVE_INFINITY;\n      for (const centroid of centroids) {\n        bestDistance = Math.min(bestDistance, squaredDistance(point, centroid));\n      }\n\n      distanceWeights[pointIndex] = bestDistance;\n      totalWeight += bestDistance;\n    }\n\n    if (!Number.isFinite(totalWeight) || totalWeight <= 0) {\n      for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\n        if (!selected.has(pointIndex)) {\n          selected.add(pointIndex);\n          centroids.push([...(points[pointIndex] ?? points[0] ?? [])]);\n          break;\n        }\n      }\n      continue;\n    }\n\n    const threshold = random() * totalWeight;\n    let running = 0;\n    let pickedIndex = -1;\n\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\n      if (selected.has(pointIndex)) {\n        continue;\n      }\n      running += distanceWeights[pointIndex] ?? 0;\n      if (running >= threshold) {\n        pickedIndex = pointIndex;\n        break;\n      }\n    }\n\n    if (pickedIndex < 0) {\n      for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\n        if (!selected.has(pointIndex)) {\n          pickedIndex = pointIndex;\n          break;\n        }\n      }\n    }\n\n    if (pickedIndex < 0) {\n      break;\n    }\n\n    selected.add(pickedIndex);\n    centroids.push([...(points[pickedIndex] ?? points[0] ?? [])]);\n  }\n\n  return centroids;\n}\n\nfunction runSingleKMeans(\n  points: number[][],\n  k: number,\n  random: () => number,\n  maxIterations: number,\n  tolerance: number,\n  useKMeansPlusPlus: boolean,\n): KMeansRunResult {\n  const dimensionality = points[0]?.length ?? 0;\n  let centroids = initializeCentroids(points, k, random, useKMeansPlusPlus);\n\n  if (centroids.length !== k) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'Unable to initialize centroids for k-means.',\n    );\n  }\n\n  const assignments = new Array<number>(points.length).fill(-1);\n  let iterations = 0;\n  let converged = false;\n  let inertia = Number.POSITIVE_INFINITY;\n\n  while (iterations < maxIterations) {\n    iterations += 1;\n    let changed = false;\n    inertia = 0;\n\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\n      const point = points[pointIndex];\n      if (!point) {\n        continue;\n      }\n\n      let bestCluster = 0;\n      let bestDistance = Number.POSITIVE_INFINITY;\n\n      for (let clusterIndex = 0; clusterIndex < centroids.length; clusterIndex += 1) {\n        const centroid = centroids[clusterIndex];\n        if (!centroid) {\n          continue;\n        }\n        const distance = squaredDistance(point, centroid);\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestCluster = clusterIndex;\n        }\n      }\n\n      inertia += bestDistance;\n      if (assignments[pointIndex] !== bestCluster) {\n        assignments[pointIndex] = bestCluster;\n        changed = true;\n      }\n    }\n\n    const nextCentroids = new Array<number[]>(k);\n    const counts = new Array<number>(k).fill(0);\n\n    for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {\n      nextCentroids[clusterIndex] = new Array<number>(dimensionality).fill(0);\n    }\n\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\n      const clusterIndex = assignments[pointIndex];\n      if (clusterIndex < 0) {\n        continue;\n      }\n\n      const point = points[pointIndex];\n      const centroid = nextCentroids[clusterIndex];\n      if (!point || !centroid) {\n        continue;\n      }\n\n      counts[clusterIndex] = (counts[clusterIndex] ?? 0) + 1;\n      for (let axis = 0; axis < dimensionality; axis += 1) {\n        centroid[axis] = (centroid[axis] ?? 0) + (point[axis] ?? 0);\n      }\n    }\n\n    for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {\n      const count = counts[clusterIndex] ?? 0;\n      if (count > 0) {\n        const centroid = nextCentroids[clusterIndex];\n        if (!centroid) {\n          continue;\n        }\n        for (let axis = 0; axis < dimensionality; axis += 1) {\n          centroid[axis] = (centroid[axis] ?? 0) / count;\n        }\n      } else {\n        let farthestIndex = 0;\n        let farthestDistance = -1;\n\n        for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\n          const assigned = assignments[pointIndex];\n          const centroid = centroids[assigned];\n          const point = points[pointIndex];\n          if (!centroid || !point) {\n            continue;\n          }\n\n          const distance = squaredDistance(point, centroid);\n          if (distance > farthestDistance) {\n            farthestDistance = distance;\n            farthestIndex = pointIndex;\n          }\n        }\n\n        nextCentroids[clusterIndex] = [...(points[farthestIndex] ?? points[0] ?? [])];\n      }\n    }\n\n    let maxShift = 0;\n    for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {\n      const previous = centroids[clusterIndex];\n      const next = nextCentroids[clusterIndex];\n      if (!previous || !next) {\n        continue;\n      }\n      maxShift = Math.max(maxShift, Math.sqrt(squaredDistance(previous, next)));\n    }\n\n    centroids = nextCentroids;\n\n    if (!changed || maxShift <= tolerance) {\n      converged = true;\n      break;\n    }\n  }\n\n  return {\n    assignments,\n    centroidsNormalized: centroids,\n    iterations,\n    inertia,\n    converged,\n  };\n}\n\nfunction computeSilhouette(points: number[][], assignments: number[], k: number): number | null {\n  if (points.length <= 1 || k <= 1) {\n    return null;\n  }\n\n  const clusters: number[][] = Array.from({ length: k }, (): number[] => []);\n  for (let index = 0; index < assignments.length; index += 1) {\n    const cluster = assignments[index] ?? -1;\n    if (cluster >= 0 && cluster < k) {\n      const clusterMembers = clusters[cluster];\n      if (clusterMembers) {\n        clusterMembers.push(index);\n      }\n    }\n  }\n\n  let total = 0;\n  let counted = 0;\n\n  for (let index = 0; index < points.length; index += 1) {\n    const point = points[index];\n    const ownCluster = assignments[index] ?? -1;\n\n    if (!point || ownCluster < 0 || ownCluster >= k) {\n      continue;\n    }\n\n    const ownMembers = clusters[ownCluster] ?? [];\n    if (ownMembers.length <= 1) {\n      continue;\n    }\n\n    let a = 0;\n    for (const neighborIndex of ownMembers) {\n      if (neighborIndex === index) {\n        continue;\n      }\n      const neighbor = points[neighborIndex];\n      if (!neighbor) {\n        continue;\n      }\n      a += euclideanDistance(point, neighbor);\n    }\n    a /= ownMembers.length - 1;\n\n    let b = Number.POSITIVE_INFINITY;\n\n    for (let cluster = 0; cluster < k; cluster += 1) {\n      if (cluster === ownCluster) {\n        continue;\n      }\n\n      const members = clusters[cluster] ?? [];\n      if (members.length === 0) {\n        continue;\n      }\n\n      let distanceToCluster = 0;\n      for (const neighborIndex of members) {\n        const neighbor = points[neighborIndex];\n        if (!neighbor) {\n          continue;\n        }\n        distanceToCluster += euclideanDistance(point, neighbor);\n      }\n      distanceToCluster /= members.length;\n      b = Math.min(b, distanceToCluster);\n    }\n\n    if (!Number.isFinite(b)) {\n      continue;\n    }\n\n    const denominator = Math.max(a, b);\n    if (denominator <= 0) {\n      continue;\n    }\n\n    total += (b - a) / denominator;\n    counted += 1;\n  }\n\n  if (counted === 0) {\n    return null;\n  }\n\n  return total / counted;\n}\n\nfunction routeDistanceFromMatrix<NodeId extends string>(\n  route: NodeId[],\n  distanceMatrix: Map<NodeId, Map<NodeId, number>>,\n): number {\n  let total = 0;\n\n  for (let index = 1; index < route.length; index += 1) {\n    const fromId = route[index - 1];\n    const toId = route[index];\n    if (!fromId || !toId) {\n      return Number.POSITIVE_INFINITY;\n    }\n\n    const distance = distanceMatrix.get(fromId)?.get(toId);\n    if (distance === undefined || !Number.isFinite(distance)) {\n      return Number.POSITIVE_INFINITY;\n    }\n\n    total += distance;\n  }\n\n  return total;\n}\n\nfunction optimizeRouteTwoOpt<NodeId extends string>(\n  route: NodeId[],\n  distanceMatrix: Map<NodeId, Map<NodeId, number>>,\n  passes: number,\n): NodeId[] {\n  if (route.length < 4 || passes <= 0) {\n    return route;\n  }\n\n  let best = [...route];\n  let bestDistance = routeDistanceFromMatrix(best, distanceMatrix);\n\n  if (!Number.isFinite(bestDistance)) {\n    return best;\n  }\n\n  for (let pass = 0; pass < passes; pass += 1) {\n    let improved = false;\n\n    for (let start = 1; start < best.length - 2; start += 1) {\n      for (let end = start + 1; end < best.length - 1; end += 1) {\n        const head = best.slice(0, start);\n        const middle = best.slice(start, end + 1).reverse();\n        const tail = best.slice(end + 1);\n        const candidate = head.concat(middle, tail);\n        const candidateDistance = routeDistanceFromMatrix(\n          candidate,\n          distanceMatrix,\n        );\n\n        if (candidateDistance + 1e-9 < bestDistance) {\n          best = candidate;\n          bestDistance = candidateDistance;\n          improved = true;\n        }\n      }\n    }\n\n    if (!improved) {\n      break;\n    }\n  }\n\n  return best;\n}\n\nfunction createDeterministicStartList<NodeId extends string>(\n  nodes: NodeId[],\n  options: TravelingSalesmanOptions<NodeId>,\n): NodeId[] {\n  const starts: NodeId[] = [];\n  const used = new Set<NodeId>();\n\n  if (options.start && nodes.includes(options.start)) {\n    starts.push(options.start);\n    used.add(options.start);\n  }\n\n  for (const candidate of options.startCandidates ?? []) {\n    if (nodes.includes(candidate) && !used.has(candidate)) {\n      starts.push(candidate);\n      used.add(candidate);\n    }\n  }\n\n  const random = createRandom(options.seed);\n  const pool = nodes.filter((nodeId) => !used.has(nodeId));\n\n  for (let index = pool.length - 1; index > 0; index -= 1) {\n    const swapIndex = Math.floor(random() * (index + 1));\n    const left = pool[index];\n    const right = pool[swapIndex];\n    if (left !== undefined && right !== undefined) {\n      pool[index] = right;\n      pool[swapIndex] = left;\n    }\n  }\n\n  const desiredCount = Math.max(\n    1,\n    Math.min(nodes.length, options.multiStartCount ?? Math.min(8, nodes.length)),\n  );\n\n  for (const nodeId of pool) {\n    if (starts.length >= desiredCount) {\n      break;\n    }\n    starts.push(nodeId);\n  }\n\n  if (starts.length === 0 && nodes.length > 0) {\n    starts.push(nodes[0]!);\n  }\n\n  return starts;\n}\n\nfunction buildGreedyRoute<NodeId extends string>(\n  start: NodeId,\n  nodes: NodeId[],\n  distanceMatrix: Map<NodeId, Map<NodeId, number>>,\n  returnToStart: boolean,\n): NodeId[] {\n  const route: NodeId[] = [start];\n  const unvisited = new Set(nodes.filter((nodeId) => nodeId !== start));\n  let cursor = start;\n\n  while (unvisited.size > 0) {\n    let nextNode: NodeId | null = null;\n    let nextDistance = Number.POSITIVE_INFINITY;\n\n    const distances = distanceMatrix.get(cursor);\n    for (const candidate of unvisited) {\n      const candidateDistance = distances?.get(candidate) ?? Number.POSITIVE_INFINITY;\n      if (candidateDistance < nextDistance) {\n        nextDistance = candidateDistance;\n        nextNode = candidate;\n      }\n    }\n\n    if (!nextNode || !Number.isFinite(nextDistance)) {\n      break;\n    }\n\n    route.push(nextNode);\n    unvisited.delete(nextNode);\n    cursor = nextNode;\n  }\n\n  if (returnToStart && route.length > 1) {\n    route.push(start);\n  }\n\n  return route;\n}\n\nfunction computeMstLowerBound<NodeId extends string>(\n  nodes: NodeId[],\n  distanceMatrix: Map<NodeId, Map<NodeId, number>>,\n): number {\n  if (nodes.length <= 1) {\n    return 0;\n  }\n\n  const visited = new Set<NodeId>();\n  visited.add(nodes[0]!);\n  let total = 0;\n\n  while (visited.size < nodes.length) {\n    let bestDistance = Number.POSITIVE_INFINITY;\n    let nextNode: NodeId | null = null;\n\n    for (const fromId of visited) {\n      const distances = distanceMatrix.get(fromId);\n      for (const toId of nodes) {\n        if (visited.has(toId)) {\n          continue;\n        }\n\n        const distance = distances?.get(toId) ?? Number.POSITIVE_INFINITY;\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          nextNode = toId;\n        }\n      }\n    }\n\n    if (!nextNode || !Number.isFinite(bestDistance)) {\n      return Number.POSITIVE_INFINITY;\n    }\n\n    visited.add(nextNode);\n    total += bestDistance;\n  }\n\n  return total;\n}\n\nexport function buildGraphAdjacency<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: GraphBuildOptions = {},\n): GraphAdjacency<NodeId> {\n  const directed = options.directed ?? true;\n  const nodeIds = dedupeNodeList(nodes, edges);\n  const edgeMap = buildNormalizedEdgeMap(nodeIds, edges, directed);\n  const neighborsByNode = toNeighborList(edgeMap);\n  const incomingByNode = createIncomingByNode(nodeIds, neighborsByNode);\n\n  return {\n    nodes: nodeIds,\n    neighborsByNode,\n    incomingByNode,\n    edges: toEdgeList(neighborsByNode),\n    directed,\n  };\n}\n\nexport function stronglyConnectedComponents<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: StronglyConnectedComponentsOptions = {},\n): StronglyConnectedComponentsResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n  const components: NodeId[][] = [];\n\n  if (!adjacency.directed) {\n    const visited = new Set<NodeId>();\n\n    for (const source of adjacency.nodes) {\n      if (visited.has(source)) {\n        continue;\n      }\n\n      const queue: NodeId[] = [source];\n      visited.add(source);\n      const component: NodeId[] = [];\n\n      let cursor = 0;\n      while (cursor < queue.length) {\n        const nodeId = queue[cursor];\n        cursor += 1;\n        if (!nodeId) {\n          continue;\n        }\n\n        component.push(nodeId);\n        for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n          if (!visited.has(neighbor.id)) {\n            visited.add(neighbor.id);\n            queue.push(neighbor.id);\n          }\n        }\n      }\n\n      component.sort(defaultTieBreaker);\n      components.push(component);\n    }\n  } else {\n    let index = 0;\n    const indexByNode = new Map<NodeId, number>();\n    const lowLinkByNode = new Map<NodeId, number>();\n    const stack: NodeId[] = [];\n    const inStack = new Set<NodeId>();\n\n    const strongConnect = (nodeId: NodeId): void => {\n      indexByNode.set(nodeId, index);\n      lowLinkByNode.set(nodeId, index);\n      index += 1;\n      stack.push(nodeId);\n      inStack.add(nodeId);\n\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n        if (!indexByNode.has(neighbor.id)) {\n          strongConnect(neighbor.id);\n          const currentLow = lowLinkByNode.get(nodeId) ?? 0;\n          const neighborLow = lowLinkByNode.get(neighbor.id) ?? 0;\n          lowLinkByNode.set(nodeId, Math.min(currentLow, neighborLow));\n        } else if (inStack.has(neighbor.id)) {\n          const currentLow = lowLinkByNode.get(nodeId) ?? 0;\n          const neighborIndex = indexByNode.get(neighbor.id) ?? 0;\n          lowLinkByNode.set(nodeId, Math.min(currentLow, neighborIndex));\n        }\n      }\n\n      if ((lowLinkByNode.get(nodeId) ?? -1) === (indexByNode.get(nodeId) ?? -2)) {\n        const component: NodeId[] = [];\n\n        while (stack.length > 0) {\n          const member = stack.pop();\n          if (!member) {\n            break;\n          }\n          inStack.delete(member);\n          component.push(member);\n          if (member === nodeId) {\n            break;\n          }\n        }\n\n        component.sort(defaultTieBreaker);\n        components.push(component);\n      }\n    };\n\n    for (const nodeId of adjacency.nodes) {\n      if (!indexByNode.has(nodeId)) {\n        strongConnect(nodeId);\n      }\n    }\n  }\n\n  components.sort((left, right) => {\n    const firstLeft = left[0] ?? '';\n    const firstRight = right[0] ?? '';\n    return defaultTieBreaker(firstLeft, firstRight);\n  });\n\n  const componentByNode = new Map<NodeId, number>();\n  for (let componentIndex = 0; componentIndex < components.length; componentIndex += 1) {\n    for (const nodeId of components[componentIndex] ?? []) {\n      componentByNode.set(nodeId, componentIndex);\n    }\n  }\n\n  return {\n    components,\n    componentByNode,\n  };\n}\n\nexport function weaklyConnectedComponents<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n): WeaklyConnectedComponentsResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed: false });\n  const components: NodeId[][] = [];\n  const componentByNode = new Map<NodeId, number>();\n  const visited = new Set<NodeId>();\n\n  for (const source of adjacency.nodes) {\n    if (visited.has(source)) {\n      continue;\n    }\n\n    const queue: NodeId[] = [source];\n    visited.add(source);\n    const component: NodeId[] = [];\n\n    let cursor = 0;\n    while (cursor < queue.length) {\n      const nodeId = queue[cursor];\n      cursor += 1;\n      if (!nodeId) {\n        continue;\n      }\n\n      component.push(nodeId);\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n        if (!visited.has(neighbor.id)) {\n          visited.add(neighbor.id);\n          queue.push(neighbor.id);\n        }\n      }\n    }\n\n    component.sort(defaultTieBreaker);\n    const componentIndex = components.length;\n    components.push(component);\n    for (const nodeId of component) {\n      componentByNode.set(nodeId, componentIndex);\n    }\n  }\n\n  components.sort((left, right) => {\n    const firstLeft = left[0] ?? '';\n    const firstRight = right[0] ?? '';\n    return defaultTieBreaker(firstLeft, firstRight);\n  });\n\n  componentByNode.clear();\n  for (let componentIndex = 0; componentIndex < components.length; componentIndex += 1) {\n    const component = components[componentIndex] ?? [];\n    for (const nodeId of component) {\n      componentByNode.set(nodeId, componentIndex);\n    }\n  }\n\n  return {\n    components,\n    componentByNode,\n  };\n}\n\nexport function topologicalSort<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: TopologicalSortOptions<NodeId> = {},\n): TopologicalSortResult<NodeId> {\n  const nodeIds = dedupeNodeList(nodes, edges);\n  const tieBreaker =\n    options.tieBreaker ??\n    ((left: NodeId, right: NodeId) => defaultTieBreaker(left, right));\n  const priorityByNode = options.priorityByNode;\n  const priorityAccessor =\n    options.priority ??\n    ((nodeId: NodeId) => {\n      if (priorityByNode instanceof Map) {\n        return priorityByNode.get(nodeId) ?? 0;\n      }\n      if (priorityByNode) {\n        return priorityByNode[nodeId] ?? 0;\n      }\n      return 0;\n    });\n  const compareNodes = (left: NodeId, right: NodeId): number => {\n    const priorityDelta = priorityAccessor(right) - priorityAccessor(left);\n    if (Math.abs(priorityDelta) > 1e-12) {\n      return priorityDelta;\n    }\n    return tieBreaker(left, right);\n  };\n\n  const outgoing = new Map<NodeId, Set<NodeId>>();\n  const indegree = new Map<NodeId, number>();\n\n  for (const nodeId of nodeIds) {\n    outgoing.set(nodeId, new Set<NodeId>());\n    indegree.set(nodeId, 0);\n  }\n\n  for (const edge of edges) {\n    if (edge.from === edge.to) {\n      continue;\n    }\n    if (!outgoing.has(edge.from) || !outgoing.has(edge.to)) {\n      continue;\n    }\n\n    const targets = outgoing.get(edge.from);\n    if (!targets || targets.has(edge.to)) {\n      continue;\n    }\n\n    targets.add(edge.to);\n    indegree.set(edge.to, (indegree.get(edge.to) ?? 0) + 1);\n  }\n\n  const queue = nodeIds\n    .filter((nodeId) => (indegree.get(nodeId) ?? 0) === 0)\n    .sort(compareNodes);\n\n  const order: NodeId[] = [];\n\n  while (queue.length > 0) {\n    const nodeId = queue.shift();\n    if (!nodeId) {\n      continue;\n    }\n\n    order.push(nodeId);\n    const targets = Array.from(outgoing.get(nodeId) ?? []).sort(compareNodes);\n\n    for (const targetId of targets) {\n      const next = (indegree.get(targetId) ?? 0) - 1;\n      indegree.set(targetId, next);\n      if (next === 0) {\n        queue.push(targetId);\n      }\n    }\n\n    queue.sort(compareNodes);\n  }\n\n  const orderSet = new Set(order);\n  const leftovers = nodeIds.filter((nodeId) => !orderSet.has(nodeId));\n  leftovers.sort(compareNodes);\n\n  const directedScc = stronglyConnectedComponents(nodeIds, edges, { directed: true });\n  const selfLoopNodes = new Set<NodeId>(\n    edges.filter((edge) => edge.from === edge.to).map((edge) => edge.from),\n  );\n\n  const cycleNodes = new Set<NodeId>();\n  for (const component of directedScc.components) {\n    if (component.length > 1) {\n      for (const nodeId of component) {\n        cycleNodes.add(nodeId);\n      }\n    } else if (component.length === 1) {\n      const nodeId = component[0];\n      if (nodeId && selfLoopNodes.has(nodeId)) {\n        cycleNodes.add(nodeId);\n      }\n    }\n  }\n\n  for (const nodeId of leftovers) {\n    cycleNodes.add(nodeId);\n  }\n\n  for (const nodeId of leftovers) {\n    if (!orderSet.has(nodeId)) {\n      order.push(nodeId);\n      orderSet.add(nodeId);\n    }\n  }\n\n  return {\n    order,\n    cycleNodes: Array.from(cycleNodes).sort(compareNodes),\n    isDag: cycleNodes.size === 0,\n  };\n}\n\nexport function degreeCentrality<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: GraphBuildOptions = {},\n): Map<NodeId, DegreeCentralityRecord> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n  const total = adjacency.nodes.length;\n  const denominator =\n    total <= 1\n      ? 1\n      : adjacency.directed\n        ? 2 * (total - 1)\n        : Math.max(1, total - 1);\n\n  const output = new Map<NodeId, DegreeCentralityRecord>();\n\n  for (const nodeId of adjacency.nodes) {\n    const outDegree = adjacency.neighborsByNode.get(nodeId)?.length ?? 0;\n    const inDegree = adjacency.incomingByNode.get(nodeId)?.length ?? 0;\n    const degree = adjacency.directed ? inDegree + outDegree : outDegree;\n\n    output.set(nodeId, {\n      inDegree,\n      outDegree,\n      degree,\n      normalized: degree / denominator,\n    });\n  }\n\n  return output;\n}\n\nexport interface ClosenessCentralityOptions extends GraphBuildOptions {\n  mode?: ClosenessCentralityMode;\n  shortestPathAlgorithm?: ShortestPathAlgorithm;\n}\n\nexport function closenessCentrality<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: ClosenessCentralityOptions = {},\n): Map<NodeId, ClosenessCentralityRecord> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n  const total = adjacency.nodes.length;\n  const totalOthers = Math.max(0, total - 1);\n  const mode: ClosenessCentralityMode = options.mode ?? 'harmonic';\n  const output = new Map<NodeId, ClosenessCentralityRecord>();\n\n  for (const source of adjacency.nodes) {\n    const engine = runShortestPathEngine(\n      adjacency,\n      source,\n      options.shortestPathAlgorithm ?? 'auto',\n    );\n\n    const distances = engine.result.distanceByNode;\n    const negativeCycle = engine.result.negativeCycleNodes.size > 0;\n    let reachableCount = 0;\n    let distanceSum = 0;\n    let harmonicSum = 0;\n\n    for (const target of adjacency.nodes) {\n      if (target === source) {\n        continue;\n      }\n\n      const distance = distances.get(target);\n      if (distance === undefined || !Number.isFinite(distance) || distance <= 0) {\n        continue;\n      }\n\n      reachableCount += 1;\n      distanceSum += distance;\n      harmonicSum += 1 / distance;\n    }\n\n    let score = 0;\n    let normalized = 0;\n\n    if (!negativeCycle) {\n      if (mode === 'classic') {\n        score =\n          reachableCount > 0 && distanceSum > 0\n            ? reachableCount / distanceSum\n            : 0;\n        normalized = totalOthers > 0 ? score * (reachableCount / totalOthers) : 0;\n      } else {\n        score = harmonicSum;\n        normalized = totalOthers > 0 ? harmonicSum / totalOthers : 0;\n      }\n    }\n\n    output.set(source, {\n      reachableCount,\n      distanceSum,\n      score,\n      normalized,\n      mode,\n      negativeCycle,\n    });\n  }\n\n  return output;\n}\n\nexport function betweennessCentrality<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: GraphBuildOptions = {},\n): Map<NodeId, BetweennessCentralityRecord> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n  if (hasNegativeWeights(adjacency)) {\n    throw new GraphAlgorithmError(\n      'NEGATIVE_WEIGHT',\n      'Betweenness centrality requires non-negative graph weights.',\n    );\n  }\n\n  const output = new Map<NodeId, number>();\n  for (const nodeId of adjacency.nodes) {\n    output.set(nodeId, 0);\n  }\n\n  for (const source of adjacency.nodes) {\n    const stack: NodeId[] = [];\n    const predecessors = new Map<NodeId, NodeId[]>();\n    const sigma = new Map<NodeId, number>();\n    const distance = new Map<NodeId, number>();\n    const queue = new MinPriorityQueue<NodeId>();\n    const settled = new Set<NodeId>();\n\n    for (const nodeId of adjacency.nodes) {\n      predecessors.set(nodeId, []);\n      sigma.set(nodeId, 0);\n      distance.set(nodeId, Number.POSITIVE_INFINITY);\n    }\n\n    sigma.set(source, 1);\n    distance.set(source, 0);\n    queue.push(source, 0);\n\n    while (queue.size > 0) {\n      const item = queue.pop();\n      if (!item) {\n        break;\n      }\n\n      const nodeId = item.value;\n      if (settled.has(nodeId)) {\n        continue;\n      }\n\n      settled.add(nodeId);\n      stack.push(nodeId);\n\n      const distanceToNode = distance.get(nodeId);\n      if (distanceToNode === undefined || !Number.isFinite(distanceToNode)) {\n        continue;\n      }\n\n      const sigmaToNode = sigma.get(nodeId) ?? 0;\n\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n        const candidateDistance = distanceToNode + neighbor.weight;\n        const knownDistance = distance.get(neighbor.id);\n\n        if (\n          knownDistance === undefined ||\n          candidateDistance < knownDistance - 1e-12\n        ) {\n          distance.set(neighbor.id, candidateDistance);\n          queue.push(neighbor.id, candidateDistance);\n          sigma.set(neighbor.id, sigmaToNode);\n          predecessors.set(neighbor.id, [nodeId]);\n        } else if (\n          knownDistance !== undefined &&\n          Math.abs(candidateDistance - knownDistance) <= 1e-12\n        ) {\n          sigma.set(neighbor.id, (sigma.get(neighbor.id) ?? 0) + sigmaToNode);\n          predecessors.get(neighbor.id)?.push(nodeId);\n        }\n      }\n    }\n\n    const dependency = new Map<NodeId, number>();\n    for (const nodeId of adjacency.nodes) {\n      dependency.set(nodeId, 0);\n    }\n\n    while (stack.length > 0) {\n      const nodeId = stack.pop();\n      if (!nodeId) {\n        continue;\n      }\n\n      const sigmaNode = sigma.get(nodeId) ?? 0;\n      const dependencyNode = dependency.get(nodeId) ?? 0;\n\n      for (const predecessor of predecessors.get(nodeId) ?? []) {\n        const sigmaPredecessor = sigma.get(predecessor) ?? 0;\n        if (sigmaNode <= 0) {\n          continue;\n        }\n\n        const contribution =\n          (sigmaPredecessor / sigmaNode) * (1 + dependencyNode);\n        dependency.set(\n          predecessor,\n          (dependency.get(predecessor) ?? 0) + contribution,\n        );\n      }\n\n      if (nodeId !== source) {\n        output.set(nodeId, (output.get(nodeId) ?? 0) + dependencyNode);\n      }\n    }\n  }\n\n  if (!adjacency.directed) {\n    for (const nodeId of adjacency.nodes) {\n      output.set(nodeId, (output.get(nodeId) ?? 0) / 2);\n    }\n  }\n\n  const total = adjacency.nodes.length;\n  const normalization =\n    total <= 2\n      ? Number.POSITIVE_INFINITY\n      : adjacency.directed\n        ? (total - 1) * (total - 2)\n        : ((total - 1) * (total - 2)) / 2;\n\n  const records = new Map<NodeId, BetweennessCentralityRecord>();\n  for (const nodeId of adjacency.nodes) {\n    const raw = output.get(nodeId) ?? 0;\n    records.set(nodeId, {\n      raw,\n      normalized:\n        Number.isFinite(normalization) && normalization > 0\n          ? raw / normalization\n          : 0,\n    });\n  }\n\n  return records;\n}\n\nexport function pageRank<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: PageRankOptions = {},\n): PageRankResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n\n  if (hasNegativeWeights(adjacency)) {\n    throw new GraphAlgorithmError(\n      'NEGATIVE_WEIGHT',\n      'PageRank requires non-negative graph weights.',\n    );\n  }\n\n  const totalNodes = adjacency.nodes.length;\n  if (totalNodes === 0) {\n    return {\n      byNode: new Map<NodeId, PageRankRecord>(),\n      order: [],\n      iterations: 0,\n      converged: true,\n      dampingFactor: options.dampingFactor ?? 0.85,\n    };\n  }\n\n  const dampingFactor = options.dampingFactor ?? 0.85;\n  if (\n    !Number.isFinite(dampingFactor) ||\n    dampingFactor < 0 ||\n    dampingFactor >= 1\n  ) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      `PageRank dampingFactor must be in [0, 1), received ${dampingFactor}.`,\n    );\n  }\n\n  const tolerance = Math.max(0, options.tolerance ?? 1e-9);\n  const maxIterations = Math.max(1, Math.floor(options.maxIterations ?? 200));\n  const initialScore = 1 / totalNodes;\n\n  const outgoingWeightSum = new Map<NodeId, number>();\n  for (const nodeId of adjacency.nodes) {\n    const totalWeight = (adjacency.neighborsByNode.get(nodeId) ?? []).reduce(\n      (sum, neighbor) => sum + neighbor.weight,\n      0,\n    );\n    outgoingWeightSum.set(nodeId, totalWeight);\n  }\n\n  let scores = new Map<NodeId, number>();\n  for (const nodeId of adjacency.nodes) {\n    scores.set(nodeId, initialScore);\n  }\n\n  let iterations = 0;\n  let converged = false;\n\n  for (let iteration = 0; iteration < maxIterations; iteration += 1) {\n    iterations = iteration + 1;\n    const next = new Map<NodeId, number>();\n    const teleportMass = (1 - dampingFactor) / totalNodes;\n\n    let sinkMass = 0;\n    for (const nodeId of adjacency.nodes) {\n      const outgoingWeight = outgoingWeightSum.get(nodeId) ?? 0;\n      if (outgoingWeight <= 1e-12) {\n        sinkMass += scores.get(nodeId) ?? 0;\n      }\n      next.set(nodeId, teleportMass);\n    }\n\n    const sinkContribution = (dampingFactor * sinkMass) / totalNodes;\n    if (sinkContribution > 0) {\n      for (const nodeId of adjacency.nodes) {\n        next.set(nodeId, (next.get(nodeId) ?? 0) + sinkContribution);\n      }\n    }\n\n    for (const nodeId of adjacency.nodes) {\n      const outgoingWeight = outgoingWeightSum.get(nodeId) ?? 0;\n      if (outgoingWeight <= 1e-12) {\n        continue;\n      }\n\n      const score = scores.get(nodeId) ?? 0;\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n        const transfer = (dampingFactor * score * neighbor.weight) / outgoingWeight;\n        next.set(neighbor.id, (next.get(neighbor.id) ?? 0) + transfer);\n      }\n    }\n\n    let delta = 0;\n    for (const nodeId of adjacency.nodes) {\n      const previous = scores.get(nodeId) ?? 0;\n      const current = next.get(nodeId) ?? 0;\n      delta += Math.abs(previous - current);\n    }\n\n    scores = next;\n    if (delta <= tolerance) {\n      converged = true;\n      break;\n    }\n  }\n\n  let scoreSum = 0;\n  for (const nodeId of adjacency.nodes) {\n    scoreSum += scores.get(nodeId) ?? 0;\n  }\n\n  if (!Number.isFinite(scoreSum) || scoreSum <= 0) {\n    scores = new Map<NodeId, number>();\n    for (const nodeId of adjacency.nodes) {\n      scores.set(nodeId, initialScore);\n    }\n    scoreSum = 1;\n  } else if (Math.abs(scoreSum - 1) > 1e-12) {\n    for (const nodeId of adjacency.nodes) {\n      scores.set(nodeId, (scores.get(nodeId) ?? 0) / scoreSum);\n    }\n  }\n\n  const order = [...adjacency.nodes].sort((left, right) => {\n    const scoreDelta = (scores.get(right) ?? 0) - (scores.get(left) ?? 0);\n    if (Math.abs(scoreDelta) > 1e-12) {\n      return scoreDelta;\n    }\n    return defaultTieBreaker(left, right);\n  });\n\n  const maxScore = order.length > 0 ? (scores.get(order[0]!) ?? 0) : 0;\n  const byNode = new Map<NodeId, PageRankRecord>();\n  for (let index = 0; index < order.length; index += 1) {\n    const nodeId = order[index];\n    if (!nodeId) {\n      continue;\n    }\n    const score = scores.get(nodeId) ?? 0;\n    byNode.set(nodeId, {\n      score,\n      normalized: maxScore > 0 ? score / maxScore : 0,\n      rank: index + 1,\n    });\n  }\n\n  return {\n    byNode,\n    order,\n    iterations,\n    converged,\n    dampingFactor,\n  };\n}\n\nexport function minimumSpanningTree<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: MinimumSpanningTreeOptions<NodeId> = {},\n): MinimumSpanningTreeResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed: false });\n  const tieBreaker =\n    options.tieBreaker ??\n    ((left: NodeId, right: NodeId) => defaultTieBreaker(left, right));\n  const candidateByKey = new Map<string, Required<GraphEdge<NodeId>>>();\n\n  for (const edge of adjacency.edges) {\n    if (edge.from === edge.to) {\n      continue;\n    }\n    const canonical = canonicalUndirectedEdge(edge.from, edge.to);\n    const key = undirectedEdgeKey(canonical.from, canonical.to);\n    const existing = candidateByKey.get(key);\n    if (!existing || edge.weight < existing.weight - 1e-12) {\n      candidateByKey.set(key, {\n        from: canonical.from,\n        to: canonical.to,\n        weight: edge.weight,\n      });\n    }\n  }\n\n  const candidates = Array.from(candidateByKey.values());\n  candidates.sort((left, right) => {\n    const weightDelta = left.weight - right.weight;\n    if (Math.abs(weightDelta) > 1e-12) {\n      return weightDelta;\n    }\n\n    const fromDelta = tieBreaker(left.from, right.from);\n    if (fromDelta !== 0) {\n      return fromDelta;\n    }\n    return tieBreaker(left.to, right.to);\n  });\n\n  const disjointSet = new DisjointSet(adjacency.nodes);\n  const selected: Array<Required<GraphEdge<NodeId>>> = [];\n  let totalWeight = 0;\n\n  for (const edge of candidates) {\n    if (disjointSet.union(edge.from, edge.to)) {\n      selected.push(edge);\n      totalWeight += edge.weight;\n    }\n  }\n\n  const roots = new Set<NodeId>();\n  for (const nodeId of adjacency.nodes) {\n    roots.add(disjointSet.find(nodeId));\n  }\n  const componentCount = roots.size;\n\n  return {\n    edges: selected,\n    totalWeight,\n    componentCount,\n    spanning:\n      adjacency.nodes.length <= 1 ||\n      (componentCount === 1 && selected.length === adjacency.nodes.length - 1),\n  };\n}\n\nexport function articulationPointsAndBridges<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n): ArticulationBridgeResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed: false });\n  const discoveredAt = new Map<NodeId, number>();\n  const lowLink = new Map<NodeId, number>();\n  const parentByNode = new Map<NodeId, NodeId | null>();\n  const articulationPoints = new Set<NodeId>();\n  const bridgeByKey = new Map<string, Required<GraphEdge<NodeId>>>();\n\n  let discoveryCounter = 0;\n\n  const visit = (nodeId: NodeId): void => {\n    discoveredAt.set(nodeId, discoveryCounter);\n    lowLink.set(nodeId, discoveryCounter);\n    discoveryCounter += 1;\n\n    let childCount = 0;\n    const parent = parentByNode.get(nodeId) ?? null;\n\n    for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n      const discoveredNeighbor = discoveredAt.get(neighbor.id);\n      if (discoveredNeighbor === undefined) {\n        parentByNode.set(neighbor.id, nodeId);\n        childCount += 1;\n        visit(neighbor.id);\n\n        const lowNode = lowLink.get(nodeId) ?? 0;\n        const lowNeighbor = lowLink.get(neighbor.id) ?? 0;\n        lowLink.set(nodeId, Math.min(lowNode, lowNeighbor));\n\n        const discoveredNode = discoveredAt.get(nodeId) ?? 0;\n        if (parent === null && childCount > 1) {\n          articulationPoints.add(nodeId);\n        }\n        if (parent !== null && lowNeighbor >= discoveredNode) {\n          articulationPoints.add(nodeId);\n        }\n        if (lowNeighbor > discoveredNode) {\n          const canonical = canonicalUndirectedEdge(nodeId, neighbor.id);\n          const key = undirectedEdgeKey(canonical.from, canonical.to);\n          const existing = bridgeByKey.get(key);\n          if (!existing || neighbor.weight < existing.weight - 1e-12) {\n            bridgeByKey.set(key, {\n              from: canonical.from,\n              to: canonical.to,\n              weight: neighbor.weight,\n            });\n          }\n        }\n      } else if (neighbor.id !== parent) {\n        const lowNode = lowLink.get(nodeId) ?? 0;\n        lowLink.set(nodeId, Math.min(lowNode, discoveredNeighbor));\n      }\n    }\n  };\n\n  for (const nodeId of adjacency.nodes) {\n    if (!discoveredAt.has(nodeId)) {\n      parentByNode.set(nodeId, null);\n      visit(nodeId);\n    }\n  }\n\n  const bridges = Array.from(bridgeByKey.values());\n  bridges.sort((left, right) => {\n    const fromDelta = defaultTieBreaker(left.from, right.from);\n    if (fromDelta !== 0) {\n      return fromDelta;\n    }\n\n    const toDelta = defaultTieBreaker(left.to, right.to);\n    if (toDelta !== 0) {\n      return toDelta;\n    }\n\n    return left.weight - right.weight;\n  });\n\n  return {\n    articulationPoints: Array.from(articulationPoints).sort(defaultTieBreaker),\n    bridges,\n  };\n}\n\nexport function analyzeGraph<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: GraphAnalysisOptions = {},\n): GraphAnalysisResult<NodeId> {\n  const scc = stronglyConnectedComponents(nodes, edges, options);\n  const weak = weaklyConnectedComponents(nodes, edges);\n  const articulation = articulationPointsAndBridges(nodes, edges);\n  const dedupedNodes = dedupeNodeList(nodes, edges);\n  const orderedNodeIds = [...dedupedNodes].sort(defaultTieBreaker);\n  let betweennessByNode = new Map<NodeId, BetweennessCentralityRecord>();\n  let pageRankByNode = new Map<NodeId, PageRankRecord>();\n\n  try {\n    betweennessByNode = betweennessCentrality(nodes, edges, options);\n  } catch (error) {\n    if (\n      !(error instanceof GraphAlgorithmError) ||\n      error.code !== 'NEGATIVE_WEIGHT'\n    ) {\n      throw error;\n    }\n\n    betweennessByNode = new Map<NodeId, BetweennessCentralityRecord>();\n    for (const nodeId of orderedNodeIds) {\n      betweennessByNode.set(nodeId, {\n        raw: 0,\n        normalized: 0,\n      });\n    }\n  }\n\n  try {\n    const pageRankResult = pageRank(nodes, edges, {\n      directed: options.directed ?? true,\n      ...(options.pageRankOptions ?? {}),\n    });\n    pageRankByNode = pageRankResult.byNode;\n  } catch (error) {\n    if (\n      !(error instanceof GraphAlgorithmError) ||\n      error.code !== 'NEGATIVE_WEIGHT'\n    ) {\n      throw error;\n    }\n\n    const defaultScore = dedupedNodes.length > 0 ? 1 / dedupedNodes.length : 0;\n    pageRankByNode = new Map<NodeId, PageRankRecord>();\n    for (let index = 0; index < orderedNodeIds.length; index += 1) {\n      const nodeId = orderedNodeIds[index];\n      if (!nodeId) {\n        continue;\n      }\n      pageRankByNode.set(nodeId, {\n        score: defaultScore,\n        normalized: 1,\n        rank: index + 1,\n      });\n    }\n  }\n\n  return {\n    degree: degreeCentrality(nodes, edges, options),\n    closeness: closenessCentrality(nodes, edges, {\n      ...options,\n      mode: options.closenessMode ?? 'harmonic',\n      shortestPathAlgorithm: options.shortestPathAlgorithm,\n    }),\n    betweenness: betweennessByNode,\n    pageRank: pageRankByNode,\n    stronglyConnectedComponents: scc.components,\n    weaklyConnectedComponents: weak.components,\n    articulationPoints: articulation.articulationPoints,\n    bridges: articulation.bridges,\n  };\n}\n\nexport function shortestPath<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  source: NodeId,\n  target: NodeId,\n  options: ShortestPathOptions = {},\n): ShortestPathResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n  if (\n    !adjacency.neighborsByNode.has(source) ||\n    !adjacency.neighborsByNode.has(target)\n  ) {\n    return {\n      source,\n      target,\n      path: [],\n      distance: Number.POSITIVE_INFINITY,\n      reachable: false,\n      explored: 0,\n      algorithm: options.algorithm ?? 'auto',\n      hasNegativeWeights: hasNegativeWeights(adjacency),\n      negativeCycle: false,\n    };\n  }\n\n  const engine = runShortestPathEngine(\n    adjacency,\n    source,\n    options.algorithm ?? 'auto',\n  );\n\n  if (engine.result.negativeCycleNodes.has(target)) {\n    if (options.failOnNegativeCycle ?? false) {\n      throw new GraphAlgorithmError(\n        'NEGATIVE_CYCLE',\n        `Negative cycle reaches target node \"${target}\".`,\n      );\n    }\n\n    return {\n      source,\n      target,\n      path: [],\n      distance: Number.NEGATIVE_INFINITY,\n      reachable: false,\n      explored: engine.result.explored,\n      algorithm: engine.algorithm,\n      hasNegativeWeights: engine.hasNegativeWeights,\n      negativeCycle: true,\n    };\n  }\n\n  const distance =\n    engine.result.distanceByNode.get(target) ?? Number.POSITIVE_INFINITY;\n  const reachable = Number.isFinite(distance);\n\n  const path = reachable\n    ? reconstructPath(source, target, engine.result.previousByNode)\n    : [];\n\n  return {\n    source,\n    target,\n    path,\n    distance,\n    reachable: reachable && path.length > 0,\n    explored: engine.result.explored,\n    algorithm: engine.algorithm,\n    hasNegativeWeights: engine.hasNegativeWeights,\n    negativeCycle: engine.result.negativeCycleNodes.size > 0,\n  };\n}\n\nexport function labelPropagationCommunities<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: LabelPropagationOptions<NodeId> = {},\n): CommunityDetectionResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, {\n    directed: options.directed ?? false,\n  });\n  if (hasNegativeWeights(adjacency)) {\n    throw new GraphAlgorithmError(\n      'NEGATIVE_WEIGHT',\n      'Label propagation requires non-negative graph weights.',\n    );\n  }\n\n  const tieBreaker =\n    options.tieBreaker ??\n    ((left: NodeId, right: NodeId) => defaultTieBreaker(left, right));\n  const nodeOrder = [...adjacency.nodes].sort(tieBreaker);\n  const labelByNode = new Map<NodeId, number>();\n  for (let index = 0; index < nodeOrder.length; index += 1) {\n    const nodeId = nodeOrder[index];\n    if (nodeId) {\n      labelByNode.set(nodeId, index);\n    }\n  }\n\n  const maxIterations = Math.max(1, options.maxIterations ?? 100);\n  let iterations = 0;\n  let converged = false;\n\n  for (let iteration = 0; iteration < maxIterations; iteration += 1) {\n    iterations = iteration + 1;\n    let changed = false;\n\n    for (const nodeId of nodeOrder) {\n      const neighbors = adjacency.neighborsByNode.get(nodeId) ?? [];\n      if (neighbors.length === 0) {\n        continue;\n      }\n\n      const scoreByLabel = new Map<number, number>();\n      for (const neighbor of neighbors) {\n        const neighborLabel = labelByNode.get(neighbor.id);\n        if (neighborLabel === undefined) {\n          continue;\n        }\n        scoreByLabel.set(\n          neighborLabel,\n          (scoreByLabel.get(neighborLabel) ?? 0) + neighbor.weight,\n        );\n      }\n\n      const currentLabel = labelByNode.get(nodeId);\n      if (currentLabel === undefined || scoreByLabel.size === 0) {\n        continue;\n      }\n\n      let bestLabel = currentLabel;\n      let bestScore = Number.NEGATIVE_INFINITY;\n\n      for (const [candidateLabel, score] of scoreByLabel.entries()) {\n        if (score > bestScore + 1e-12) {\n          bestScore = score;\n          bestLabel = candidateLabel;\n          continue;\n        }\n        if (Math.abs(score - bestScore) <= 1e-12 && candidateLabel < bestLabel) {\n          bestLabel = candidateLabel;\n        }\n      }\n\n      if (bestLabel !== currentLabel) {\n        labelByNode.set(nodeId, bestLabel);\n        changed = true;\n      }\n    }\n\n    if (!changed) {\n      converged = true;\n      break;\n    }\n  }\n\n  return buildCommunityResult(\n    adjacency,\n    labelByNode,\n    iterations,\n    converged,\n    'label-propagation',\n  );\n}\n\nexport function louvainCommunities<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: LouvainOptions<NodeId> = {},\n): CommunityDetectionResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, {\n    directed: options.directed ?? false,\n  });\n\n  if (hasNegativeWeights(adjacency)) {\n    throw new GraphAlgorithmError(\n      'NEGATIVE_WEIGHT',\n      'Louvain requires non-negative graph weights.',\n    );\n  }\n\n  const tieBreaker =\n    options.tieBreaker ??\n    ((left: NodeId, right: NodeId) => defaultTieBreaker(left, right));\n  const nodeOrder = [...adjacency.nodes].sort(tieBreaker);\n  const maxPasses = Math.max(1, options.maxPasses ?? 32);\n  const tolerance = Math.max(0, options.tolerance ?? 1e-9);\n\n  const degreeByNode = new Map<NodeId, number>();\n  for (const nodeId of adjacency.nodes) {\n    degreeByNode.set(\n      nodeId,\n      sumNeighborWeights(adjacency.neighborsByNode.get(nodeId) ?? []),\n    );\n  }\n\n  let totalDegree = 0;\n  for (const degree of degreeByNode.values()) {\n    totalDegree += degree;\n  }\n\n  const labelByNode = new Map<NodeId, number>();\n  const communityWeight = new Map<number, number>();\n  for (let index = 0; index < nodeOrder.length; index += 1) {\n    const nodeId = nodeOrder[index];\n    if (!nodeId) {\n      continue;\n    }\n    labelByNode.set(nodeId, index);\n    const degree = degreeByNode.get(nodeId) ?? 0;\n    communityWeight.set(index, degree);\n  }\n\n  if (totalDegree <= 1e-12) {\n    return buildCommunityResult(adjacency, labelByNode, 0, true, 'louvain');\n  }\n\n  let iterations = 0;\n  let converged = false;\n\n  for (let pass = 0; pass < maxPasses; pass += 1) {\n    iterations = pass + 1;\n    let changed = false;\n\n    for (const nodeId of nodeOrder) {\n      const currentLabel = labelByNode.get(nodeId);\n      if (currentLabel === undefined) {\n        continue;\n      }\n\n      const nodeDegree = degreeByNode.get(nodeId) ?? 0;\n      communityWeight.set(\n        currentLabel,\n        (communityWeight.get(currentLabel) ?? 0) - nodeDegree,\n      );\n\n      const edgeWeightByCommunity = new Map<number, number>();\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n        const candidateLabel = labelByNode.get(neighbor.id);\n        if (candidateLabel === undefined) {\n          continue;\n        }\n\n        edgeWeightByCommunity.set(\n          candidateLabel,\n          (edgeWeightByCommunity.get(candidateLabel) ?? 0) + neighbor.weight,\n        );\n      }\n\n      let bestLabel = currentLabel;\n      let bestGain = 0;\n\n      for (const [candidateLabel, edgeWeight] of edgeWeightByCommunity.entries()) {\n        const candidateWeight = communityWeight.get(candidateLabel) ?? 0;\n        const gain = edgeWeight - (candidateWeight * nodeDegree) / totalDegree;\n\n        if (gain > bestGain + tolerance) {\n          bestGain = gain;\n          bestLabel = candidateLabel;\n          continue;\n        }\n\n        if (\n          Math.abs(gain - bestGain) <= tolerance &&\n          candidateLabel < bestLabel\n        ) {\n          bestLabel = candidateLabel;\n        }\n      }\n\n      if (bestLabel !== currentLabel && bestGain > tolerance) {\n        labelByNode.set(nodeId, bestLabel);\n        communityWeight.set(\n          bestLabel,\n          (communityWeight.get(bestLabel) ?? 0) + nodeDegree,\n        );\n        changed = true;\n      } else {\n        communityWeight.set(\n          currentLabel,\n          (communityWeight.get(currentLabel) ?? 0) + nodeDegree,\n        );\n      }\n    }\n\n    if (!changed) {\n      converged = true;\n      break;\n    }\n  }\n\n  return buildCommunityResult(\n    adjacency,\n    labelByNode,\n    iterations,\n    converged,\n    'louvain',\n  );\n}\n\nexport function nodeSimilarity<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: SimilarityOptions = {},\n): NodeSimilarityResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, {\n    directed: options.directed ?? false,\n  });\n  const metric = options.metric ?? 'jaccard';\n  const minScore = options.minScore ?? 0;\n  const neighborSets = buildNeighborIdSetMap(adjacency);\n  const orderedNodes = [...adjacency.nodes].sort(defaultTieBreaker);\n  const pairs: Array<Omit<NodeSimilarityRecord<NodeId>, 'rank'>> = [];\n\n  for (let leftIndex = 0; leftIndex < orderedNodes.length; leftIndex += 1) {\n    const leftId = orderedNodes[leftIndex];\n    if (!leftId) {\n      continue;\n    }\n    for (\n      let rightIndex = leftIndex + 1;\n      rightIndex < orderedNodes.length;\n      rightIndex += 1\n    ) {\n      const rightId = orderedNodes[rightIndex];\n      if (!rightId) {\n        continue;\n      }\n      const score = computeSimilarityScore(leftId, rightId, neighborSets, metric);\n      if (score < minScore - 1e-12) {\n        continue;\n      }\n      pairs.push({\n        left: leftId,\n        right: rightId,\n        score,\n        metric,\n      });\n    }\n  }\n\n  pairs.sort((left, right) => {\n    const scoreDelta = right.score - left.score;\n    if (Math.abs(scoreDelta) > 1e-12) {\n      return scoreDelta;\n    }\n    const leftDelta = defaultTieBreaker(left.left, right.left);\n    if (leftDelta !== 0) {\n      return leftDelta;\n    }\n    return defaultTieBreaker(left.right, right.right);\n  });\n\n  return {\n    metric,\n    pairs: pairs.map((pair, index) => ({\n      ...pair,\n      rank: index + 1,\n    })),\n  };\n}\n\nexport function kNearestNeighbors<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: KNearestNeighborsOptions = {},\n): KNearestNeighborsResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, {\n    directed: options.directed ?? false,\n  });\n  const metric = options.metric ?? 'jaccard';\n  const minScore = options.minScore ?? 0;\n  const k = Math.max(1, Math.floor(options.k ?? 5));\n  const neighborSets = buildNeighborIdSetMap(adjacency);\n  const orderedNodes = [...adjacency.nodes].sort(defaultTieBreaker);\n  const neighborsByNode = new Map<NodeId, KNearestNeighbor<NodeId>[]>();\n\n  for (const nodeId of orderedNodes) {\n    const candidates: KNearestNeighbor<NodeId>[] = [];\n    for (const otherId of orderedNodes) {\n      if (nodeId === otherId) {\n        continue;\n      }\n      const score = computeSimilarityScore(nodeId, otherId, neighborSets, metric);\n      if (score < minScore - 1e-12) {\n        continue;\n      }\n      candidates.push({\n        nodeId: otherId,\n        score,\n      });\n    }\n\n    candidates.sort((left, right) => {\n      const scoreDelta = right.score - left.score;\n      if (Math.abs(scoreDelta) > 1e-12) {\n        return scoreDelta;\n      }\n      return defaultTieBreaker(left.nodeId, right.nodeId);\n    });\n\n    neighborsByNode.set(nodeId, candidates.slice(0, k));\n  }\n\n  return {\n    metric,\n    k,\n    neighborsByNode,\n  };\n}\n\nexport function predictLinks<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: LinkPredictionOptions<NodeId> = {},\n): LinkPredictionResult<NodeId> {\n  const directed = options.directed ?? false;\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed });\n  const metric = options.metric ?? 'jaccard';\n  const minScore = options.minScore ?? 0;\n  const limit = Math.max(1, Math.floor(options.limit ?? 20));\n  const allowExistingEdges = options.allowExistingEdges ?? false;\n  const neighborSets = buildNeighborIdSetMap(adjacency);\n  const orderedNodes = [...adjacency.nodes].sort(defaultTieBreaker);\n  const sourceFilterSet = options.sourceFilter\n    ? new Set(options.sourceFilter)\n    : null;\n  const targetFilterSet = options.targetFilter\n    ? new Set(options.targetFilter)\n    : null;\n  const existingEdgeKeys = new Set<string>();\n\n  for (const edge of adjacency.edges) {\n    if (directed) {\n      existingEdgeKeys.add(`${edge.from}\\u0000${edge.to}`);\n    } else {\n      existingEdgeKeys.add(undirectedEdgeKey(edge.from, edge.to));\n    }\n  }\n\n  const predictions: Array<Omit<LinkPredictionRecord<NodeId>, 'rank'>> = [];\n\n  if (directed) {\n    for (const fromId of orderedNodes) {\n      if (sourceFilterSet && !sourceFilterSet.has(fromId)) {\n        continue;\n      }\n      for (const toId of orderedNodes) {\n        if (fromId === toId) {\n          continue;\n        }\n        if (targetFilterSet && !targetFilterSet.has(toId)) {\n          continue;\n        }\n        if (\n          !allowExistingEdges &&\n          existingEdgeKeys.has(`${fromId}\\u0000${toId}`)\n        ) {\n          continue;\n        }\n\n        const score = computeSimilarityScore(fromId, toId, neighborSets, metric);\n        if (score < minScore - 1e-12) {\n          continue;\n        }\n        predictions.push({\n          from: fromId,\n          to: toId,\n          score,\n          metric,\n        });\n      }\n    }\n  } else {\n    for (let leftIndex = 0; leftIndex < orderedNodes.length; leftIndex += 1) {\n      const fromId = orderedNodes[leftIndex];\n      if (!fromId) {\n        continue;\n      }\n      for (\n        let rightIndex = leftIndex + 1;\n        rightIndex < orderedNodes.length;\n        rightIndex += 1\n      ) {\n        const toId = orderedNodes[rightIndex];\n        if (!toId) {\n          continue;\n        }\n\n        if (\n          sourceFilterSet &&\n          !sourceFilterSet.has(fromId) &&\n          !sourceFilterSet.has(toId)\n        ) {\n          continue;\n        }\n        if (\n          targetFilterSet &&\n          !targetFilterSet.has(fromId) &&\n          !targetFilterSet.has(toId)\n        ) {\n          continue;\n        }\n        if (\n          !allowExistingEdges &&\n          existingEdgeKeys.has(undirectedEdgeKey(fromId, toId))\n        ) {\n          continue;\n        }\n\n        const score = computeSimilarityScore(fromId, toId, neighborSets, metric);\n        if (score < minScore - 1e-12) {\n          continue;\n        }\n        predictions.push({\n          from: fromId,\n          to: toId,\n          score,\n          metric,\n        });\n      }\n    }\n  }\n\n  predictions.sort((left, right) => {\n    const scoreDelta = right.score - left.score;\n    if (Math.abs(scoreDelta) > 1e-12) {\n      return scoreDelta;\n    }\n    const fromDelta = defaultTieBreaker(left.from, right.from);\n    if (fromDelta !== 0) {\n      return fromDelta;\n    }\n    return defaultTieBreaker(left.to, right.to);\n  });\n\n  return {\n    metric,\n    predictions: predictions.slice(0, limit).map((prediction, index) => ({\n      ...prediction,\n      rank: index + 1,\n    })),\n  };\n}\n\nexport function linkPrediction<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: LinkPredictionOptions<NodeId> = {},\n): LinkPredictionResult<NodeId> {\n  return predictLinks(nodes, edges, options);\n}\n\nexport function aStarShortestPath<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  source: NodeId,\n  target: NodeId,\n  options: AStarOptions<NodeId> = {},\n): AStarResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n  if (hasNegativeWeights(adjacency)) {\n    throw new GraphAlgorithmError(\n      'NEGATIVE_WEIGHT',\n      'A* requires non-negative graph weights.',\n    );\n  }\n\n  if (\n    !adjacency.neighborsByNode.has(source) ||\n    !adjacency.neighborsByNode.has(target)\n  ) {\n    return {\n      source,\n      target,\n      path: [],\n      distance: Number.POSITIVE_INFINITY,\n      reachable: false,\n      explored: 0,\n      estimatedDistance: Number.POSITIVE_INFINITY,\n    };\n  }\n\n  const heuristic =\n    options.heuristic ??\n    ((_nodeId: NodeId, _targetId: NodeId): number => 0);\n\n  const queue = new MinPriorityQueue<NodeId>();\n  const gScore = new Map<NodeId, number>();\n  const previousByNode = new Map<NodeId, NodeId>();\n  const closedSet = new Set<NodeId>();\n\n  for (const nodeId of adjacency.nodes) {\n    gScore.set(nodeId, Number.POSITIVE_INFINITY);\n  }\n\n  gScore.set(source, 0);\n  const startHeuristic = heuristic(source, target);\n  if (!Number.isFinite(startHeuristic)) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'A* heuristic must return finite values.',\n    );\n  }\n  queue.push(source, startHeuristic);\n\n  let explored = 0;\n\n  while (queue.size > 0) {\n    const item = queue.pop();\n    if (!item) {\n      break;\n    }\n\n    const nodeId = item.value;\n    if (closedSet.has(nodeId)) {\n      continue;\n    }\n    closedSet.add(nodeId);\n    explored += 1;\n\n    if (nodeId === target) {\n      break;\n    }\n\n    const currentDistance = gScore.get(nodeId);\n    if (currentDistance === undefined || !Number.isFinite(currentDistance)) {\n      continue;\n    }\n\n    for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\n      const candidate = currentDistance + neighbor.weight;\n      const known = gScore.get(neighbor.id) ?? Number.POSITIVE_INFINITY;\n      if (candidate >= known - 1e-12) {\n        continue;\n      }\n\n      const estimate = heuristic(neighbor.id, target);\n      if (!Number.isFinite(estimate)) {\n        throw new GraphAlgorithmError(\n          'INVALID_ARGUMENT',\n          'A* heuristic must return finite values.',\n        );\n      }\n\n      gScore.set(neighbor.id, candidate);\n      previousByNode.set(neighbor.id, nodeId);\n      queue.push(neighbor.id, candidate + estimate);\n    }\n  }\n\n  const distance = gScore.get(target) ?? Number.POSITIVE_INFINITY;\n  const reachable = Number.isFinite(distance);\n  const path = reachable ? reconstructPath(source, target, previousByNode) : [];\n\n  return {\n    source,\n    target,\n    path,\n    distance,\n    reachable: reachable && path.length > 0,\n    explored,\n    estimatedDistance: distance,\n  };\n}\n\nexport function allPairsShortestPaths<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: AllPairsShortestPathsOptions = {},\n): AllPairsShortestPathsResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n  const requestedAlgorithm = options.algorithm ?? 'auto';\n  const chosenAlgorithm = chooseShortestPathAlgorithm(\n    requestedAlgorithm,\n    hasNegativeWeights(adjacency),\n  );\n\n  const distanceBySource = new Map<NodeId, Map<NodeId, number>>();\n  const previousBySource = new Map<NodeId, Map<NodeId, NodeId>>();\n  let negativeCycle = false;\n\n  for (const source of adjacency.nodes) {\n    const engine = runShortestPathEngine(adjacency, source, chosenAlgorithm);\n    if (engine.result.negativeCycleNodes.size > 0) {\n      negativeCycle = true;\n      if (options.failOnNegativeCycle ?? false) {\n        throw new GraphAlgorithmError(\n          'NEGATIVE_CYCLE',\n          `Negative cycle reaches source node \"${source}\".`,\n        );\n      }\n    }\n\n    const distance = new Map<NodeId, number>();\n    const previous = new Map<NodeId, NodeId>();\n    for (const nodeId of adjacency.nodes) {\n      distance.set(\n        nodeId,\n        engine.result.distanceByNode.get(nodeId) ?? Number.POSITIVE_INFINITY,\n      );\n      const prev = engine.result.previousByNode.get(nodeId);\n      if (prev) {\n        previous.set(nodeId, prev);\n      }\n    }\n\n    distanceBySource.set(source, distance);\n    previousBySource.set(source, previous);\n  }\n\n  return {\n    nodes: adjacency.nodes,\n    distanceBySource,\n    previousBySource,\n    algorithm: chosenAlgorithm,\n    hasNegativeWeights: hasNegativeWeights(adjacency),\n    negativeCycle,\n  };\n}\n\nexport function yenKShortestPaths<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  source: NodeId,\n  target: NodeId,\n  options: YenKShortestPathsOptions = {},\n): YenKShortestPathsResult<NodeId> {\n  const directed = options.directed ?? true;\n  const k = Math.max(1, Math.floor(options.k ?? 3));\n  const shortestPathAlgorithm = options.shortestPathAlgorithm ?? 'auto';\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed });\n\n  if (\n    !adjacency.neighborsByNode.has(source) ||\n    !adjacency.neighborsByNode.has(target)\n  ) {\n    return {\n      source,\n      target,\n      paths: [],\n      complete: false,\n    };\n  }\n\n  const first = shortestPath(adjacency.nodes, adjacency.edges, source, target, {\n    directed,\n    algorithm: shortestPathAlgorithm,\n  });\n  if (!first.reachable || first.path.length === 0) {\n    return {\n      source,\n      target,\n      paths: [],\n      complete: false,\n    };\n  }\n\n  const accepted: PathRecord<NodeId>[] = [\n    {\n      path: first.path,\n      distance: first.distance,\n    },\n  ];\n  const candidates = new Map<string, PathRecord<NodeId>>();\n\n  for (let pathIndex = 1; pathIndex < k; pathIndex += 1) {\n    const previous = accepted[pathIndex - 1]?.path ?? [];\n    if (previous.length < 2) {\n      break;\n    }\n\n    for (let spurIndex = 0; spurIndex < previous.length - 1; spurIndex += 1) {\n      const spurNode = previous[spurIndex];\n      if (!spurNode) {\n        continue;\n      }\n\n      const rootPath = previous.slice(0, spurIndex + 1);\n      const rootNodeExclusion = new Set(rootPath.slice(0, -1));\n      const removedEdgeKeys = new Set<string>();\n\n      for (const pathRecord of accepted) {\n        if (\n          pathRecord.path.length > spurIndex + 1 &&\n          hasSamePrefix(pathRecord.path, rootPath)\n        ) {\n          const fromId = pathRecord.path[spurIndex];\n          const toId = pathRecord.path[spurIndex + 1];\n          if (fromId && toId) {\n            removedEdgeKeys.add(`${fromId}\\u0000${toId}`);\n          }\n        }\n      }\n\n      const filteredEdges = adjacency.edges.filter((edge) => {\n        if (removedEdgeKeys.has(`${edge.from}\\u0000${edge.to}`)) {\n          return false;\n        }\n        if (rootNodeExclusion.has(edge.from) || rootNodeExclusion.has(edge.to)) {\n          return false;\n        }\n        return true;\n      });\n\n      const spurPath = shortestPath(\n        adjacency.nodes,\n        filteredEdges,\n        spurNode,\n        target,\n        {\n          directed,\n          algorithm: shortestPathAlgorithm,\n        },\n      );\n\n      if (!spurPath.reachable || spurPath.path.length === 0) {\n        continue;\n      }\n\n      const totalPath = rootPath.slice(0, -1).concat(spurPath.path);\n      const totalDistance = routeDistanceForPath(totalPath, adjacency);\n      if (!Number.isFinite(totalDistance)) {\n        continue;\n      }\n\n      const key = pathKey(totalPath);\n      if (!candidates.has(key)) {\n        candidates.set(key, {\n          path: totalPath,\n          distance: totalDistance,\n        });\n      }\n    }\n\n    if (candidates.size === 0) {\n      break;\n    }\n\n    const next = Array.from(candidates.values()).sort((left, right) => {\n      const distanceDelta = left.distance - right.distance;\n      if (Math.abs(distanceDelta) > 1e-12) {\n        return distanceDelta;\n      }\n      return defaultTieBreaker(pathKey(left.path), pathKey(right.path));\n    })[0];\n\n    if (!next) {\n      break;\n    }\n\n    accepted.push(next);\n    candidates.delete(pathKey(next.path));\n  }\n\n  return {\n    source,\n    target,\n    paths: accepted,\n    complete: accepted.length >= k,\n  };\n}\n\nexport function maximumFlow<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  source: NodeId,\n  sink: NodeId,\n  options: MaximumFlowOptions = {},\n): MaximumFlowResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n  if (\n    !adjacency.neighborsByNode.has(source) ||\n    !adjacency.neighborsByNode.has(sink)\n  ) {\n    return {\n      source,\n      sink,\n      maxFlow: 0,\n      augmentations: 0,\n      flowByEdge: [],\n      sourcePartition: [],\n      sinkPartition: [],\n      cutEdges: [],\n    };\n  }\n\n  const originalEdges: Array<Required<GraphEdge<NodeId>>> = [];\n  for (const edge of adjacency.edges) {\n    if (edge.weight < 0) {\n      throw new GraphAlgorithmError(\n        'NEGATIVE_WEIGHT',\n        'Maximum flow requires non-negative capacities.',\n      );\n    }\n    originalEdges.push(edge);\n  }\n\n  interface ResidualEdge {\n    to: NodeId;\n    reverseIndex: number;\n    capacity: number;\n    originalIndex: number | null;\n  }\n\n  const residual = new Map<NodeId, ResidualEdge[]>();\n  for (const nodeId of adjacency.nodes) {\n    residual.set(nodeId, []);\n  }\n\n  const addResidualEdge = (\n    from: NodeId,\n    to: NodeId,\n    capacity: number,\n    originalIndex: number,\n  ): void => {\n    const fromEdges = residual.get(from);\n    const toEdges = residual.get(to);\n    if (!fromEdges || !toEdges) {\n      return;\n    }\n\n    const forwardIndex = fromEdges.length;\n    const reverseIndex = toEdges.length;\n    fromEdges.push({\n      to,\n      reverseIndex,\n      capacity,\n      originalIndex,\n    });\n    toEdges.push({\n      to: from,\n      reverseIndex: forwardIndex,\n      capacity: 0,\n      originalIndex: null,\n    });\n  };\n\n  for (let index = 0; index < originalEdges.length; index += 1) {\n    const edge = originalEdges[index];\n    if (!edge) {\n      continue;\n    }\n    addResidualEdge(edge.from, edge.to, edge.weight, index);\n  }\n\n  let maxFlow = 0;\n  let augmentations = 0;\n  const flowByOriginal = new Array<number>(originalEdges.length).fill(0);\n\n  while (true) {\n    const parent = new Map<NodeId, { from: NodeId; edgeIndex: number }>();\n    const queue: NodeId[] = [source];\n    parent.set(source, { from: source, edgeIndex: -1 });\n\n    let queueIndex = 0;\n    while (queueIndex < queue.length && !parent.has(sink)) {\n      const nodeId = queue[queueIndex];\n      queueIndex += 1;\n      if (!nodeId) {\n        continue;\n      }\n\n      const edgesFromNode = residual.get(nodeId) ?? [];\n      for (let edgeIndex = 0; edgeIndex < edgesFromNode.length; edgeIndex += 1) {\n        const edge = edgesFromNode[edgeIndex];\n        if (!edge || edge.capacity <= 1e-12) {\n          continue;\n        }\n        if (parent.has(edge.to)) {\n          continue;\n        }\n\n        parent.set(edge.to, { from: nodeId, edgeIndex });\n        queue.push(edge.to);\n      }\n    }\n\n    if (!parent.has(sink)) {\n      break;\n    }\n\n    let bottleneck = Number.POSITIVE_INFINITY;\n    let cursor: NodeId = sink;\n\n    while (cursor !== source) {\n      const parentEntry = parent.get(cursor);\n      if (!parentEntry) {\n        bottleneck = 0;\n        break;\n      }\n      const edge = residual.get(parentEntry.from)?.[parentEntry.edgeIndex];\n      if (!edge) {\n        bottleneck = 0;\n        break;\n      }\n      bottleneck = Math.min(bottleneck, edge.capacity);\n      cursor = parentEntry.from;\n    }\n\n    if (!Number.isFinite(bottleneck) || bottleneck <= 1e-12) {\n      break;\n    }\n\n    cursor = sink;\n    while (cursor !== source) {\n      const parentEntry = parent.get(cursor);\n      if (!parentEntry) {\n        break;\n      }\n      const edge = residual.get(parentEntry.from)?.[parentEntry.edgeIndex];\n      const reverse = edge\n        ? residual.get(edge.to)?.[edge.reverseIndex]\n        : undefined;\n      if (!edge || !reverse) {\n        break;\n      }\n\n      edge.capacity -= bottleneck;\n      reverse.capacity += bottleneck;\n\n      if (edge.originalIndex !== null) {\n        flowByOriginal[edge.originalIndex] =\n          (flowByOriginal[edge.originalIndex] ?? 0) + bottleneck;\n      } else if (reverse.originalIndex !== null) {\n        flowByOriginal[reverse.originalIndex] =\n          (flowByOriginal[reverse.originalIndex] ?? 0) - bottleneck;\n      }\n\n      cursor = parentEntry.from;\n    }\n\n    maxFlow += bottleneck;\n    augmentations += 1;\n  }\n\n  const reachableFromSource = new Set<NodeId>();\n  const partitionQueue: NodeId[] = [source];\n  reachableFromSource.add(source);\n  let partitionCursor = 0;\n\n  while (partitionCursor < partitionQueue.length) {\n    const nodeId = partitionQueue[partitionCursor];\n    partitionCursor += 1;\n    if (!nodeId) {\n      continue;\n    }\n\n    for (const edge of residual.get(nodeId) ?? []) {\n      if (edge.capacity <= 1e-12 || reachableFromSource.has(edge.to)) {\n        continue;\n      }\n      reachableFromSource.add(edge.to);\n      partitionQueue.push(edge.to);\n    }\n  }\n\n  const sourcePartition = adjacency.nodes\n    .filter((nodeId) => reachableFromSource.has(nodeId))\n    .sort(defaultTieBreaker);\n  const sinkPartition = adjacency.nodes\n    .filter((nodeId) => !reachableFromSource.has(nodeId))\n    .sort(defaultTieBreaker);\n\n  const cutEdges = originalEdges\n    .filter(\n      (edge) =>\n        reachableFromSource.has(edge.from) && !reachableFromSource.has(edge.to),\n    )\n    .sort((left, right) => {\n      const fromDelta = defaultTieBreaker(left.from, right.from);\n      if (fromDelta !== 0) {\n        return fromDelta;\n      }\n      return defaultTieBreaker(left.to, right.to);\n    });\n\n  const flowByEdge = originalEdges\n    .map((edge, index) => ({\n      from: edge.from,\n      to: edge.to,\n      flow: Math.max(0, flowByOriginal[index] ?? 0),\n      capacity: edge.weight,\n    }))\n    .sort((left, right) => {\n      const fromDelta = defaultTieBreaker(left.from, right.from);\n      if (fromDelta !== 0) {\n        return fromDelta;\n      }\n      return defaultTieBreaker(left.to, right.to);\n    });\n\n  return {\n    source,\n    sink,\n    maxFlow,\n    augmentations,\n    flowByEdge,\n    sourcePartition,\n    sinkPartition,\n    cutEdges,\n  };\n}\n\nexport function minCostMaxFlow<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: FlowEdge<NodeId>[],\n  source: NodeId,\n  sink: NodeId,\n  options: MinCostMaxFlowOptions = {},\n): MinCostMaxFlowResult<NodeId> {\n  const edgeProjection: GraphEdge<NodeId>[] = edges.map((edge) => ({\n    from: edge.from,\n    to: edge.to,\n    weight: edge.capacity,\n  }));\n  const nodeIds = dedupeNodeList(nodes, edgeProjection);\n  const directed = options.directed ?? true;\n\n  if (!nodeIds.includes(source) || !nodeIds.includes(sink)) {\n    return {\n      source,\n      sink,\n      flow: 0,\n      cost: 0,\n      complete: false,\n      augmentations: 0,\n      flowByEdge: [],\n    };\n  }\n\n  interface ResidualCostEdge {\n    to: NodeId;\n    reverseIndex: number;\n    capacity: number;\n    cost: number;\n    originalIndex: number | null;\n  }\n\n  interface OriginalCostEdge {\n    from: NodeId;\n    to: NodeId;\n    capacity: number;\n    cost: number;\n  }\n\n  const originals: OriginalCostEdge[] = [];\n  for (const edge of edges) {\n    if (!Number.isFinite(edge.capacity) || edge.capacity < 0) {\n      throw new GraphAlgorithmError(\n        'INVALID_ARGUMENT',\n        `Flow edge capacity must be non-negative and finite, received ${edge.capacity}.`,\n      );\n    }\n    const cost = edge.cost ?? 0;\n    if (!Number.isFinite(cost)) {\n      throw new GraphAlgorithmError(\n        'INVALID_ARGUMENT',\n        `Flow edge cost must be finite, received ${cost}.`,\n      );\n    }\n\n    originals.push({\n      from: edge.from,\n      to: edge.to,\n      capacity: edge.capacity,\n      cost,\n    });\n\n    if (!directed) {\n      originals.push({\n        from: edge.to,\n        to: edge.from,\n        capacity: edge.capacity,\n        cost,\n      });\n    }\n  }\n\n  const residual = new Map<NodeId, ResidualCostEdge[]>();\n  for (const nodeId of nodeIds) {\n    residual.set(nodeId, []);\n  }\n\n  const addResidualEdge = (\n    from: NodeId,\n    to: NodeId,\n    capacity: number,\n    cost: number,\n    originalIndex: number,\n  ): void => {\n    const fromEdges = residual.get(from);\n    const toEdges = residual.get(to);\n    if (!fromEdges || !toEdges) {\n      return;\n    }\n\n    const forwardIndex = fromEdges.length;\n    const reverseIndex = toEdges.length;\n    fromEdges.push({\n      to,\n      reverseIndex,\n      capacity,\n      cost,\n      originalIndex,\n    });\n    toEdges.push({\n      to: from,\n      reverseIndex: forwardIndex,\n      capacity: 0,\n      cost: -cost,\n      originalIndex: null,\n    });\n  };\n\n  for (let index = 0; index < originals.length; index += 1) {\n    const edge = originals[index];\n    if (!edge) {\n      continue;\n    }\n    addResidualEdge(edge.from, edge.to, edge.capacity, edge.cost, index);\n  }\n\n  const targetFlowRaw = options.targetFlow;\n  const targetFlow =\n    targetFlowRaw === undefined ? Number.POSITIVE_INFINITY : targetFlowRaw;\n  if (!Number.isFinite(targetFlow) && targetFlow !== Number.POSITIVE_INFINITY) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      `targetFlow must be finite or omitted, received ${targetFlow}.`,\n    );\n  }\n  if (targetFlow < 0) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      `targetFlow must be non-negative, received ${targetFlow}.`,\n    );\n  }\n\n  let flow = 0;\n  let cost = 0;\n  let augmentations = 0;\n  const flowByOriginal = new Array<number>(originals.length).fill(0);\n\n  while (flow < targetFlow - 1e-12) {\n    const distance = new Map<NodeId, number>();\n    const parent = new Map<NodeId, { from: NodeId; edgeIndex: number }>();\n\n    for (const nodeId of nodeIds) {\n      distance.set(nodeId, Number.POSITIVE_INFINITY);\n    }\n    distance.set(source, 0);\n\n    for (let iteration = 0; iteration < nodeIds.length - 1; iteration += 1) {\n      let changed = false;\n      for (const nodeId of nodeIds) {\n        const currentDistance = distance.get(nodeId);\n        if (currentDistance === undefined || !Number.isFinite(currentDistance)) {\n          continue;\n        }\n\n        const edgesFromNode = residual.get(nodeId) ?? [];\n        for (\n          let edgeIndex = 0;\n          edgeIndex < edgesFromNode.length;\n          edgeIndex += 1\n        ) {\n          const edge = edgesFromNode[edgeIndex];\n          if (!edge || edge.capacity <= 1e-12) {\n            continue;\n          }\n\n          const candidateDistance = currentDistance + edge.cost;\n          const knownDistance =\n            distance.get(edge.to) ?? Number.POSITIVE_INFINITY;\n\n          if (candidateDistance < knownDistance - 1e-12) {\n            distance.set(edge.to, candidateDistance);\n            parent.set(edge.to, { from: nodeId, edgeIndex });\n            changed = true;\n          }\n        }\n      }\n\n      if (!changed) {\n        break;\n      }\n    }\n\n    const sinkDistance = distance.get(sink) ?? Number.POSITIVE_INFINITY;\n    if (!Number.isFinite(sinkDistance)) {\n      break;\n    }\n\n    let bottleneck = Math.min(targetFlow - flow, Number.POSITIVE_INFINITY);\n    let cursor: NodeId = sink;\n\n    while (cursor !== source) {\n      const parentEntry = parent.get(cursor);\n      if (!parentEntry) {\n        bottleneck = 0;\n        break;\n      }\n      const edge = residual.get(parentEntry.from)?.[parentEntry.edgeIndex];\n      if (!edge) {\n        bottleneck = 0;\n        break;\n      }\n      bottleneck = Math.min(bottleneck, edge.capacity);\n      cursor = parentEntry.from;\n    }\n\n    if (!Number.isFinite(bottleneck) || bottleneck <= 1e-12) {\n      break;\n    }\n\n    cursor = sink;\n    while (cursor !== source) {\n      const parentEntry = parent.get(cursor);\n      if (!parentEntry) {\n        break;\n      }\n      const edge = residual.get(parentEntry.from)?.[parentEntry.edgeIndex];\n      const reverse = edge\n        ? residual.get(edge.to)?.[edge.reverseIndex]\n        : undefined;\n      if (!edge || !reverse) {\n        break;\n      }\n\n      edge.capacity -= bottleneck;\n      reverse.capacity += bottleneck;\n\n      if (edge.originalIndex !== null) {\n        flowByOriginal[edge.originalIndex] =\n          (flowByOriginal[edge.originalIndex] ?? 0) + bottleneck;\n      } else if (reverse.originalIndex !== null) {\n        flowByOriginal[reverse.originalIndex] =\n          (flowByOriginal[reverse.originalIndex] ?? 0) - bottleneck;\n      }\n\n      cursor = parentEntry.from;\n    }\n\n    flow += bottleneck;\n    cost += bottleneck * sinkDistance;\n    augmentations += 1;\n  }\n\n  const flowByEdge = originals\n    .map((edge, index) => ({\n      from: edge.from,\n      to: edge.to,\n      flow: Math.max(0, flowByOriginal[index] ?? 0),\n      capacity: edge.capacity,\n      cost: edge.cost,\n    }))\n    .sort((left, right) => {\n      const fromDelta = defaultTieBreaker(left.from, right.from);\n      if (fromDelta !== 0) {\n        return fromDelta;\n      }\n      return defaultTieBreaker(left.to, right.to);\n    });\n\n  return {\n    source,\n    sink,\n    flow,\n    cost,\n    complete:\n      targetFlow === Number.POSITIVE_INFINITY\n        ? true\n        : flow >= targetFlow - 1e-12,\n    augmentations,\n    flowByEdge,\n  };\n}\n\nexport function kMeansClustering(\n  points: number[][],\n  k: number,\n  options: KMeansOptions = {},\n): KMeansResult {\n  if (!Array.isArray(points) || points.length === 0) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'kMeansClustering requires at least one point.',\n    );\n  }\n\n  const dimensionality = points[0]?.length ?? 0;\n  if (dimensionality === 0) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'kMeansClustering requires points with at least one axis.',\n    );\n  }\n\n  for (const point of points) {\n    if (point.length !== dimensionality) {\n      throw new GraphAlgorithmError(\n        'INVALID_ARGUMENT',\n        'kMeansClustering requires all points to share dimensionality.',\n      );\n    }\n  }\n\n  const clusterCount = Math.max(1, Math.min(points.length, Math.floor(k)));\n  const maxIterations = Math.max(1, options.maxIterations ?? 120);\n  const tolerance = Math.max(0, options.tolerance ?? 1e-5);\n  const nInit = Math.max(1, options.nInit ?? 8);\n  const normalization = options.normalization ?? 'zscore';\n  const useKMeansPlusPlus = options.useKMeansPlusPlus ?? true;\n  const baseSeed =\n    options.seed === undefined || !Number.isFinite(options.seed)\n      ? Math.floor(Math.random() * 0xffffffff)\n      : Math.floor(options.seed);\n\n  const transform = normalizePoints(points, normalization);\n  const normalizedPoints = points.map((point) => transform.normalize(point));\n\n  let best: KMeansRunResult | null = null;\n  let bestSeed = baseSeed;\n\n  for (let attempt = 0; attempt < nInit; attempt += 1) {\n    const seed = (baseSeed + attempt * 2654435761) >>> 0;\n    const random = createRandom(seed);\n    const run = runSingleKMeans(\n      normalizedPoints,\n      clusterCount,\n      random,\n      maxIterations,\n      tolerance,\n      useKMeansPlusPlus,\n    );\n\n    if (!best || run.inertia < best.inertia - 1e-9) {\n      best = run;\n      bestSeed = seed;\n    }\n  }\n\n  if (!best) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'kMeansClustering failed to produce a valid run.',\n    );\n  }\n\n  const clusters: KMeansCluster[] = [];\n  for (let clusterIndex = 0; clusterIndex < clusterCount; clusterIndex += 1) {\n    const indices: number[] = [];\n    for (let pointIndex = 0; pointIndex < best.assignments.length; pointIndex += 1) {\n      if (best.assignments[pointIndex] === clusterIndex) {\n        indices.push(pointIndex);\n      }\n    }\n\n    clusters.push({\n      centroid: transform.denormalize(best.centroidsNormalized[clusterIndex] ?? []),\n      indices,\n    });\n  }\n\n  const silhouette = computeSilhouette(\n    normalizedPoints,\n    best.assignments,\n    clusterCount,\n  );\n\n  return {\n    assignments: best.assignments,\n    clusters,\n    iterations: best.iterations,\n    inertia: best.inertia,\n    converged: best.converged,\n    silhouette,\n    selectedSeed: bestSeed,\n  };\n}\n\nexport function kMeansAuto(points: number[][], options: KMeansAutoOptions = {}): KMeansAutoResult {\n  if (!Array.isArray(points) || points.length === 0) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'kMeansAuto requires at least one point.',\n    );\n  }\n\n  const minK = Math.max(2, options.kMin ?? 2);\n  const maxK = Math.max(\n    minK,\n    Math.min(points.length, options.kMax ?? Math.min(10, Math.ceil(Math.sqrt(points.length)) + 2)),\n  );\n\n  let bestResult: KMeansResult | null = null;\n  let bestK = minK;\n  const candidates: KMeansAutoCandidate[] = [];\n\n  for (let k = minK; k <= maxK; k += 1) {\n    const result = kMeansClustering(points, k, {\n      ...options,\n      seed:\n        options.seed === undefined || !Number.isFinite(options.seed)\n          ? undefined\n          : options.seed + k * 997,\n    });\n\n    candidates.push({\n      k,\n      silhouette: result.silhouette,\n      inertia: result.inertia,\n    });\n\n    if (!bestResult) {\n      bestResult = result;\n      bestK = k;\n      continue;\n    }\n\n    const currentSilhouette = result.silhouette ?? Number.NEGATIVE_INFINITY;\n    const bestSilhouette = bestResult.silhouette ?? Number.NEGATIVE_INFINITY;\n\n    if (currentSilhouette > bestSilhouette + 1e-9) {\n      bestResult = result;\n      bestK = k;\n      continue;\n    }\n\n    if (\n      Math.abs(currentSilhouette - bestSilhouette) <= 1e-9 &&\n      result.inertia < bestResult.inertia - 1e-9\n    ) {\n      bestResult = result;\n      bestK = k;\n    }\n  }\n\n  if (!bestResult) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'kMeansAuto failed to choose a cluster configuration.',\n    );\n  }\n\n  return {\n    ...bestResult,\n    selectedK: bestK,\n    candidates,\n  };\n}\n\nexport function travelingSalesmanApprox<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: TravelingSalesmanOptions<NodeId> = {},\n): TravelingSalesmanResult<NodeId> {\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\n\n  if (adjacency.nodes.length === 0) {\n    return {\n      order: [],\n      distance: 0,\n      segments: [],\n      visitedCount: 0,\n      complete: true,\n      unreachableNodes: [],\n      lowerBound: 0,\n      optimalityGap: 0,\n    };\n  }\n\n  if (hasNegativeWeights(adjacency)) {\n    throw new GraphAlgorithmError(\n      'NEGATIVE_WEIGHT',\n      'TSP approximation requires non-negative graph weights.',\n    );\n  }\n\n  const returnToStart = options.returnToStart ?? true;\n  const twoOptPasses = Math.max(0, options.twoOptPasses ?? 3);\n  const starts = createDeterministicStartList(adjacency.nodes, options);\n\n  const distanceMatrix = new Map<NodeId, Map<NodeId, number>>();\n  const previousMatrix = new Map<NodeId, Map<NodeId, NodeId>>();\n\n  for (const source of adjacency.nodes) {\n    const engine = runShortestPathEngine(\n      adjacency,\n      source,\n      options.shortestPathAlgorithm ?? 'auto',\n    );\n\n    if (engine.result.negativeCycleNodes.size > 0) {\n      throw new GraphAlgorithmError(\n        'NEGATIVE_CYCLE',\n        'TSP approximation cannot run when negative cycles are reachable.',\n      );\n    }\n\n    distanceMatrix.set(source, engine.result.distanceByNode);\n    previousMatrix.set(source, engine.result.previousByNode);\n  }\n\n  let bestRoute: NodeId[] = [];\n  let bestDistance = Number.POSITIVE_INFINITY;\n\n  for (const start of starts) {\n    const greedyRoute = buildGreedyRoute(\n      start,\n      adjacency.nodes,\n      distanceMatrix,\n      returnToStart,\n    );\n\n    let candidateRoute = greedyRoute;\n    if (candidateRoute.length > 2) {\n      candidateRoute = optimizeRouteTwoOpt(\n        candidateRoute,\n        distanceMatrix,\n        twoOptPasses,\n      );\n    }\n\n    const candidateDistance = routeDistanceFromMatrix(\n      candidateRoute,\n      distanceMatrix,\n    );\n\n    if (candidateDistance < bestDistance) {\n      bestDistance = candidateDistance;\n      bestRoute = candidateRoute;\n    }\n  }\n\n  const visited = new Set(bestRoute);\n  const unreachableNodes = adjacency.nodes.filter((nodeId) => !visited.has(nodeId));\n  const complete = unreachableNodes.length === 0 && Number.isFinite(bestDistance);\n\n  const segments: TravelingSalesmanSegment<NodeId>[] = [];\n  let totalDistance = 0;\n\n  for (let index = 1; index < bestRoute.length; index += 1) {\n    const fromId = bestRoute[index - 1];\n    const toId = bestRoute[index];\n    if (!fromId || !toId) {\n      continue;\n    }\n\n    const distance = distanceMatrix.get(fromId)?.get(toId) ?? Number.POSITIVE_INFINITY;\n    const previous = previousMatrix.get(fromId) ?? new Map<NodeId, NodeId>();\n    const path = reconstructPath(fromId, toId, previous);\n\n    if (!Number.isFinite(distance) || path.length === 0) {\n      continue;\n    }\n\n    totalDistance += distance;\n    segments.push({\n      from: fromId,\n      to: toId,\n      distance,\n      path,\n    });\n  }\n\n  if (!complete) {\n    totalDistance = Number.POSITIVE_INFINITY;\n  }\n\n  const lowerBound = computeMstLowerBound(adjacency.nodes, distanceMatrix);\n  const optimalityGap =\n    complete &&\n    Number.isFinite(totalDistance) &&\n    Number.isFinite(lowerBound) &&\n    lowerBound > 0\n      ? (totalDistance - lowerBound) / lowerBound\n      : null;\n\n  return {\n    order: bestRoute,\n    distance: totalDistance,\n    segments,\n    visitedCount: visited.size,\n    complete,\n    unreachableNodes,\n    lowerBound,\n    optimalityGap,\n  };\n}\n\n//  Hierarchical Clustering \n\nexport type LinkageMethod = 'single' | 'complete' | 'average' | 'ward';\n\nexport interface DendrogramNode {\n  left: number;\n  right: number;\n  distance: number;\n  size: number;\n}\n\nexport interface HierarchicalClusterResult {\n  clusters: number[][];\n  assignments: number[];\n  dendrogram: DendrogramNode[];\n  silhouette: number | null;\n}\n\nexport function hierarchicalClustering(\n  points: number[][],\n  k: number,\n  options: {\n    linkage?: LinkageMethod;\n    distanceMetric?: 'euclidean' | 'cosine' | 'manhattan';\n  } = {},\n): HierarchicalClusterResult {\n  if (!Array.isArray(points) || points.length === 0) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'hierarchicalClustering requires at least one point.',\n    );\n  }\n\n  const n = points.length;\n  const clusterCount = Math.max(1, Math.min(n, Math.floor(k)));\n  const linkage = options.linkage ?? 'average';\n  const metric = options.distanceMetric ?? 'euclidean';\n\n  const distFn = (a: number[], b: number[]): number => {\n    switch (metric) {\n      case 'cosine': {\n        const sim = distanceCosineSimilarity(a, b);\n        return 1 - sim;\n      }\n      case 'manhattan':\n        return manhattanDistance(a, b);\n      default:\n        return euclideanDistance(a, b);\n    }\n  };\n\n  // Initialize: each point is its own cluster\n  // clusterMembers[i] = array of point indices in cluster i\n  const clusterMembers: number[][] = points.map((_, i) => [i]);\n  // active[i] = whether cluster i is still active\n  const active: boolean[] = new Array(n).fill(true);\n  const dendrogram: DendrogramNode[] = [];\n\n  // Precompute pairwise distances\n  const distMatrix: number[][] = Array.from({ length: n }, () =>\n    new Array<number>(n).fill(0),\n  );\n  for (let i = 0; i < n; i += 1) {\n    for (let j = i + 1; j < n; j += 1) {\n      const d = distFn(points[i], points[j]);\n      distMatrix[i][j] = d;\n      distMatrix[j][i] = d;\n    }\n  }\n\n  // Cluster distances (for lance-williams updates or direct computation)\n  const clusterDist: number[][] = Array.from({ length: n }, (_, i) =>\n    [...distMatrix[i]],\n  );\n\n  let activeCount = n;\n\n  while (activeCount > clusterCount) {\n    // Find closest pair of active clusters\n    let bestI = -1;\n    let bestJ = -1;\n    let bestDist = Number.POSITIVE_INFINITY;\n\n    for (let i = 0; i < clusterMembers.length; i += 1) {\n      if (!active[i]) continue;\n      for (let j = i + 1; j < clusterMembers.length; j += 1) {\n        if (!active[j]) continue;\n        if (clusterDist[i][j] < bestDist) {\n          bestDist = clusterDist[i][j];\n          bestI = i;\n          bestJ = j;\n        }\n      }\n    }\n\n    if (bestI === -1 || bestJ === -1) break;\n\n    // Merge bestJ into bestI\n    dendrogram.push({\n      left: bestI < n ? -(bestI + 1) : bestI,\n      right: bestJ < n ? -(bestJ + 1) : bestJ,\n      distance: bestDist,\n      size: clusterMembers[bestI].length + clusterMembers[bestJ].length,\n    });\n\n    const mergedMembers = clusterMembers[bestI].concat(clusterMembers[bestJ]);\n    clusterMembers[bestI] = mergedMembers;\n    active[bestJ] = false;\n    activeCount -= 1;\n\n    // Update distances from merged cluster to all other active clusters\n    for (let other = 0; other < clusterMembers.length; other += 1) {\n      if (!active[other] || other === bestI) continue;\n\n      let newDist: number;\n      switch (linkage) {\n        case 'single':\n          newDist = Math.min(clusterDist[bestI][other], clusterDist[bestJ][other]);\n          break;\n        case 'complete':\n          newDist = Math.max(clusterDist[bestI][other], clusterDist[bestJ][other]);\n          break;\n        case 'ward': {\n          // Lance-Williams formula for Ward's method\n          const ni = clusterMembers[bestI].length - clusterMembers[bestJ].length;\n          const nj = clusterMembers[bestJ].length;\n          const nk = clusterMembers[other].length;\n          const total = ni + nj + nk;\n          newDist = Math.sqrt(\n            ((ni + nk) * clusterDist[bestI][other] * clusterDist[bestI][other] +\n              (nj + nk) * clusterDist[bestJ][other] * clusterDist[bestJ][other] -\n              nk * bestDist * bestDist) /\n              total,\n          );\n          break;\n        }\n        default: {\n          // average linkage\n          const sizeI = clusterMembers[bestI].length - clusterMembers[bestJ].length;\n          const sizeJ = clusterMembers[bestJ].length;\n          newDist =\n            (clusterDist[bestI][other] * sizeI +\n              clusterDist[bestJ][other] * sizeJ) /\n            (sizeI + sizeJ);\n          break;\n        }\n      }\n\n      clusterDist[bestI][other] = newDist;\n      clusterDist[other][bestI] = newDist;\n    }\n  }\n\n  // Build final cluster assignments\n  const assignments = new Array<number>(n).fill(-1);\n  const clusters: number[][] = [];\n  let clusterIdx = 0;\n  for (let i = 0; i < clusterMembers.length; i += 1) {\n    if (!active[i]) continue;\n    clusters.push(clusterMembers[i]);\n    for (const ptIdx of clusterMembers[i]) {\n      assignments[ptIdx] = clusterIdx;\n    }\n    clusterIdx += 1;\n  }\n\n  // Compute silhouette\n  const silhouette = computeSilhouette(points, assignments, clusters.length);\n\n  return {\n    clusters,\n    assignments,\n    dendrogram,\n    silhouette,\n  };\n}\n\n//  DBSCAN \n\nexport interface DbscanResult {\n  clusters: number[][];\n  assignments: number[];\n  noise: number[];\n  clusterCount: number;\n}\n\nexport function dbscan(\n  points: number[][],\n  epsilon: number,\n  minPoints: number,\n  options: {\n    distanceMetric?: 'euclidean' | 'cosine' | 'manhattan';\n  } = {},\n): DbscanResult {\n  if (!Array.isArray(points) || points.length === 0) {\n    throw new GraphAlgorithmError(\n      'INVALID_ARGUMENT',\n      'dbscan requires at least one point.',\n    );\n  }\n\n  const n = points.length;\n  const metric = options.distanceMetric ?? 'euclidean';\n\n  const distFn = (a: number[], b: number[]): number => {\n    switch (metric) {\n      case 'cosine':\n        return 1 - distanceCosineSimilarity(a, b);\n      case 'manhattan':\n        return manhattanDistance(a, b);\n      default:\n        return euclideanDistance(a, b);\n    }\n  };\n\n  const UNVISITED = -2;\n  const NOISE = -1;\n  const assignments = new Array<number>(n).fill(UNVISITED);\n  let currentCluster = 0;\n\n  // Find neighbors within epsilon\n  const regionQuery = (pointIdx: number): number[] => {\n    const neighbors: number[] = [];\n    for (let i = 0; i < n; i += 1) {\n      if (distFn(points[pointIdx], points[i]) <= epsilon) {\n        neighbors.push(i);\n      }\n    }\n    return neighbors;\n  };\n\n  for (let i = 0; i < n; i += 1) {\n    if (assignments[i] !== UNVISITED) continue;\n\n    const neighbors = regionQuery(i);\n\n    if (neighbors.length < minPoints) {\n      assignments[i] = NOISE;\n      continue;\n    }\n\n    // Start a new cluster\n    assignments[i] = currentCluster;\n    const seed = [...neighbors];\n    let seedIdx = 0;\n\n    while (seedIdx < seed.length) {\n      const j = seed[seedIdx];\n      seedIdx += 1;\n\n      if (assignments[j] === NOISE) {\n        assignments[j] = currentCluster;\n      }\n      if (assignments[j] !== UNVISITED) continue;\n\n      assignments[j] = currentCluster;\n      const jNeighbors = regionQuery(j);\n      if (jNeighbors.length >= minPoints) {\n        for (const neighbor of jNeighbors) {\n          if (!seed.includes(neighbor)) {\n            seed.push(neighbor);\n          }\n        }\n      }\n    }\n\n    currentCluster += 1;\n  }\n\n  // Build output\n  const clusters: number[][] = Array.from(\n    { length: currentCluster },\n    () => [],\n  );\n  const noise: number[] = [];\n\n  for (let i = 0; i < n; i += 1) {\n    if (assignments[i] === NOISE) {\n      noise.push(i);\n    } else {\n      clusters[assignments[i]].push(i);\n    }\n  }\n\n  return {\n    clusters,\n    assignments,\n    noise,\n    clusterCount: currentCluster,\n  };\n}\n","/**\n * Graph EDA  What Tukey Would Have Done With Graphs\n *\n * Treats graph structural properties as data series that deserve\n * full exploratory data analysis treatment.\n */\n\nimport { Series } from './index';\nimport type {\n  SeriesDescription,\n  GraphNodeInput,\n  GraphEdge,\n} from './index';\n\n//  Types \n\nexport interface GraphEdaSummary<NodeId extends string = string> {\n  nodeCount: number;\n  edgeCount: number;\n  density: number;\n  degreeDistribution: SeriesDescription;\n  inDegreeDistribution: SeriesDescription;\n  outDegreeDistribution: SeriesDescription;\n  clusteringCoefficients: Map<NodeId, number>;\n  globalClusteringCoefficient: number;\n  clusteringDistribution: SeriesDescription;\n  averagePathLength: number;\n  diameter: number;\n  reciprocity: number;\n  degreeAssortativity: number;\n}\n\nexport interface GraphOutlierResult<NodeId extends string = string> {\n  nodeId: NodeId;\n  score: number;\n  reason: string;\n}\n\n//  Helpers \n\nfunction resolveNodeId<NodeId extends string>(\n  node: GraphNodeInput<NodeId>,\n): NodeId {\n  if (typeof node === 'string') return node;\n  return node.id;\n}\n\nfunction buildAdjacencyMaps<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  directed: boolean,\n): {\n  nodeIds: NodeId[];\n  outNeighbors: Map<NodeId, Set<NodeId>>;\n  inNeighbors: Map<NodeId, Set<NodeId>>;\n  edgeSet: Set<string>;\n} {\n  const nodeIdSet = new Set<NodeId>();\n  for (const node of nodes) {\n    nodeIdSet.add(resolveNodeId(node));\n  }\n  for (const edge of edges) {\n    nodeIdSet.add(edge.from as NodeId);\n    nodeIdSet.add(edge.to as NodeId);\n  }\n\n  const nodeIds = Array.from(nodeIdSet).sort();\n  const outNeighbors = new Map<NodeId, Set<NodeId>>();\n  const inNeighbors = new Map<NodeId, Set<NodeId>>();\n  const edgeSet = new Set<string>();\n\n  for (const id of nodeIds) {\n    outNeighbors.set(id, new Set());\n    inNeighbors.set(id, new Set());\n  }\n\n  for (const edge of edges) {\n    const from = edge.from as NodeId;\n    const to = edge.to as NodeId;\n    outNeighbors.get(from)?.add(to);\n    inNeighbors.get(to)?.add(from);\n    edgeSet.add(`${from}\\0${to}`);\n\n    if (!directed) {\n      outNeighbors.get(to)?.add(from);\n      inNeighbors.get(from)?.add(to);\n      edgeSet.add(`${to}\\0${from}`);\n    }\n  }\n\n  return { nodeIds, outNeighbors, inNeighbors, edgeSet };\n}\n\n//  Clustering Coefficient \n\n/**\n * Compute the local clustering coefficient for each node.\n * For undirected graphs: the fraction of pairs of neighbors that are connected.\n * For directed graphs: uses the total number of directed triangles.\n */\nexport function clusteringCoefficient<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: { directed?: boolean } = {},\n): Map<NodeId, number> {\n  const directed = options.directed ?? false;\n  const { nodeIds, outNeighbors, edgeSet } = buildAdjacencyMaps(\n    nodes,\n    edges,\n    directed,\n  );\n\n  const result = new Map<NodeId, number>();\n\n  for (const nodeId of nodeIds) {\n    const neighbors = outNeighbors.get(nodeId)!;\n    const k = neighbors.size;\n\n    if (k < 2) {\n      result.set(nodeId, 0);\n      continue;\n    }\n\n    const neighborArr = Array.from(neighbors);\n    let triangles = 0;\n\n    for (let i = 0; i < neighborArr.length; i += 1) {\n      for (let j = i + 1; j < neighborArr.length; j += 1) {\n        const a = neighborArr[i];\n        const b = neighborArr[j];\n        if (directed) {\n          if (edgeSet.has(`${a}\\0${b}`)) triangles += 1;\n          if (edgeSet.has(`${b}\\0${a}`)) triangles += 1;\n        } else {\n          if (edgeSet.has(`${a}\\0${b}`) || edgeSet.has(`${b}\\0${a}`)) {\n            triangles += 1;\n          }\n        }\n      }\n    }\n\n    const maxTriangles = directed ? k * (k - 1) : (k * (k - 1)) / 2;\n    result.set(nodeId, maxTriangles > 0 ? triangles / maxTriangles : 0);\n  }\n\n  return result;\n}\n\n//  Graph EDA \n\n/**\n * Full exploratory data analysis of a graph's structural properties.\n * Returns distributions as Series descriptions for full Tukey-style EDA.\n */\nexport function graphEda<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: {\n    directed?: boolean;\n    samplePathLength?: number;\n  } = {},\n): GraphEdaSummary<NodeId> {\n  const directed = options.directed ?? false;\n  const { nodeIds, outNeighbors, inNeighbors, edgeSet } = buildAdjacencyMaps(\n    nodes,\n    edges,\n    directed,\n  );\n\n  const nodeCount = nodeIds.length;\n  const edgeCount = edges.length;\n\n  // Density\n  const maxEdges = directed\n    ? nodeCount * (nodeCount - 1)\n    : (nodeCount * (nodeCount - 1)) / 2;\n  const density = maxEdges > 0 ? edgeCount / maxEdges : 0;\n\n  // Degree distributions\n  const degrees: number[] = [];\n  const inDegrees: number[] = [];\n  const outDegrees: number[] = [];\n\n  for (const nodeId of nodeIds) {\n    const outDeg = outNeighbors.get(nodeId)?.size ?? 0;\n    const inDeg = inNeighbors.get(nodeId)?.size ?? 0;\n    outDegrees.push(outDeg);\n    inDegrees.push(inDeg);\n    degrees.push(directed ? outDeg + inDeg : outDeg);\n  }\n\n  const degreeSeries = new Series({ data: degrees });\n  const inDegreeSeries = new Series({ data: inDegrees });\n  const outDegreeSeries = new Series({ data: outDegrees });\n\n  // Clustering coefficients\n  const cc = clusteringCoefficient(nodes, edges, { directed });\n  const ccValues = Array.from(cc.values());\n  const globalCC =\n    ccValues.length > 0\n      ? ccValues.reduce((a, b) => a + b, 0) / ccValues.length\n      : 0;\n  const ccSeries = new Series({ data: ccValues.length > 0 ? ccValues : [0] });\n\n  // Reciprocity (fraction of edges with a reverse edge)\n  let reciprocalCount = 0;\n  if (directed) {\n    for (const edge of edges) {\n      if (edgeSet.has(`${edge.to}\\0${edge.from}`)) {\n        reciprocalCount += 1;\n      }\n    }\n  }\n  const reciprocity = directed && edgeCount > 0\n    ? reciprocalCount / edgeCount\n    : directed\n      ? 0\n      : 1;\n\n  // BFS-based path length sampling\n  const sampleSize = Math.min(\n    nodeCount,\n    options.samplePathLength ?? Math.min(nodeCount, 50),\n  );\n  let totalPathLength = 0;\n  let pathCount = 0;\n  let diameter = 0;\n\n  // Sample nodes deterministically\n  const sampleStep = Math.max(1, Math.floor(nodeCount / sampleSize));\n  for (let si = 0; si < nodeCount && si / sampleStep < sampleSize; si += sampleStep) {\n    const source = nodeIds[si];\n    // BFS from source\n    const dist = new Map<NodeId, number>();\n    dist.set(source, 0);\n    const queue: NodeId[] = [source];\n    let qi = 0;\n\n    while (qi < queue.length) {\n      const current = queue[qi];\n      qi += 1;\n      const currentDist = dist.get(current)!;\n      const neighbors = outNeighbors.get(current) ?? new Set<NodeId>();\n\n      for (const neighbor of neighbors) {\n        if (!dist.has(neighbor)) {\n          const d = currentDist + 1;\n          dist.set(neighbor, d);\n          queue.push(neighbor);\n          totalPathLength += d;\n          pathCount += 1;\n          if (d > diameter) diameter = d;\n        }\n      }\n    }\n  }\n\n  const averagePathLength = pathCount > 0 ? totalPathLength / pathCount : 0;\n\n  // Degree assortativity: Pearson correlation of degrees at edge endpoints\n  let assortativity = 0;\n  if (edges.length > 1) {\n    const sourceDegrees: number[] = [];\n    const targetDegrees: number[] = [];\n    for (const edge of edges) {\n      sourceDegrees.push(outNeighbors.get(edge.from as NodeId)?.size ?? 0);\n      targetDegrees.push(outNeighbors.get(edge.to as NodeId)?.size ?? 0);\n    }\n    const n = sourceDegrees.length;\n    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;\n    for (let i = 0; i < n; i += 1) {\n      sumX += sourceDegrees[i];\n      sumY += targetDegrees[i];\n      sumXY += sourceDegrees[i] * targetDegrees[i];\n      sumX2 += sourceDegrees[i] * sourceDegrees[i];\n      sumY2 += targetDegrees[i] * targetDegrees[i];\n    }\n    const numerator = n * sumXY - sumX * sumY;\n    const denominator = Math.sqrt(\n      (n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY),\n    );\n    assortativity = denominator > 0 ? numerator / denominator : 0;\n  }\n\n  return {\n    nodeCount,\n    edgeCount,\n    density,\n    degreeDistribution: degreeSeries.describe(),\n    inDegreeDistribution: inDegreeSeries.describe(),\n    outDegreeDistribution: outDegreeSeries.describe(),\n    clusteringCoefficients: cc,\n    globalClusteringCoefficient: globalCC,\n    clusteringDistribution: ccSeries.describe(),\n    averagePathLength,\n    diameter,\n    reciprocity,\n    degreeAssortativity: assortativity,\n  };\n}\n\n//  Graph Outliers \n\n/**\n * Graph-based outlier detection: nodes with unusual structural signatures.\n */\nexport function graphOutliers<NodeId extends string>(\n  nodes: GraphNodeInput<NodeId>[],\n  edges: GraphEdge<NodeId>[],\n  options: {\n    method?: 'degree' | 'clustering' | 'combined';\n    threshold?: number;\n  } = {},\n): GraphOutlierResult<NodeId>[] {\n  const method = options.method ?? 'combined';\n  const threshold = options.threshold ?? 2.0;\n  const directed = false;\n  const { nodeIds, outNeighbors } = buildAdjacencyMaps(nodes, edges, directed);\n\n  const results: GraphOutlierResult<NodeId>[] = [];\n\n  if (method === 'degree' || method === 'combined') {\n    const degrees = nodeIds.map((id) => outNeighbors.get(id)?.size ?? 0);\n    const degreeSeries = new Series({ data: degrees });\n    const mean = degreeSeries.mean();\n    const std = degreeSeries.stddev();\n\n    if (std > 0) {\n      for (let i = 0; i < nodeIds.length; i += 1) {\n        const zscore = Math.abs(degrees[i] - mean) / std;\n        if (zscore > threshold) {\n          results.push({\n            nodeId: nodeIds[i],\n            score: zscore,\n            reason: `degree outlier (z=${zscore.toFixed(2)}, degree=${degrees[i]})`,\n          });\n        }\n      }\n    }\n  }\n\n  if (method === 'clustering' || method === 'combined') {\n    const cc = clusteringCoefficient(nodes, edges, { directed });\n    const ccValues = Array.from(cc.values());\n    const ccSeries = new Series({ data: ccValues.length > 0 ? ccValues : [0] });\n    const mean = ccSeries.mean();\n    const std = ccSeries.stddev();\n\n    if (std > 0) {\n      let i = 0;\n      for (const nodeId of nodeIds) {\n        const value = cc.get(nodeId) ?? 0;\n        const zscore = Math.abs(value - mean) / std;\n        if (zscore > threshold) {\n          // Avoid duplicates in combined mode\n          const existing = results.find((r) => r.nodeId === nodeId);\n          if (existing) {\n            existing.score = Math.max(existing.score, zscore);\n            existing.reason += `; clustering outlier (z=${zscore.toFixed(2)}, cc=${value.toFixed(3)})`;\n          } else {\n            results.push({\n              nodeId,\n              score: zscore,\n              reason: `clustering outlier (z=${zscore.toFixed(2)}, cc=${value.toFixed(3)})`,\n            });\n          }\n        }\n        i += 1;\n      }\n    }\n  }\n\n  return results.sort((a, b) => b.score - a.score);\n}\n","import {\n  aStarShortestPath,\n  allPairsShortestPaths,\n  kNearestNeighbors,\n  labelPropagationCommunities,\n  louvainCommunities,\n  maximumFlow,\n  minCostMaxFlow,\n  nodeSimilarity,\n  pageRank,\n  predictLinks,\n  shortestPath,\n  yenKShortestPaths,\n  type AStarOptions,\n  type AStarResult,\n  type AllPairsShortestPathsOptions,\n  type AllPairsShortestPathsResult,\n  type CommunityDetectionResult,\n  type FlowEdge,\n  type GraphEdge,\n  type GraphNodeInput,\n  type KNearestNeighborsOptions,\n  type KNearestNeighborsResult,\n  type LabelPropagationOptions,\n  type LinkPredictionOptions,\n  type LinkPredictionResult,\n  type LouvainOptions,\n  type MaximumFlowOptions,\n  type MaximumFlowResult,\n  type MinCostMaxFlowOptions,\n  type MinCostMaxFlowResult,\n  type NodeSimilarityResult,\n  type PageRankOptions,\n  type PageRankResult,\n  type ShortestPathOptions,\n  type ShortestPathResult,\n  type SimilarityOptions,\n  type YenKShortestPathsOptions,\n  type YenKShortestPathsResult,\n  GraphAlgorithmError,\n  buildGraphAdjacency,\n} from './graph';\n\nexport interface GdsProjectOptions {\n  directed?: boolean;\n  replace?: boolean;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface GdsGraphProjection<NodeId extends string = string> {\n  name: string;\n  nodes: NodeId[];\n  edges: Array<Required<GraphEdge<NodeId>>>;\n  directed: boolean;\n  createdAt: number;\n  metadata: Record<string, unknown>;\n}\n\nexport interface GdsCatalogEntry {\n  name: string;\n  nodeCount: number;\n  edgeCount: number;\n  directed: boolean;\n  createdAt: number;\n  metadata: Record<string, unknown>;\n}\n\nexport type GdsPipelineStep<NodeId extends string = string> =\n  | { id: string; kind: 'page-rank'; options?: PageRankOptions }\n  | { id: string; kind: 'louvain'; options?: LouvainOptions<NodeId> }\n  | {\n      id: string;\n      kind: 'label-propagation';\n      options?: LabelPropagationOptions<NodeId>;\n    }\n  | { id: string; kind: 'similarity'; options?: SimilarityOptions }\n  | { id: string; kind: 'knn'; options?: KNearestNeighborsOptions }\n  | { id: string; kind: 'link-prediction'; options?: LinkPredictionOptions<NodeId> }\n  | {\n      id: string;\n      kind: 'shortest-path';\n      source: NodeId;\n      target: NodeId;\n      options?: ShortestPathOptions;\n    }\n  | {\n      id: string;\n      kind: 'a-star';\n      source: NodeId;\n      target: NodeId;\n      options?: AStarOptions<NodeId>;\n    }\n  | {\n      id: string;\n      kind: 'yen-k-shortest-paths';\n      source: NodeId;\n      target: NodeId;\n      options?: YenKShortestPathsOptions;\n    }\n  | {\n      id: string;\n      kind: 'max-flow';\n      source: NodeId;\n      sink: NodeId;\n      options?: MaximumFlowOptions;\n    }\n  | {\n      id: string;\n      kind: 'min-cost-max-flow';\n      source: NodeId;\n      sink: NodeId;\n      edges?: FlowEdge<NodeId>[] | null;\n      options?: MinCostMaxFlowOptions;\n    }\n  | {\n      id: string;\n      kind: 'all-pairs-shortest-paths';\n      options?: AllPairsShortestPathsOptions;\n    };\n\nexport type GdsPipelineOutput<NodeId extends string = string> =\n  | PageRankResult<NodeId>\n  | CommunityDetectionResult<NodeId>\n  | NodeSimilarityResult<NodeId>\n  | KNearestNeighborsResult<NodeId>\n  | LinkPredictionResult<NodeId>\n  | ShortestPathResult<NodeId>\n  | AStarResult<NodeId>\n  | YenKShortestPathsResult<NodeId>\n  | MaximumFlowResult<NodeId>\n  | MinCostMaxFlowResult<NodeId>\n  | AllPairsShortestPathsResult<NodeId>;\n\nexport class GraphCatalog<NodeId extends string = string> {\n  private projections = new Map<string, GdsGraphProjection<NodeId>>();\n\n  project(\n    name: string,\n    nodes: GraphNodeInput<NodeId>[],\n    edges: GraphEdge<NodeId>[],\n    options: GdsProjectOptions = {},\n  ): GdsGraphProjection<NodeId> {\n    const normalizedName = name.trim();\n    if (!normalizedName) {\n      throw new GraphAlgorithmError(\n        'INVALID_ARGUMENT',\n        'Projection name must be non-empty.',\n      );\n    }\n\n    if (this.projections.has(normalizedName) && !(options.replace ?? false)) {\n      throw new GraphAlgorithmError(\n        'INVALID_ARGUMENT',\n        `Projection \"${normalizedName}\" already exists.`,\n      );\n    }\n\n    const directed = options.directed ?? true;\n    const adjacency = buildGraphAdjacency(nodes, edges, { directed });\n    const projection: GdsGraphProjection<NodeId> = {\n      name: normalizedName,\n      nodes: adjacency.nodes,\n      edges: adjacency.edges,\n      directed,\n      createdAt: Date.now(),\n      metadata: options.metadata ?? {},\n    };\n\n    this.projections.set(normalizedName, projection);\n    return projection;\n  }\n\n  drop(name: string): boolean {\n    return this.projections.delete(name);\n  }\n\n  clear(): void {\n    this.projections.clear();\n  }\n\n  exists(name: string): boolean {\n    return this.projections.has(name);\n  }\n\n  get(name: string): GdsGraphProjection<NodeId> | null {\n    return this.projections.get(name) ?? null;\n  }\n\n  list(): GdsCatalogEntry[] {\n    return Array.from(this.projections.values())\n      .map((projection) => ({\n        name: projection.name,\n        nodeCount: projection.nodes.length,\n        edgeCount: projection.edges.length,\n        directed: projection.directed,\n        createdAt: projection.createdAt,\n        metadata: projection.metadata,\n      }))\n      .sort((left, right) => left.name.localeCompare(right.name));\n  }\n\n  pageRank(name: string, options: PageRankOptions = {}): PageRankResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return pageRank(projection.nodes, projection.edges, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  louvain(\n    name: string,\n    options: LouvainOptions<NodeId> = {},\n  ): CommunityDetectionResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return louvainCommunities(projection.nodes, projection.edges, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  labelPropagation(\n    name: string,\n    options: LabelPropagationOptions<NodeId> = {},\n  ): CommunityDetectionResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return labelPropagationCommunities(projection.nodes, projection.edges, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  similarity(\n    name: string,\n    options: SimilarityOptions = {},\n  ): NodeSimilarityResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return nodeSimilarity(projection.nodes, projection.edges, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  knn(\n    name: string,\n    options: KNearestNeighborsOptions = {},\n  ): KNearestNeighborsResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return kNearestNeighbors(projection.nodes, projection.edges, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  linkPrediction(\n    name: string,\n    options: LinkPredictionOptions<NodeId> = {},\n  ): LinkPredictionResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return predictLinks(projection.nodes, projection.edges, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  shortestPath(\n    name: string,\n    source: NodeId,\n    target: NodeId,\n    options: ShortestPathOptions = {},\n  ): ShortestPathResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return shortestPath(projection.nodes, projection.edges, source, target, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  aStar(\n    name: string,\n    source: NodeId,\n    target: NodeId,\n    options: AStarOptions<NodeId> = {},\n  ): AStarResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return aStarShortestPath(projection.nodes, projection.edges, source, target, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  yen(\n    name: string,\n    source: NodeId,\n    target: NodeId,\n    options: YenKShortestPathsOptions = {},\n  ): YenKShortestPathsResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return yenKShortestPaths(\n      projection.nodes,\n      projection.edges,\n      source,\n      target,\n      {\n        directed: projection.directed,\n        ...options,\n      },\n    );\n  }\n\n  allPairs(\n    name: string,\n    options: AllPairsShortestPathsOptions = {},\n  ): AllPairsShortestPathsResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return allPairsShortestPaths(projection.nodes, projection.edges, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  maxFlow(\n    name: string,\n    source: NodeId,\n    sink: NodeId,\n    options: MaximumFlowOptions = {},\n  ): MaximumFlowResult<NodeId> {\n    const projection = this.requireProjection(name);\n    return maximumFlow(projection.nodes, projection.edges, source, sink, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  minCostMaxFlow(\n    name: string,\n    source: NodeId,\n    sink: NodeId,\n    edges: FlowEdge<NodeId>[] | null = null,\n    options: MinCostMaxFlowOptions = {},\n  ): MinCostMaxFlowResult<NodeId> {\n    const projection = this.requireProjection(name);\n    const flowEdges =\n      edges ??\n      projection.edges.map((edge) => ({\n        from: edge.from,\n        to: edge.to,\n        capacity: edge.weight,\n        cost: edge.weight,\n      }));\n\n    return minCostMaxFlow(projection.nodes, flowEdges, source, sink, {\n      directed: projection.directed,\n      ...options,\n    });\n  }\n\n  runPipeline(\n    name: string,\n    steps: GdsPipelineStep<NodeId>[],\n  ): Map<string, GdsPipelineOutput<NodeId>> {\n    const output = new Map<string, GdsPipelineOutput<NodeId>>();\n\n    for (const step of steps) {\n      const stepId = step.id.trim();\n      if (!stepId) {\n        throw new GraphAlgorithmError(\n          'INVALID_ARGUMENT',\n          'Pipeline step id must be non-empty.',\n        );\n      }\n      if (output.has(stepId)) {\n        throw new GraphAlgorithmError(\n          'INVALID_ARGUMENT',\n          `Duplicate pipeline step id \"${stepId}\".`,\n        );\n      }\n\n      if (step.kind === 'page-rank') {\n        output.set(stepId, this.pageRank(name, step.options));\n        continue;\n      }\n      if (step.kind === 'louvain') {\n        output.set(stepId, this.louvain(name, step.options));\n        continue;\n      }\n      if (step.kind === 'label-propagation') {\n        output.set(stepId, this.labelPropagation(name, step.options));\n        continue;\n      }\n      if (step.kind === 'similarity') {\n        output.set(stepId, this.similarity(name, step.options));\n        continue;\n      }\n      if (step.kind === 'knn') {\n        output.set(stepId, this.knn(name, step.options));\n        continue;\n      }\n      if (step.kind === 'link-prediction') {\n        output.set(stepId, this.linkPrediction(name, step.options));\n        continue;\n      }\n      if (step.kind === 'shortest-path') {\n        output.set(\n          stepId,\n          this.shortestPath(name, step.source, step.target, step.options),\n        );\n        continue;\n      }\n      if (step.kind === 'a-star') {\n        output.set(stepId, this.aStar(name, step.source, step.target, step.options));\n        continue;\n      }\n      if (step.kind === 'yen-k-shortest-paths') {\n        output.set(stepId, this.yen(name, step.source, step.target, step.options));\n        continue;\n      }\n      if (step.kind === 'max-flow') {\n        output.set(stepId, this.maxFlow(name, step.source, step.sink, step.options));\n        continue;\n      }\n      if (step.kind === 'min-cost-max-flow') {\n        output.set(\n          stepId,\n          this.minCostMaxFlow(\n            name,\n            step.source,\n            step.sink,\n            step.edges ?? null,\n            step.options,\n          ),\n        );\n        continue;\n      }\n      if (step.kind === 'all-pairs-shortest-paths') {\n        output.set(stepId, this.allPairs(name, step.options));\n        continue;\n      }\n\n      const exhaustiveKind: never = step;\n      throw new GraphAlgorithmError(\n        'INVALID_ARGUMENT',\n        `Unsupported pipeline step kind \"${String(exhaustiveKind)}\".`,\n      );\n    }\n\n    return output;\n  }\n\n  private requireProjection(name: string): GdsGraphProjection<NodeId> {\n    const projection = this.projections.get(name);\n    if (!projection) {\n      throw new GraphAlgorithmError(\n        'INVALID_ARGUMENT',\n        `Projection \"${name}\" does not exist.`,\n      );\n    }\n    return projection;\n  }\n}\n\nexport function createGraphCatalog<NodeId extends string = string>(): GraphCatalog<NodeId> {\n  return new GraphCatalog<NodeId>();\n}\n\nexport const gds = createGraphCatalog<string>();\n","/**\n * Twokeys - A small data exploration and manipulation library\n * Named after John Tukey, pioneer of exploratory data analysis (EDA)\n *\n * Features:\n * - Summary statistics (mean, median, mode, quartiles)\n * - Binning (histogram-like grouping)\n * - Smoothing (Hanning filter and median smoothing)\n * - Ranking and ranking analysis\n * - Outlier detection (using Tukey fences)\n * - Data transforms (logarithms, roots, inverses)\n */\n\nexport interface SeriesOptions {\n  data?: number[];\n}\n\nexport interface PointsOptions {\n  data?: number[][];\n  dimensionality?: number;\n  count?: number;\n}\n\nexport interface MedianResult {\n  datum: number;\n  depth: number;\n}\n\nexport interface ModeResult {\n  count: number;\n  data: number[];\n}\n\nexport interface RankInfo {\n  rank: number;\n  peers: number;\n}\n\nexport interface RankedResult {\n  up: Record<number, RankInfo>;\n  down: Record<number, RankInfo>;\n  groups: {\n    up: (number | number[])[];\n    down: (number | number[])[];\n  };\n}\n\nexport interface BinnedResult {\n  bins: number;\n  width: number;\n  binned: Record<\n    number,\n    {\n      from: number;\n      to: number;\n      data: number[];\n    }\n  >;\n}\n\nexport interface SeriesDescription {\n  original: number[];\n  summary: {\n    median: MedianResult;\n    mean: number;\n    mode: ModeResult;\n    hinges: MedianResult[];\n    adjacent: number[];\n    outliers: number[];\n    outer: number[];\n    outside: number[];\n    inside: number[];\n    extremes: number[];\n    iqr: number;\n    fences: number[];\n  };\n  smooths: {\n    smooth: number[];\n    hanning: number[];\n  };\n  transforms: {\n    logs: number[];\n    roots: number[];\n    inverse: number[];\n  };\n  counts: [number, number][];\n  sorted: number[];\n  ranked: RankedResult;\n  binned: BinnedResult;\n}\n\nexport interface PointsDescription {\n  original: number[][];\n  centroid: number[];\n  variances: number[];\n  correlationMatrix: number[][];\n  mahalanobisDistances: number[];\n  outlierCount: number;\n  dimensionSummaries: SeriesDescription[];\n}\n\n// Constants\nconst DEFAULT_MAX_RANDOM_INTEGER = 100;\nconst DEFAULT_MIN_RANDOM_INTEGER = 0;\nconst DEFAULT_RANDOM_SERIES_COUNT = 1000;\nconst DEFAULT_OUTLIER_MULTIPLE = 1.5;\nconst DEFAULT_JITTER_MULTIPLIER = 1;\nconst DEFAULT_SPLIT_PASSES = 2;\nconst DEFAULT_MAX_RANDOM_DIMENSIONALITY = 2;\n\n// Utility functions\nfunction randomInteger(max: number = DEFAULT_MAX_RANDOM_INTEGER): number {\n  return Math.floor(Math.random() * max);\n}\n\nfunction randomSeries(\n  count: number = DEFAULT_RANDOM_SERIES_COUNT,\n  max: number = DEFAULT_MAX_RANDOM_INTEGER\n): number[] {\n  const series: number[] = [];\n  for (let i = 0; i < count; i++) {\n    series.push(randomInteger(max));\n  }\n  return series;\n}\n\nfunction randomPoint(\n  dimension: number = DEFAULT_MAX_RANDOM_DIMENSIONALITY,\n  max: number = DEFAULT_MAX_RANDOM_INTEGER\n): number[] {\n  const point: number[] = [];\n  for (let i = 0; i < dimension; i++) {\n    point.push(Math.floor((Math.random() * (max / 10)) % max));\n  }\n  return point;\n}\n\nfunction randomPoints(\n  count: number = DEFAULT_RANDOM_SERIES_COUNT,\n  dimension: number = DEFAULT_MAX_RANDOM_DIMENSIONALITY,\n  max: number = DEFAULT_MAX_RANDOM_INTEGER\n): number[][] {\n  const points: number[][] = [];\n  for (let i = 0; i < count; i++) {\n    points.push(randomPoint(dimension, max));\n  }\n  return points;\n}\n\n/**\n * Series class for 1D data exploration\n */\nexport class Series {\n  private data: {\n    original: number[];\n    sorted?: number[];\n    median?: number;\n    medianDepth?: number;\n    mean?: number;\n    variance?: number;\n    stddev?: number;\n    skewness?: number;\n    kurtosis?: number;\n    mode?: ModeResult;\n    extremes?: number[];\n    counts?: [number, number][];\n    hinges?: MedianResult[];\n    iqr?: number;\n    fences?: number[];\n    outer?: number[];\n    outside?: number[];\n    inside?: number[];\n    outliers?: number[];\n    ranked?: RankedResult;\n    adjacent?: number[];\n    binned?: BinnedResult;\n    logs?: number[];\n    roots?: number[];\n    inverse?: number[];\n    hanning?: number[];\n    smooth?: number[];\n    rough?: number[];\n    description?: SeriesDescription;\n  };\n\n  constructor(options: SeriesOptions = {}) {\n    this.data = {\n      original: options.data ?? randomSeries(),\n    };\n  }\n\n  // Sort\n  sorted(): number[] {\n    if (!this.data.sorted) {\n      this.data.sorted = this.getSorted(this.data.original);\n    }\n    return this.data.sorted;\n  }\n\n  private getSorted(arr: number[]): number[] {\n    return [...arr].sort((a, b) => {\n      if (a > b) return 1;\n      if (a === b) return 0;\n      return -1;\n    });\n  }\n\n  // Median\n  median(): MedianResult {\n    this.sorted();\n    if (this.data.median === undefined) {\n      this.data.median = this.getMedian(this.data.sorted!);\n    }\n    if (this.data.medianDepth === undefined) {\n      this.data.medianDepth = this.getMedianDepth(this.data.sorted!);\n    }\n    return {\n      datum: this.data.median,\n      depth: this.data.medianDepth,\n    };\n  }\n\n  private getMedianDepth(arr: number[], offset: number = 0): number {\n    if (!arr.length) return NaN;\n    return offset + (arr.length + 1) / 2;\n  }\n\n  private getMedian(arr: number[]): number {\n    const len = arr.length;\n    if (!len) return NaN;\n    if (len === 1) return arr[0];\n\n    const mid = Math.floor(len / 2);\n    if (len % 2 === 0) {\n      return (arr[mid - 1] + arr[mid]) / 2;\n    }\n    return arr[mid];\n  }\n\n  // Mean\n  mean(): number {\n    if (this.data.mean === undefined) {\n      this.data.mean = this.getMean(this.data.original);\n    }\n    return this.data.mean;\n  }\n\n  private getMean(arr: number[]): number {\n    if (!arr.length) return NaN;\n    let total = 0;\n    for (const num of arr) {\n      total += num;\n    }\n    return total / arr.length;\n  }\n\n  // Variance (sample variance: (x - mean) / (n - 1))\n  variance(): number {\n    if (this.data.variance === undefined) {\n      const m = this.mean();\n      const arr = this.data.original;\n      if (arr.length < 2) {\n        this.data.variance = NaN;\n      } else {\n        let sum = 0;\n        for (const val of arr) {\n          const delta = val - m;\n          sum += delta * delta;\n        }\n        this.data.variance = sum / (arr.length - 1);\n      }\n    }\n    return this.data.variance;\n  }\n\n  // Standard deviation: sqrt(variance)\n  stddev(): number {\n    if (this.data.stddev === undefined) {\n      this.data.stddev = Math.sqrt(this.variance());\n    }\n    return this.data.stddev;\n  }\n\n  // Exponential moving average series\n  ema(alpha: number): number[] {\n    const arr = this.data.original;\n    if (arr.length === 0) return [];\n    const result: number[] = [arr[0]];\n    for (let i = 1; i < arr.length; i += 1) {\n      const prev = result[i - 1];\n      result.push(prev * (1 - alpha) + arr[i] * alpha);\n    }\n    return result;\n  }\n\n  // Z-score normalization: (x - mean) / stddev\n  zscore(): number[] {\n    const m = this.mean();\n    const s = this.stddev();\n    if (s === 0 || isNaN(s)) {\n      return this.data.original.map(() => 0);\n    }\n    return this.data.original.map((val) => (val - m) / s);\n  }\n\n  // Fisher-Pearson skewness: n/((n-1)(n-2)) * ((x-mean)/stddev)\n  skewness(): number {\n    if (this.data.skewness === undefined) {\n      const arr = this.data.original;\n      const n = arr.length;\n      if (n < 3) {\n        this.data.skewness = NaN;\n      } else {\n        const m = this.mean();\n        const s = this.stddev();\n        if (s === 0) {\n          this.data.skewness = 0;\n        } else {\n          let sum = 0;\n          for (const val of arr) {\n            const z = (val - m) / s;\n            sum += z * z * z;\n          }\n          this.data.skewness = (n / ((n - 1) * (n - 2))) * sum;\n        }\n      }\n    }\n    return this.data.skewness;\n  }\n\n  // Excess kurtosis: adjusted fourth moment minus 3\n  kurtosis(): number {\n    if (this.data.kurtosis === undefined) {\n      const arr = this.data.original;\n      const n = arr.length;\n      if (n < 4) {\n        this.data.kurtosis = NaN;\n      } else {\n        const m = this.mean();\n        const s = this.stddev();\n        if (s === 0) {\n          this.data.kurtosis = 0;\n        } else {\n          let sum = 0;\n          for (const val of arr) {\n            const z = (val - m) / s;\n            sum += z * z * z * z;\n          }\n          const rawKurt = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3)) * sum;\n          const correction = (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n          this.data.kurtosis = rawKurt - correction;\n        }\n      }\n    }\n    return this.data.kurtosis;\n  }\n\n  // Mode\n  mode(): ModeResult {\n    if (!this.data.mode) {\n      this.sorted();\n      this.data.mode = this.getMode(this.data.sorted!);\n    }\n    return this.data.mode;\n  }\n\n  private getMode(data: number[]): ModeResult {\n    if (!data.length) {\n      return { count: 0, data: [] };\n    }\n\n    // Count frequencies\n    const freq: Record<number, number> = {};\n    let maxCount = 0;\n\n    for (const val of data) {\n      freq[val] = (freq[val] || 0) + 1;\n      if (freq[val] > maxCount) {\n        maxCount = freq[val];\n      }\n    }\n\n    // Find all values with max frequency\n    const modes: number[] = [];\n    for (const [val, count] of Object.entries(freq)) {\n      if (count === maxCount) {\n        modes.push(Number(val));\n      }\n    }\n\n    return {\n      count: maxCount,\n      data: modes.sort((a, b) => a - b),\n    };\n  }\n\n  // Extremes\n  extremes(): number[] {\n    if (!this.data.extremes) {\n      this.sorted();\n      this.data.extremes = this.getExtremes(this.data.sorted!);\n    }\n    return this.data.extremes;\n  }\n\n  private getExtremes(data: number[]): number[] {\n    if (!data.length) return [];\n    return [data[0], data[data.length - 1]];\n  }\n\n  // Counts\n  counts(): [number, number][] {\n    if (!this.data.counts) {\n      this.sorted();\n      this.data.counts = this.getCounts(this.data.sorted!);\n    }\n    return this.data.counts;\n  }\n\n  private getCounts(data: number[]): [number, number][] {\n    const freq = new Map<number, number>();\n    for (const val of data) {\n      freq.set(val, (freq.get(val) || 0) + 1);\n    }\n    const result: [number, number][] = [];\n    for (const [val, count] of freq) {\n      result.push([val, count]);\n    }\n    return result.sort((a, b) => a[0] - b[0]);\n  }\n\n  // Hinges (quartiles)\n  hinges(): MedianResult[] {\n    if (!this.data.hinges) {\n      this.sorted();\n      this.data.hinges = this.getHinges(this.data.sorted!);\n    }\n    return this.data.hinges;\n  }\n\n  private getHinges(\n    arr: number[],\n    hinges: number = 2,\n    result: MedianResult[] = []\n  ): MedianResult[] {\n    const copy = [...arr];\n    const total = copy.length;\n\n    let hingeCount = hinges;\n    if (hingeCount % 2 !== 0) {\n      hingeCount++;\n    }\n\n    if (total <= hingeCount || hingeCount <= 0) {\n      return result;\n    }\n\n    const per = Math.floor(total / hingeCount);\n    const howMany = Math.floor(total / per) - 1;\n\n    for (let step = 0; step <= howMany; step++) {\n      const fragment = copy.slice(step * per, step * per + per);\n      result.push({\n        datum: this.getMedian(fragment),\n        depth: this.getMedianDepth(fragment, step * per),\n      });\n    }\n\n    return result;\n  }\n\n  // IQR (Interquartile Range)\n  iqr(): number {\n    if (this.data.iqr === undefined) {\n      this.hinges();\n      this.data.iqr = this.getIQR(this.data.hinges!);\n    }\n    return this.data.iqr;\n  }\n\n  private getIQR(hinges: MedianResult[]): number {\n    const first = hinges[0]?.datum;\n    const second = hinges[1]?.datum;\n    if (first === undefined || second === undefined) {\n      return NaN;\n    }\n    return Math.abs(first - second);\n  }\n\n  // Fences\n  fences(): number[] {\n    if (!this.data.fences) {\n      this.median();\n      this.iqr();\n      this.data.fences = this.getFences();\n    }\n    return this.data.fences;\n  }\n\n  private getFences(multiple: number = DEFAULT_OUTLIER_MULTIPLE): number[] {\n    const base = this.data.median;\n    const iqr = this.data.iqr;\n    if (base === undefined || iqr === undefined || isNaN(iqr)) {\n      return [];\n    }\n    const extra = iqr * multiple;\n    return [base - extra, base + extra];\n  }\n\n  // Outer fences\n  outer(): number[] {\n    if (!this.data.outer) {\n      this.median();\n      this.iqr();\n      this.data.outer = this.getOuter();\n    }\n    return this.data.outer;\n  }\n\n  private getOuter(multiple: number = DEFAULT_OUTLIER_MULTIPLE): number[] {\n    const base = this.data.median;\n    const iqr = this.data.iqr;\n    if (base === undefined || iqr === undefined || isNaN(iqr)) {\n      return [];\n    }\n    const extra = 2 * iqr * multiple;\n    return [base - extra, base + extra];\n  }\n\n  // Outside values\n  outside(): number[] {\n    if (!this.data.outside) {\n      this.outer();\n      this.data.outside = this.getOutside();\n    }\n    return this.data.outside;\n  }\n\n  private getOutside(): number[] {\n    const results: number[] = [];\n    const sorted = this.data.sorted!;\n    const outer = this.data.outer;\n    if (!outer || outer.length === 0) return [];\n    const min = Math.min(...outer);\n    const max = Math.max(...outer);\n    for (const num of sorted) {\n      if (num > max || num < min) {\n        results.push(num);\n      }\n    }\n    return results;\n  }\n\n  // Inside values\n  inside(): number[] {\n    if (!this.data.inside) {\n      this.fences();\n      this.data.inside = this.getInside();\n    }\n    return this.data.inside;\n  }\n\n  private getInside(): number[] {\n    const results: number[] = [];\n    const sorted = this.data.sorted!;\n    const fences = this.data.fences;\n    if (!fences || fences.length === 0) return [];\n    const min = Math.min(...fences);\n    const max = Math.max(...fences);\n    for (const num of sorted) {\n      if (num < max && num > min) {\n        results.push(num);\n      }\n    }\n    return results;\n  }\n\n  // Outliers\n  outliers(): number[] {\n    if (!this.data.outliers) {\n      this.fences();\n      this.data.outliers = this.getOutliers();\n    }\n    return this.data.outliers;\n  }\n\n  private getOutliers(): number[] {\n    const results: number[] = [];\n    const sorted = this.data.sorted!;\n    const fences = this.data.fences!;\n    if (fences.length === 0) return [];\n    const min = Math.min(...fences);\n    const max = Math.max(...fences);\n    for (const num of sorted) {\n      if (num > max || num < min) {\n        results.push(num);\n      }\n    }\n    return results;\n  }\n\n  // Ranked\n  ranked(): RankedResult {\n    if (!this.data.ranked) {\n      this.sorted();\n      this.data.ranked = this.getRanked(this.data.sorted!);\n    }\n    return this.data.ranked;\n  }\n\n  private getRanked(arr: number[], ties: boolean = true): RankedResult {\n    const up: Record<number, RankInfo> = {};\n    const down: Record<number, RankInfo> = {};\n    const total = arr.length;\n    const ranked: (number | number[])[] = [];\n\n    let tiedRank = NaN;\n    let tiedNumbers: number[] = [];\n\n    const reset = () => {\n      tiedRank = NaN;\n      tiedNumbers = [];\n    };\n\n    for (let i = 0; i < arr.length; i++) {\n      const num = arr[i];\n\n      if (!ties) {\n        up[num] = { rank: i + 1, peers: 0 };\n        down[num] = { rank: total - i, peers: 0 };\n      } else {\n        const incr = i + 1;\n        const decr = i - 1;\n\n        if (num === arr[decr]) {\n          if (!isNaN(tiedRank) && tiedNumbers.length === 0) {\n            tiedNumbers.push(num);\n            ranked.push(tiedNumbers);\n            reset();\n          } else {\n            tiedNumbers.push(num);\n            tiedRank = decr;\n          }\n          if (num !== arr[incr]) {\n            ranked.push(tiedNumbers);\n            reset();\n          }\n        } else {\n          if (num !== arr[incr]) {\n            if (tiedNumbers.length > 0) {\n              ranked.push(tiedNumbers);\n              reset();\n            } else {\n              ranked.push(num);\n            }\n          } else {\n            tiedNumbers.push(num);\n          }\n        }\n      }\n    }\n\n    let offset = 0;\n    for (let i = 0; i < ranked.length; i++) {\n      const item = ranked[i];\n      if (typeof item === 'number') {\n        down[item] = { rank: i + 1 + offset, peers: 0 };\n        up[item] = { rank: total - i - offset, peers: 0 };\n      } else if (Array.isArray(item)) {\n        offset += item.length;\n        const usable = item[0];\n        down[usable] = { rank: i + 1 + offset, peers: item.length };\n        up[usable] = { rank: total - i - offset, peers: item.length };\n      } else {\n        offset += 1;\n      }\n    }\n\n    return {\n      up,\n      down,\n      groups: {\n        down: [...ranked],\n        up: [...ranked].reverse(),\n      },\n    };\n  }\n\n  // Adjacent\n  adjacent(): number[] {\n    if (!this.data.adjacent) {\n      this.fences();\n      this.data.adjacent = this.getAdjacent(this.data.sorted!, this.data.fences!);\n    }\n    return this.data.adjacent;\n  }\n\n  private getAdjacent(arr: number[], fences: number[]): number[] {\n    if (fences.length === 0) return [];\n\n    const low = fences[0];\n    const lows: number[] = [];\n    const high = fences[1];\n    const highs: number[] = [];\n\n    for (const val of arr) {\n      if (val > low) lows.push(val);\n      if (val < high) highs.push(val);\n    }\n\n    lows.sort((a, b) => a - b);\n    highs.sort((a, b) => a - b);\n\n    return [lows[0], highs[highs.length - 1]];\n  }\n\n  // Binned\n  binned(bins: number = NaN): BinnedResult {\n    if (!this.data.binned) {\n      this.sorted();\n      this.extremes();\n      this.data.binned = this.getBinned(this.data.sorted!, bins);\n    }\n    return this.data.binned;\n  }\n\n  private getBinned(\n    arr: number[],\n    bins: number = 10,\n    width: number = NaN,\n    includeZero: boolean = true\n  ): BinnedResult {\n    const binned: Record<number, { from: number; to: number; data: number[] }> = {};\n    const total = arr.length;\n    const zeroOffset = includeZero ? 0 : 1;\n\n    if (total === 0) {\n      return { bins: 0, width: NaN, binned: {} };\n    }\n\n    const extremes = this.data.extremes!;\n    let calculatedWidth = width;\n\n    if (extremes && isNaN(calculatedWidth) && extremes.length === 2) {\n      calculatedWidth = (extremes[1] - extremes[0]) / (Math.log(arr.length) / Math.LN2);\n      calculatedWidth = Math.floor(calculatedWidth);\n\n      let areIntegers = true;\n      for (const item of arr) {\n        if (item % 1 !== 0) {\n          areIntegers = false;\n          break;\n        }\n      }\n      if (areIntegers) {\n        calculatedWidth = Math.floor(calculatedWidth);\n      }\n    }\n\n    let binCount = Math.floor(extremes[1] / calculatedWidth) + 1;\n    if (!binCount || binCount < 1) {\n      binCount = 1;\n    }\n\n    for (const val of arr) {\n      const bin = Math.floor((val - zeroOffset) / calculatedWidth);\n      if (!binned[bin]) {\n        binned[bin] = {\n          from: bin * calculatedWidth + zeroOffset,\n          to: (bin + 1) * calculatedWidth + zeroOffset - 1,\n          data: [],\n        };\n      }\n      binned[bin].data.push(val);\n    }\n\n    return {\n      bins: binCount,\n      width: calculatedWidth,\n      binned,\n    };\n  }\n\n  // Transforms\n  logs(): number[] {\n    if (!this.data.logs) {\n      this.data.logs = this.getLogs(this.data.original);\n    }\n    return this.data.logs;\n  }\n\n  private getLogs(arr: number[]): number[] {\n    return arr.map((val) => Math.log(val));\n  }\n\n  roots(): number[] {\n    if (!this.data.roots) {\n      this.data.roots = this.getRoots(this.data.original);\n    }\n    return this.data.roots;\n  }\n\n  private getRoots(arr: number[]): number[] {\n    return arr.map((val) => Math.sqrt(val));\n  }\n\n  inverse(): number[] {\n    if (!this.data.inverse) {\n      this.data.inverse = this.getInverse(this.data.original);\n    }\n    return this.data.inverse;\n  }\n\n  private getInverse(arr: number[]): number[] {\n    return arr.map((val) => 1 / val);\n  }\n\n  // Smoothing\n  hanning(): number[] {\n    if (!this.data.hanning) {\n      this.data.hanning = this.getSkipMeans(this.data.original);\n    }\n    return this.data.hanning;\n  }\n\n  private getSkipMeans(arr: number[]): number[] {\n    const results: number[] = [];\n    for (let i = 0; i < arr.length; i++) {\n      if (i !== 0 && i !== arr.length - 1) {\n        results.push((arr[i] + arr[i + 1]) / 2);\n      }\n    }\n    results.unshift(arr[0]);\n    results.push(arr[arr.length - 1]);\n    return results;\n  }\n\n  smooth(): number[] {\n    if (!this.data.smooth) {\n      this.sorted();\n      this.data.smooth = this.getSmooth(this.data.original);\n    }\n    this.data.rough = this.getRough(this.data.original, this.data.smooth);\n    return this.data.smooth;\n  }\n\n  private getRough(original: number[], smoothed: number[]): number[] {\n    const residuals: number[] = [];\n    for (let x = 0; x < original.length; x++) {\n      residuals.push(original[x] - smoothed[x]);\n    }\n    return residuals;\n  }\n\n  private getSmooth(arr: number[], passes: number = 3): number[] {\n    let smoothed = [...arr];\n    smoothed = this.smoothMedian(smoothed, passes);\n    smoothed = this.smoothExtremes(smoothed, -1);\n    smoothed = this.smoothSplit(smoothed, 2);\n    smoothed = this.smoothMedian(smoothed, passes);\n    smoothed = this.smoothExtremes(smoothed, -1);\n    smoothed = this.smoothMedian(smoothed, passes);\n    return smoothed;\n  }\n\n  private smoothExtremes(\n    arr: number[],\n    passes: number = 1,\n    current: number = 0,\n    end: 'both' | 'head' | 'tail' = 'both'\n  ): number[] {\n    const len = arr.length;\n    if (len <= 2) return [...arr];\n\n    const result = [...arr];\n\n    for (let pass = current; pass < passes || passes === -1; pass++) {\n      let changed = false;\n\n      if (end === 'both' || end === 'head') {\n        const first = result[0];\n        const second = result[1];\n        const third = result[2];\n        const tmp = second - 2 * (third - second);\n        // Median of three: sort and pick middle\n        const median =\n          first <= second\n            ? second <= tmp\n              ? second\n              : first <= tmp\n                ? tmp\n                : first\n            : first <= tmp\n              ? first\n              : second <= tmp\n                ? tmp\n                : second;\n        if (result[0] !== median) {\n          result[0] = median;\n          changed = true;\n        }\n      }\n\n      if (end === 'both' || end === 'tail') {\n        const antepenultimate = result[len - 3];\n        const penultimate = result[len - 2];\n        const last = result[len - 1];\n        const tmp = penultimate - 2 * (antepenultimate - penultimate);\n        const median =\n          last <= penultimate\n            ? penultimate <= tmp\n              ? penultimate\n              : last <= tmp\n                ? tmp\n                : last\n            : last <= tmp\n              ? last\n              : penultimate <= tmp\n                ? tmp\n                : penultimate;\n        if (result[len - 1] !== median) {\n          result[len - 1] = median;\n          changed = true;\n        }\n      }\n\n      if (passes === -1 && !changed) {\n        break;\n      }\n    }\n    return result;\n  }\n\n  private smoothSplit(\n    arr: number[],\n    passes: number = DEFAULT_SPLIT_PASSES,\n    current: number = 0\n  ): number[] {\n    let result = [...arr];\n    const len = arr.length;\n\n    for (let pass = current; pass < passes || passes === -1; pass++) {\n      let changed = false;\n\n      for (let i = 2; i < len - 1; i++) {\n        const num = result[i];\n        const t1 = result[i - 1];\n        const t2 = result[i - 2];\n        const f1 = result[i + 1];\n\n        if (num === t1 && ((t1 > t2 && num > f1) || (t1 < t2 && num < f1))) {\n          // Apply smoothExtremes at split point in-place\n          const left = this.smoothExtremes(result.slice(0, i));\n          const right = this.smoothExtremes(result.slice(i));\n          result = left.concat(right);\n          changed = true;\n        }\n      }\n\n      if (passes === -1 && !changed) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  private smoothMedian(arr: number[], passes: number = 1, current: number = 0): number[] {\n    let result = arr;\n    const len = arr.length;\n    if (len <= 2) return [...arr];\n\n    for (let pass = current; pass < passes || passes === -1; pass++) {\n      const next = new Array<number>(len);\n      next[0] = result[0];\n      next[len - 1] = result[len - 1];\n\n      let changed = false;\n      for (let i = 1; i < len - 1; i++) {\n        const val = result[i];\n        const smoothed = Math.min(Math.max(result[i - 1], val), result[i + 1]);\n        next[i] = smoothed;\n        if (smoothed !== val) changed = true;\n      }\n\n      if (passes === -1 && !changed) {\n        return result;\n      }\n      result = next;\n    }\n    return result;\n  }\n\n  private jitter(\n    arr: number[],\n    passes: number = 1,\n    floor: number = NaN,\n    multiplier: number = DEFAULT_JITTER_MULTIPLIER,\n    weight: number = NaN,\n    current: number = 0\n  ): number[] {\n    const nextCurrent = current + 1;\n    const copy = [...arr];\n\n    if (nextCurrent <= passes) {\n      const jittered: number[] = [];\n      for (const num of copy) {\n        let w = weight;\n        if (!w && !isNaN(w)) {\n          w = (1 + Math.floor(num / 10)) * (Math.random() > 0.5 ? 1 : -1);\n        }\n        let value = num + Math.floor(Math.random() * multiplier * w);\n        if (!isNaN(floor) && value < floor) {\n          value = floor;\n        }\n        jittered.push(value);\n      }\n      return this.jitter(jittered, passes, floor, multiplier, weight, nextCurrent);\n    }\n    return copy;\n  }\n\n  // Trimean (Tukey's trimean: (Q1 + 2*median + Q3) / 4)\n  trimean(): number {\n    const med = this.median();\n    const h = this.hinges();\n    if (h.length < 2) return med.datum;\n    return (h[0].datum + 2 * med.datum + h[1].datum) / 4;\n  }\n\n  // Letter values (depth-based summaries beyond hinges)\n  letterValues(): Array<{ letter: string; depth: number; lower: number; upper: number; mid: number; spread: number }> {\n    this.sorted();\n    const n = this.data.sorted!.length;\n    if (n < 2) return [];\n\n    const letters = ['M', 'F', 'E', 'D', 'C', 'B', 'A', 'Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S'];\n    const results: Array<{ letter: string; depth: number; lower: number; upper: number; mid: number; spread: number }> = [];\n\n    // M = median\n    const medDepth = (n + 1) / 2;\n    const medValue = this.median().datum;\n    results.push({\n      letter: 'M',\n      depth: medDepth,\n      lower: medValue,\n      upper: medValue,\n      mid: medValue,\n      spread: 0,\n    });\n\n    // Subsequent letter values\n    let depth = medDepth;\n    let letterIdx = 1;\n\n    while (depth > 1 && letterIdx < letters.length) {\n      depth = Math.floor((Math.floor(depth) + 1) / 2);\n      if (depth < 1) break;\n\n      const lowerIdx = Math.ceil(depth) - 1;\n      const upperIdx = n - Math.ceil(depth);\n\n      if (lowerIdx < 0 || upperIdx >= n || lowerIdx >= upperIdx) break;\n\n      const lower = this.data.sorted![lowerIdx];\n      const upper = this.data.sorted![upperIdx];\n      const mid = (lower + upper) / 2;\n      const spread = upper - lower;\n\n      results.push({\n        letter: letters[letterIdx],\n        depth,\n        lower,\n        upper,\n        mid,\n        spread,\n      });\n\n      letterIdx++;\n    }\n\n    return results;\n  }\n\n  // Rough (residuals: original - smooth)\n  rough(): number[] {\n    if (!this.data.rough) {\n      this.smooth();\n    }\n    return this.data.rough || [];\n  }\n\n  // Stem-and-leaf display (text-based visualization)\n  stemLeaf(leafDigits: number = 1): { stems: string[]; leaves: Record<string, string[]>; display: string[] } {\n    this.sorted();\n    const data = this.data.sorted!;\n    if (!data.length) return { stems: [], leaves: {}, display: [] };\n\n    const scale = Math.pow(10, leafDigits);\n    const stems = new Map<number, number[]>();\n\n    for (const val of data) {\n      const stem = Math.floor(val / scale);\n      const leaf = Math.abs(Math.round(val % scale));\n      if (!stems.has(stem)) {\n        stems.set(stem, []);\n      }\n      stems.get(stem)!.push(leaf);\n    }\n\n    const sortedStems = Array.from(stems.keys()).sort((a, b) => a - b);\n    const stemStrings: string[] = [];\n    const leavesRecord: Record<string, string[]> = {};\n    const display: string[] = [];\n\n    for (const stem of sortedStems) {\n      const stemStr = String(stem);\n      stemStrings.push(stemStr);\n      const leaves = stems.get(stem)!.sort((a, b) => a - b).map(String);\n      leavesRecord[stemStr] = leaves;\n      display.push(`${stemStr.padStart(4)} | ${leaves.join(' ')}`);\n    }\n\n    return { stems: stemStrings, leaves: leavesRecord, display };\n  }\n\n  // Mid-summaries (averages of symmetric quantile pairs)\n  midSummaries(): Array<{ depth: number; mid: number; spread: number }> {\n    const lv = this.letterValues();\n    return lv.map(({ depth, mid, spread }) => ({ depth, mid, spread }));\n  }\n\n  // Describe - full summary\n  describe(): SeriesDescription {\n    this.data.description = {\n      original: this.data.original,\n      summary: {\n        median: this.median(),\n        mean: this.mean(),\n        mode: this.mode(),\n        hinges: this.hinges(),\n        adjacent: this.adjacent(),\n        outliers: this.outliers(),\n        outer: this.outer(),\n        outside: this.outside(),\n        inside: this.inside(),\n        extremes: this.extremes(),\n        iqr: this.iqr(),\n        fences: this.fences(),\n      },\n      smooths: {\n        smooth: this.smooth(),\n        hanning: this.hanning(),\n      },\n      transforms: {\n        logs: this.logs(),\n        roots: this.roots(),\n        inverse: this.inverse(),\n      },\n      counts: this.counts(),\n      sorted: this.sorted(),\n      ranked: this.ranked(),\n      binned: this.binned(),\n    };\n    return this.data.description;\n  }\n}\n\n/**\n * Points class for n-dimensional data exploration\n */\nexport class Points {\n  private data: {\n    original: number[][];\n    centroid?: number[];\n    variances?: number[];\n    stddevs?: number[];\n    covarianceMatrix?: number[][];\n    correlationMatrix?: number[][];\n    mahalanobisDistances?: number[];\n    description?: PointsDescription;\n  };\n  private dimension: number;\n  private count: number;\n\n  constructor(options: PointsOptions | number = {}) {\n    if (typeof options === 'number') {\n      this.count = options;\n      this.dimension = DEFAULT_MAX_RANDOM_DIMENSIONALITY;\n      this.data = {\n        original: randomPoints(this.count, this.dimension),\n      };\n    } else {\n      this.dimension = options.dimensionality ?? 2;\n      this.count = options.count ?? 100;\n      this.data = {\n        original: options.data ?? randomPoints(this.count, this.dimension),\n      };\n      if (options.data && options.data.length > 0) {\n        this.dimension = options.data[0].length;\n        this.count = options.data.length;\n      }\n    }\n  }\n\n  // Mean point across all dimensions\n  centroid(): number[] {\n    if (!this.data.centroid) {\n      const pts = this.data.original;\n      const dim = this.dimension;\n      const n = pts.length;\n      if (n === 0) {\n        this.data.centroid = [];\n        return this.data.centroid;\n      }\n      const sums = new Array<number>(dim).fill(0);\n      for (const pt of pts) {\n        for (let d = 0; d < dim; d += 1) {\n          sums[d] += pt[d] ?? 0;\n        }\n      }\n      this.data.centroid = sums.map((s) => s / n);\n    }\n    return this.data.centroid;\n  }\n\n  // Per-dimension sample variance\n  variances(): number[] {\n    if (!this.data.variances) {\n      const pts = this.data.original;\n      const dim = this.dimension;\n      const n = pts.length;\n      if (n < 2) {\n        this.data.variances = new Array<number>(dim).fill(NaN);\n        return this.data.variances;\n      }\n      const means = this.centroid();\n      const sums = new Array<number>(dim).fill(0);\n      for (const pt of pts) {\n        for (let d = 0; d < dim; d += 1) {\n          const delta = (pt[d] ?? 0) - means[d];\n          sums[d] += delta * delta;\n        }\n      }\n      this.data.variances = sums.map((s) => s / (n - 1));\n    }\n    return this.data.variances;\n  }\n\n  // Per-dimension standard deviation\n  standardDeviations(): number[] {\n    if (!this.data.stddevs) {\n      this.data.stddevs = this.variances().map((v) => Math.sqrt(v));\n    }\n    return this.data.stddevs;\n  }\n\n  // Full covariance matrix\n  covarianceMatrix(): number[][] {\n    if (!this.data.covarianceMatrix) {\n      const pts = this.data.original;\n      const dim = this.dimension;\n      const n = pts.length;\n      const means = this.centroid();\n\n      const cov: number[][] = Array.from({ length: dim }, () =>\n        new Array<number>(dim).fill(0),\n      );\n\n      if (n < 2) {\n        this.data.covarianceMatrix = cov;\n        return this.data.covarianceMatrix;\n      }\n\n      for (const pt of pts) {\n        for (let i = 0; i < dim; i += 1) {\n          const di = (pt[i] ?? 0) - means[i];\n          for (let j = i; j < dim; j += 1) {\n            const dj = (pt[j] ?? 0) - means[j];\n            cov[i][j] += di * dj;\n          }\n        }\n      }\n\n      for (let i = 0; i < dim; i += 1) {\n        for (let j = i; j < dim; j += 1) {\n          cov[i][j] /= n - 1;\n          cov[j][i] = cov[i][j];\n        }\n      }\n\n      this.data.covarianceMatrix = cov;\n    }\n    return this.data.covarianceMatrix;\n  }\n\n  // Pearson correlation matrix\n  correlationMatrix(): number[][] {\n    if (!this.data.correlationMatrix) {\n      const cov = this.covarianceMatrix();\n      const dim = this.dimension;\n      const stddevs = this.standardDeviations();\n\n      const corr: number[][] = Array.from({ length: dim }, () =>\n        new Array<number>(dim).fill(0),\n      );\n\n      for (let i = 0; i < dim; i += 1) {\n        for (let j = 0; j < dim; j += 1) {\n          const denom = stddevs[i] * stddevs[j];\n          corr[i][j] = denom === 0 ? (i === j ? 1 : 0) : cov[i][j] / denom;\n        }\n      }\n\n      this.data.correlationMatrix = corr;\n    }\n    return this.data.correlationMatrix;\n  }\n\n  // Mahalanobis distance of a single point from the distribution\n  mahalanobis(point: number[]): number {\n    const means = this.centroid();\n    const vars = this.variances();\n    const dim = Math.min(point.length, means.length, vars.length);\n    if (dim === 0) return 0;\n\n    let sum = 0;\n    for (let i = 0; i < dim; i += 1) {\n      const delta = (point[i] ?? 0) - means[i];\n      const v = Math.max(vars[i], 1e-8);\n      sum += (delta * delta) / v;\n    }\n    return Math.sqrt(sum);\n  }\n\n  // Mahalanobis distance for each stored point\n  mahalanobisAll(): number[] {\n    if (!this.data.mahalanobisDistances) {\n      const means = this.centroid();\n      const vars = this.variances();\n      this.data.mahalanobisDistances = this.data.original.map((pt) => {\n        const dim = Math.min(pt.length, means.length, vars.length);\n        let sum = 0;\n        for (let i = 0; i < dim; i += 1) {\n          const delta = (pt[i] ?? 0) - means[i];\n          const v = Math.max(vars[i], 1e-8);\n          sum += (delta * delta) / v;\n        }\n        return Math.sqrt(sum);\n      });\n    }\n    return this.data.mahalanobisDistances;\n  }\n\n  // Outlier detection: points with Mahalanobis distance > threshold\n  outliersByMahalanobis(threshold: number = 3.0): number[][] {\n    const distances = this.mahalanobisAll();\n    const results: number[][] = [];\n    for (let i = 0; i < distances.length; i += 1) {\n      if (distances[i] > threshold) {\n        results.push(this.data.original[i]);\n      }\n    }\n    return results;\n  }\n\n  // L2-normalize all points (returns new Points)\n  normalizeL2(): Points {\n    const normalized = this.data.original.map((pt) => {\n      let sumSq = 0;\n      for (const v of pt) {\n        sumSq += v * v;\n      }\n      const mag = Math.sqrt(sumSq);\n      if (mag === 0) return pt.map(() => 0);\n      return pt.map((v) => v / mag);\n    });\n    return new Points({ data: normalized });\n  }\n\n  // Z-score normalize per dimension (returns new Points)\n  normalizeZscore(): Points {\n    const means = this.centroid();\n    const stddevs = this.standardDeviations();\n    const dim = this.dimension;\n\n    const normalized = this.data.original.map((pt) => {\n      const result = new Array<number>(dim);\n      for (let d = 0; d < dim; d += 1) {\n        const s = stddevs[d];\n        result[d] = s === 0 || isNaN(s) ? 0 : ((pt[d] ?? 0) - means[d]) / s;\n      }\n      return result;\n    });\n    return new Points({ data: normalized });\n  }\n\n  // Full description\n  describe(): PointsDescription {\n    const distances = this.mahalanobisAll();\n    const outlierCount = distances.filter((d) => d > 3.0).length;\n\n    // Build per-dimension Series summaries\n    const dim = this.dimension;\n    const dimensionSummaries: SeriesDescription[] = [];\n    for (let d = 0; d < dim; d += 1) {\n      const values = this.data.original.map((pt) => pt[d] ?? 0);\n      const series = new Series({ data: values });\n      dimensionSummaries.push(series.describe());\n    }\n\n    this.data.description = {\n      original: this.data.original,\n      centroid: this.centroid(),\n      variances: this.variances(),\n      correlationMatrix: this.correlationMatrix(),\n      mahalanobisDistances: distances,\n      outlierCount,\n      dimensionSummaries,\n    };\n    return this.data.description;\n  }\n}\n\n/**\n * Main Twokeys class - factory for Series and Points\n */\nexport class Twokeys {\n  public smoothed: boolean = false;\n\n  // Constants\n  static readonly DEFAULT_MAX_RANDOM_INTEGER = DEFAULT_MAX_RANDOM_INTEGER;\n  static readonly DEFAULT_MIN_RANDOM_INTEGER = DEFAULT_MIN_RANDOM_INTEGER;\n  static readonly DEFAULT_RANDOM_SERIES_COUNT = DEFAULT_RANDOM_SERIES_COUNT;\n  static readonly DEFAULT_OUTLIER_MULTIPLE = DEFAULT_OUTLIER_MULTIPLE;\n  static readonly DEFAULT_JITTER_MULTIPLIER = DEFAULT_JITTER_MULTIPLIER;\n  static readonly DEFAULT_SPLIT_PASSES = DEFAULT_SPLIT_PASSES;\n  static readonly DEFAULT_MAX_RANDOM_DIMENSIONALITY = DEFAULT_MAX_RANDOM_DIMENSIONALITY;\n\n  // Static factory methods\n  static Series = Series;\n  static Points = Points;\n\n  // Utility methods\n  static randomInteger = randomInteger;\n  static randomSeries = randomSeries;\n  static randomPoint = randomPoint;\n  static randomPoints = randomPoints;\n}\n\nexport * from './distance';\nexport * from './graph';\nexport * from './graph-eda';\nexport * from './gds';\n\n// Default export\nexport default Twokeys;\n"]}