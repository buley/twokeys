{"version":3,"sources":["../src/distance.ts","../src/graph.ts","../src/graph-eda.ts","../src/index.ts"],"names":["cosineSimilarity","a","b","len","dot","magA","magB","i","ai","bi","denom","squaredEuclideanDistance","sum","delta","euclideanDistance","manhattanDistance","mahalanobisDistance","point","means","variances","epsilon","variance","normalizeL2","vector","sumSq","v","mag","cosineSimilaritySparse","small","large","key","val","other","jaccardSimilarity","intersection","value","union","overlapCoefficient","minSize","GraphAlgorithmError","code","message","MinPriorityQueue","priority","top","last","index","cursor","parent","current","parentItem","left","right","smallest","leftItem","rightItem","currentSmallest","cursorItem","smallestItem","defaultTieBreaker","canonicalUndirectedEdge","undirectedEdgeKey","edge","asNodeId","input","DisjointSet","nodes","nodeId","root","leftRoot","rightRoot","leftRank","rightRank","dedupeNodeList","edges","seen","ordered","node","normalizeWeight","weight","initializeNeighborMap","nodeIds","map","maybeUpdateEdge","from","to","outgoing","existing","buildNormalizedEdgeMap","directed","neighbors","toNeighborList","edgeMap","neighborsByNode","targetId","createIncomingByNode","incomingByNode","fromId","neighbor","incoming","toEdgeList","hasNegativeWeights","adjacency","reconstructPath","source","target","previousByNode","reversed","previous","sumNeighborWeights","collectUniqueUndirectedEdges","byKey","canonical","computeModularity","communityByNode","uniqueEdges","totalEdgeWeight","degreeByNode","totalWeightByCommunity","internalWeightByCommunity","community","degree","fromCommunity","toCommunity","modularity","totalWeight","internal","buildCommunityResult","labelsByNode","iterations","converged","algorithm","communitiesRaw","label","members","communities","buildNeighborIdSetMap","output","set","computeSimilarityScore","leftId","rightId","neighborSets","metric","leftSize","rightSize","iterate","lookup","common","adamicAdar","resourceAllocation","overlapDenominator","routeDistanceForPath","path","total","toId","pathKey","hasSamePrefix","prefix","chooseShortestPathAlgorithm","requested","hasNegative","runDijkstra","distanceByNode","settled","queue","item","currentDistance","nextDistance","existingDistance","runBellmanFord","totalNodes","iteration","changed","fromDistance","candidate","negativeCycleNodes","toDistance","explored","distance","runShortestPathEngine","requestedAlgorithm","createRandom","seed","state","normalizePoints","points","mode","dimensionality","mins","maxs","axis","ranges","max","min","range","stdDevs","stdDev","initializeCentroids","k","random","useKMeansPlusPlus","centroids","selected","first","distanceWeights","pointIndex","bestDistance","centroid","threshold","running","pickedIndex","runSingleKMeans","maxIterations","tolerance","assignments","inertia","bestCluster","clusterIndex","nextCentroids","counts","count","farthestIndex","farthestDistance","assigned","maxShift","next","computeSilhouette","clusters","cluster","clusterMembers","counted","ownCluster","ownMembers","neighborIndex","distanceToCluster","denominator","routeDistanceFromMatrix","route","distanceMatrix","optimizeRouteTwoOpt","passes","best","pass","improved","start","end","head","middle","tail","candidateDistance","createDeterministicStartList","options","starts","used","pool","swapIndex","desiredCount","buildGreedyRoute","returnToStart","unvisited","nextNode","distances","computeMstLowerBound","visited","buildGraphAdjacency","stronglyConnectedComponents","components","indexByNode","lowLinkByNode","stack","inStack","strongConnect","currentLow","neighborLow","component","member","firstLeft","firstRight","componentByNode","componentIndex","weaklyConnectedComponents","topologicalSort","tieBreaker","priorityByNode","priorityAccessor","compareNodes","priorityDelta","indegree","targets","order","orderSet","leftovers","directedScc","selfLoopNodes","cycleNodes","degreeCentrality","outDegree","inDegree","closenessCentrality","totalOthers","engine","negativeCycle","reachableCount","distanceSum","harmonicSum","score","normalized","betweennessCentrality","predecessors","sigma","distanceToNode","sigmaToNode","knownDistance","dependency","sigmaNode","dependencyNode","predecessor","sigmaPredecessor","contribution","normalization","records","raw","pageRank","dampingFactor","initialScore","outgoingWeightSum","scores","teleportMass","sinkMass","sinkContribution","outgoingWeight","transfer","scoreSum","scoreDelta","maxScore","byNode","minimumSpanningTree","candidateByKey","candidates","weightDelta","fromDelta","disjointSet","roots","componentCount","articulationPointsAndBridges","discoveredAt","lowLink","parentByNode","articulationPoints","bridgeByKey","discoveryCounter","visit","childCount","discoveredNeighbor","lowNode","lowNeighbor","discoveredNode","bridges","toDelta","analyzeGraph","scc","weak","articulation","dedupedNodes","orderedNodeIds","betweennessByNode","pageRankByNode","error","defaultScore","shortestPath","reachable","labelPropagationCommunities","nodeOrder","labelByNode","scoreByLabel","neighborLabel","currentLabel","bestLabel","bestScore","candidateLabel","louvainCommunities","maxPasses","totalDegree","communityWeight","nodeDegree","edgeWeightByCommunity","bestGain","edgeWeight","candidateWeight","gain","nodeSimilarity","minScore","orderedNodes","pairs","leftIndex","rightIndex","leftDelta","pair","kNearestNeighbors","otherId","predictLinks","limit","allowExistingEdges","sourceFilterSet","targetFilterSet","existingEdgeKeys","predictions","prediction","linkPrediction","aStarShortestPath","heuristic","_nodeId","_targetId","gScore","closedSet","startHeuristic","known","estimate","allPairsShortestPaths","chosenAlgorithm","distanceBySource","previousBySource","prev","yenKShortestPaths","shortestPathAlgorithm","accepted","pathIndex","spurIndex","spurNode","rootPath","rootNodeExclusion","removedEdgeKeys","pathRecord","filteredEdges","spurPath","totalPath","totalDistance","distanceDelta","maximumFlow","sink","originalEdges","residual","addResidualEdge","capacity","originalIndex","fromEdges","toEdges","forwardIndex","reverseIndex","maxFlow","augmentations","flowByOriginal","queueIndex","edgesFromNode","edgeIndex","bottleneck","parentEntry","reverse","reachableFromSource","partitionQueue","partitionCursor","sourcePartition","sinkPartition","cutEdges","flowByEdge","minCostMaxFlow","edgeProjection","originals","cost","targetFlowRaw","targetFlow","flow","sinkDistance","kMeansClustering","clusterCount","nInit","baseSeed","transform","normalizedPoints","bestSeed","attempt","run","indices","silhouette","kMeansAuto","minK","maxK","bestResult","bestK","result","currentSilhouette","bestSilhouette","travelingSalesmanApprox","twoOptPasses","previousMatrix","bestRoute","candidateRoute","unreachableNodes","complete","segments","lowerBound","optimalityGap","hierarchicalClustering","n","linkage","distFn","_","active","dendrogram","distMatrix","j","d","clusterDist","activeCount","bestI","bestJ","bestDist","mergedMembers","newDist","ni","nj","nk","sizeI","sizeJ","clusterIdx","ptIdx","dbscan","minPoints","UNVISITED","NOISE","currentCluster","regionQuery","pointIdx","seedIdx","jNeighbors","noise","resolveNodeId","buildAdjacencyMaps","nodeIdSet","outNeighbors","inNeighbors","edgeSet","id","clusteringCoefficient","neighborArr","triangles","maxTriangles","graphEda","nodeCount","edgeCount","maxEdges","density","degrees","inDegrees","outDegrees","outDeg","inDeg","degreeSeries","Series","inDegreeSeries","outDegreeSeries","cc","ccValues","globalCC","ccSeries","reciprocalCount","reciprocity","sampleSize","totalPathLength","pathCount","diameter","sampleStep","si","dist","qi","currentDist","averagePathLength","assortativity","sourceDegrees","targetDegrees","sumX","sumY","sumXY","sumX2","sumY2","numerator","graphOutliers","method","results","mean","std","zscore","r","DEFAULT_MAX_RANDOM_INTEGER","DEFAULT_MIN_RANDOM_INTEGER","DEFAULT_RANDOM_SERIES_COUNT","DEFAULT_OUTLIER_MULTIPLE","DEFAULT_JITTER_MULTIPLIER","DEFAULT_SPLIT_PASSES","DEFAULT_MAX_RANDOM_DIMENSIONALITY","randomInteger","randomSeries","series","randomPoint","dimension","randomPoints","arr","offset","mid","num","m","alpha","s","z","rawKurt","correction","data","freq","maxCount","modes","hinges","copy","hingeCount","per","howMany","step","fragment","second","multiple","base","iqr","extra","sorted","outer","fences","ties","up","down","ranked","tiedRank","tiedNumbers","reset","incr","decr","usable","low","lows","high","highs","bins","width","includeZero","binned","zeroOffset","extremes","calculatedWidth","areIntegers","binCount","bin","original","smoothed","residuals","x","third","tmp","median","antepenultimate","penultimate","t1","t2","f1","floor","multiplier","nextCurrent","jittered","w","med","h","letters","medDepth","medValue","depth","letterIdx","lowerIdx","upperIdx","lower","upper","spread","leafDigits","scale","stems","stem","leaf","sortedStems","stemStrings","leavesRecord","display","stemStr","leaves","Points","_Points","pts","dim","sums","pt","cov","di","dj","stddevs","corr","vars","outlierCount","dimensionSummaries","values","Twokeys","index_default"],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * Vector Distance & Similarity Functions\r\n *\r\n * Standalone functions for vector math  zero dependencies.\r\n * These are the workhorses that Points, graph algorithms, and consumers all use.\r\n */\r\n\r\n//  Dense vector operations \r\n\r\n/**\r\n * Cosine similarity between two dense vectors.\r\n * Returns a value in [-1, 1] where 1 means identical direction.\r\n */\r\nexport function cosineSimilarity(a: number[], b: number[]): number {\r\n  const len = Math.min(a.length, b.length);\r\n  if (len === 0) return 0;\r\n\r\n  let dot = 0;\r\n  let magA = 0;\r\n  let magB = 0;\r\n\r\n  for (let i = 0; i < len; i += 1) {\r\n    const ai = a[i] ?? 0;\r\n    const bi = b[i] ?? 0;\r\n    dot += ai * bi;\r\n    magA += ai * ai;\r\n    magB += bi * bi;\r\n  }\r\n\r\n  const denom = Math.sqrt(magA) * Math.sqrt(magB);\r\n  if (denom === 0) return 0;\r\n  return dot / denom;\r\n}\r\n\r\n/**\r\n * Squared Euclidean distance between two dense vectors.\r\n * Avoids the sqrt for performance-sensitive comparisons.\r\n */\r\nexport function squaredEuclideanDistance(a: number[], b: number[]): number {\r\n  let sum = 0;\r\n  const len = Math.max(a.length, b.length);\r\n  for (let i = 0; i < len; i += 1) {\r\n    const delta = (a[i] ?? 0) - (b[i] ?? 0);\r\n    sum += delta * delta;\r\n  }\r\n  return sum;\r\n}\r\n\r\n/**\r\n * Euclidean (L2) distance between two dense vectors.\r\n */\r\nexport function euclideanDistance(a: number[], b: number[]): number {\r\n  return Math.sqrt(squaredEuclideanDistance(a, b));\r\n}\r\n\r\n/**\r\n * Manhattan (L1) distance between two dense vectors.\r\n */\r\nexport function manhattanDistance(a: number[], b: number[]): number {\r\n  let sum = 0;\r\n  const len = Math.max(a.length, b.length);\r\n  for (let i = 0; i < len; i += 1) {\r\n    sum += Math.abs((a[i] ?? 0) - (b[i] ?? 0));\r\n  }\r\n  return sum;\r\n}\r\n\r\n/**\r\n * Mahalanobis distance of a point from a distribution described by\r\n * per-dimension means and variances.\r\n *\r\n * This is the diagonal-covariance special case (dimensions are independent),\r\n * which is what most embedding-space consumers need.\r\n *\r\n * d = sqrt(  (x_i - _i) / max(_i, ) )\r\n */\r\nexport function mahalanobisDistance(\r\n  point: number[],\r\n  means: number[],\r\n  variances: number[],\r\n  epsilon: number = 1e-8,\r\n): number {\r\n  const len = Math.min(point.length, means.length, variances.length);\r\n  if (len === 0) return 0;\r\n\r\n  let sum = 0;\r\n  for (let i = 0; i < len; i += 1) {\r\n    const delta = (point[i] ?? 0) - (means[i] ?? 0);\r\n    const variance = Math.max(variances[i] ?? 0, epsilon);\r\n    sum += (delta * delta) / variance;\r\n  }\r\n  return Math.sqrt(sum);\r\n}\r\n\r\n/**\r\n * L2-normalize a dense vector (unit vector in same direction).\r\n * Returns the zero vector if the input has zero magnitude.\r\n */\r\nexport function normalizeL2(vector: number[]): number[] {\r\n  let sumSq = 0;\r\n  for (let i = 0; i < vector.length; i += 1) {\r\n    const v = vector[i] ?? 0;\r\n    sumSq += v * v;\r\n  }\r\n  const mag = Math.sqrt(sumSq);\r\n  if (mag === 0) return vector.map(() => 0);\r\n  return vector.map((v) => (v ?? 0) / mag);\r\n}\r\n\r\n//  Sparse vector operations \r\n\r\n/**\r\n * Cosine similarity between two sparse vectors represented as Map<string, number>.\r\n */\r\nexport function cosineSimilaritySparse(\r\n  a: Map<string, number>,\r\n  b: Map<string, number>,\r\n): number {\r\n  if (a.size === 0 || b.size === 0) return 0;\r\n\r\n  let dot = 0;\r\n  let magA = 0;\r\n  let magB = 0;\r\n\r\n  // Iterate over the smaller map for efficiency\r\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\r\n\r\n  for (const [key, val] of small) {\r\n    const other = large.get(key);\r\n    if (other !== undefined) {\r\n      dot += val * other;\r\n    }\r\n    magA += val * val;\r\n  }\r\n\r\n  for (const val of large.values()) {\r\n    magB += val * val;\r\n  }\r\n\r\n  // If we iterated the smaller as `a`, magA is correct.\r\n  // If we swapped, magA holds the smaller's magnitude and magB holds the larger's.\r\n  // Since cosine similarity is symmetric, the result is the same.\r\n\r\n  const denom = Math.sqrt(magA) * Math.sqrt(magB);\r\n  if (denom === 0) return 0;\r\n  return dot / denom;\r\n}\r\n\r\n//  Set operations \r\n\r\n/**\r\n * Jaccard similarity between two sets: |A  B| / |A  B|.\r\n * Returns 0 for empty sets.\r\n */\r\nexport function jaccardSimilarity<T>(a: Set<T>, b: Set<T>): number {\r\n  if (a.size === 0 || b.size === 0) return 0;\r\n\r\n  let intersection = 0;\r\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\r\n  for (const value of small) {\r\n    if (large.has(value)) {\r\n      intersection += 1;\r\n    }\r\n  }\r\n\r\n  const union = a.size + b.size - intersection;\r\n  if (union <= 0) return 0;\r\n  return intersection / union;\r\n}\r\n\r\n/**\r\n * Overlap coefficient: |A  B| / min(|A|, |B|).\r\n * Returns 0 for empty sets.\r\n */\r\nexport function overlapCoefficient<T>(a: Set<T>, b: Set<T>): number {\r\n  if (a.size === 0 || b.size === 0) return 0;\r\n\r\n  let intersection = 0;\r\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\r\n  for (const value of small) {\r\n    if (large.has(value)) {\r\n      intersection += 1;\r\n    }\r\n  }\r\n\r\n  const minSize = Math.min(a.size, b.size);\r\n  if (minSize <= 0) return 0;\r\n  return intersection / minSize;\r\n}\r\n","import {\r\n  squaredEuclideanDistance as squaredDistance,\r\n  euclideanDistance,\r\n  cosineSimilarity as distanceCosineSimilarity,\r\n  manhattanDistance,\r\n} from './distance';\r\n\r\nexport type GraphNodeInput<NodeId extends string = string> =\r\n  | NodeId\r\n  | { id: NodeId };\r\n\r\nexport interface GraphEdge<NodeId extends string = string> {\r\n  from: NodeId;\r\n  to: NodeId;\r\n  weight?: number;\r\n}\r\n\r\nexport interface GraphBuildOptions {\r\n  directed?: boolean;\r\n}\r\n\r\nexport interface GraphNeighbor<NodeId extends string = string> {\r\n  id: NodeId;\r\n  weight: number;\r\n}\r\n\r\nexport interface GraphAdjacency<NodeId extends string = string> {\r\n  nodes: NodeId[];\r\n  neighborsByNode: Map<NodeId, GraphNeighbor<NodeId>[]>;\r\n  incomingByNode: Map<NodeId, GraphNeighbor<NodeId>[]>;\r\n  edges: Array<Required<GraphEdge<NodeId>>>;\r\n  directed: boolean;\r\n}\r\n\r\nexport type GraphAlgorithmErrorCode =\r\n  | 'NEGATIVE_WEIGHT'\r\n  | 'NEGATIVE_CYCLE'\r\n  | 'INVALID_ARGUMENT';\r\n\r\nexport class GraphAlgorithmError extends Error {\r\n  readonly code: GraphAlgorithmErrorCode;\r\n\r\n  constructor(code: GraphAlgorithmErrorCode, message: string) {\r\n    super(message);\r\n    this.name = 'GraphAlgorithmError';\r\n    this.code = code;\r\n  }\r\n}\r\n\r\nexport interface TopologicalSortOptions<NodeId extends string = string> {\r\n  tieBreaker?: (left: NodeId, right: NodeId) => number;\r\n  priority?: (nodeId: NodeId) => number;\r\n  priorityByNode?: Map<NodeId, number> | Partial<Record<NodeId, number>>;\r\n}\r\n\r\nexport interface TopologicalSortResult<NodeId extends string = string> {\r\n  order: NodeId[];\r\n  cycleNodes: NodeId[];\r\n  isDag: boolean;\r\n}\r\n\r\nexport interface StronglyConnectedComponentsOptions extends GraphBuildOptions {}\r\n\r\nexport interface StronglyConnectedComponentsResult<NodeId extends string = string> {\r\n  components: NodeId[][];\r\n  componentByNode: Map<NodeId, number>;\r\n}\r\n\r\nexport interface WeaklyConnectedComponentsResult<NodeId extends string = string> {\r\n  components: NodeId[][];\r\n  componentByNode: Map<NodeId, number>;\r\n}\r\n\r\nexport interface DegreeCentralityRecord {\r\n  inDegree: number;\r\n  outDegree: number;\r\n  degree: number;\r\n  normalized: number;\r\n}\r\n\r\nexport type ClosenessCentralityMode = 'classic' | 'harmonic';\r\n\r\nexport interface ClosenessCentralityRecord {\r\n  reachableCount: number;\r\n  distanceSum: number;\r\n  score: number;\r\n  normalized: number;\r\n  mode: ClosenessCentralityMode;\r\n  negativeCycle: boolean;\r\n}\r\n\r\nexport interface BetweennessCentralityRecord {\r\n  raw: number;\r\n  normalized: number;\r\n}\r\n\r\nexport interface PageRankOptions extends GraphBuildOptions {\r\n  dampingFactor?: number;\r\n  tolerance?: number;\r\n  maxIterations?: number;\r\n}\r\n\r\nexport interface PageRankRecord {\r\n  score: number;\r\n  normalized: number;\r\n  rank: number;\r\n}\r\n\r\nexport interface PageRankResult<NodeId extends string = string> {\r\n  byNode: Map<NodeId, PageRankRecord>;\r\n  order: NodeId[];\r\n  iterations: number;\r\n  converged: boolean;\r\n  dampingFactor: number;\r\n}\r\n\r\nexport interface MinimumSpanningTreeOptions<NodeId extends string = string> {\r\n  tieBreaker?: (left: NodeId, right: NodeId) => number;\r\n}\r\n\r\nexport interface MinimumSpanningTreeResult<NodeId extends string = string> {\r\n  edges: Array<Required<GraphEdge<NodeId>>>;\r\n  totalWeight: number;\r\n  componentCount: number;\r\n  spanning: boolean;\r\n}\r\n\r\nexport interface ArticulationBridgeResult<NodeId extends string = string> {\r\n  articulationPoints: NodeId[];\r\n  bridges: Array<Required<GraphEdge<NodeId>>>;\r\n}\r\n\r\nexport interface GraphAnalysisResult<NodeId extends string = string> {\r\n  degree: Map<NodeId, DegreeCentralityRecord>;\r\n  closeness: Map<NodeId, ClosenessCentralityRecord>;\r\n  betweenness: Map<NodeId, BetweennessCentralityRecord>;\r\n  pageRank: Map<NodeId, PageRankRecord>;\r\n  stronglyConnectedComponents: NodeId[][];\r\n  weaklyConnectedComponents: NodeId[][];\r\n  articulationPoints: NodeId[];\r\n  bridges: Array<Required<GraphEdge<NodeId>>>;\r\n}\r\n\r\nexport interface GraphAnalysisOptions extends GraphBuildOptions {\r\n  closenessMode?: ClosenessCentralityMode;\r\n  shortestPathAlgorithm?: ShortestPathAlgorithm;\r\n  pageRankOptions?: Omit<PageRankOptions, 'directed'>;\r\n}\r\n\r\nexport type ShortestPathAlgorithm = 'auto' | 'dijkstra' | 'bellman-ford';\r\n\r\nexport interface ShortestPathOptions extends GraphBuildOptions {\r\n  algorithm?: ShortestPathAlgorithm;\r\n  failOnNegativeCycle?: boolean;\r\n}\r\n\r\nexport interface ShortestPathResult<NodeId extends string = string> {\r\n  source: NodeId;\r\n  target: NodeId;\r\n  path: NodeId[];\r\n  distance: number;\r\n  reachable: boolean;\r\n  explored: number;\r\n  algorithm: ShortestPathAlgorithm;\r\n  hasNegativeWeights: boolean;\r\n  negativeCycle: boolean;\r\n}\r\n\r\nexport interface LabelPropagationOptions<NodeId extends string = string>\r\n  extends GraphBuildOptions {\r\n  maxIterations?: number;\r\n  tieBreaker?: (left: NodeId, right: NodeId) => number;\r\n}\r\n\r\nexport interface LouvainOptions<NodeId extends string = string>\r\n  extends GraphBuildOptions {\r\n  maxPasses?: number;\r\n  tolerance?: number;\r\n  tieBreaker?: (left: NodeId, right: NodeId) => number;\r\n}\r\n\r\nexport interface CommunityDetectionResult<NodeId extends string = string> {\r\n  communities: NodeId[][];\r\n  communityByNode: Map<NodeId, number>;\r\n  iterations: number;\r\n  converged: boolean;\r\n  algorithm: 'label-propagation' | 'louvain';\r\n  modularity: number;\r\n}\r\n\r\nexport type SimilarityMetric =\r\n  | 'common-neighbors'\r\n  | 'jaccard'\r\n  | 'cosine'\r\n  | 'overlap'\r\n  | 'adamic-adar'\r\n  | 'resource-allocation'\r\n  | 'preferential-attachment';\r\n\r\nexport interface SimilarityOptions extends GraphBuildOptions {\r\n  metric?: SimilarityMetric;\r\n  minScore?: number;\r\n}\r\n\r\nexport interface NodeSimilarityRecord<NodeId extends string = string> {\r\n  left: NodeId;\r\n  right: NodeId;\r\n  score: number;\r\n  metric: SimilarityMetric;\r\n  rank: number;\r\n}\r\n\r\nexport interface NodeSimilarityResult<NodeId extends string = string> {\r\n  metric: SimilarityMetric;\r\n  pairs: NodeSimilarityRecord<NodeId>[];\r\n}\r\n\r\nexport interface KNearestNeighborsOptions extends GraphBuildOptions {\r\n  metric?: SimilarityMetric;\r\n  k?: number;\r\n  minScore?: number;\r\n}\r\n\r\nexport interface KNearestNeighbor<NodeId extends string = string> {\r\n  nodeId: NodeId;\r\n  score: number;\r\n}\r\n\r\nexport interface KNearestNeighborsResult<NodeId extends string = string> {\r\n  metric: SimilarityMetric;\r\n  k: number;\r\n  neighborsByNode: Map<NodeId, KNearestNeighbor<NodeId>[]>;\r\n}\r\n\r\nexport interface LinkPredictionOptions<NodeId extends string = string>\r\n  extends GraphBuildOptions {\r\n  metric?: SimilarityMetric;\r\n  limit?: number;\r\n  minScore?: number;\r\n  allowExistingEdges?: boolean;\r\n  sourceFilter?: NodeId[];\r\n  targetFilter?: NodeId[];\r\n}\r\n\r\nexport interface LinkPredictionRecord<NodeId extends string = string> {\r\n  from: NodeId;\r\n  to: NodeId;\r\n  score: number;\r\n  metric: SimilarityMetric;\r\n  rank: number;\r\n}\r\n\r\nexport interface LinkPredictionResult<NodeId extends string = string> {\r\n  metric: SimilarityMetric;\r\n  predictions: LinkPredictionRecord<NodeId>[];\r\n}\r\n\r\nexport interface AStarOptions<NodeId extends string = string>\r\n  extends GraphBuildOptions {\r\n  heuristic?: (nodeId: NodeId, targetId: NodeId) => number;\r\n}\r\n\r\nexport interface AStarResult<NodeId extends string = string> {\r\n  source: NodeId;\r\n  target: NodeId;\r\n  path: NodeId[];\r\n  distance: number;\r\n  reachable: boolean;\r\n  explored: number;\r\n  estimatedDistance: number;\r\n}\r\n\r\nexport interface PathRecord<NodeId extends string = string> {\r\n  path: NodeId[];\r\n  distance: number;\r\n}\r\n\r\nexport interface YenKShortestPathsOptions extends GraphBuildOptions {\r\n  k?: number;\r\n  shortestPathAlgorithm?: ShortestPathAlgorithm;\r\n}\r\n\r\nexport interface YenKShortestPathsResult<NodeId extends string = string> {\r\n  source: NodeId;\r\n  target: NodeId;\r\n  paths: PathRecord<NodeId>[];\r\n  complete: boolean;\r\n}\r\n\r\nexport interface AllPairsShortestPathsOptions extends GraphBuildOptions {\r\n  algorithm?: ShortestPathAlgorithm;\r\n  failOnNegativeCycle?: boolean;\r\n}\r\n\r\nexport interface AllPairsShortestPathsResult<NodeId extends string = string> {\r\n  nodes: NodeId[];\r\n  distanceBySource: Map<NodeId, Map<NodeId, number>>;\r\n  previousBySource: Map<NodeId, Map<NodeId, NodeId>>;\r\n  algorithm: ShortestPathAlgorithm;\r\n  hasNegativeWeights: boolean;\r\n  negativeCycle: boolean;\r\n}\r\n\r\nexport interface FlowEdge<NodeId extends string = string> {\r\n  from: NodeId;\r\n  to: NodeId;\r\n  capacity: number;\r\n  cost?: number;\r\n}\r\n\r\nexport interface FlowEdgeResult<NodeId extends string = string> {\r\n  from: NodeId;\r\n  to: NodeId;\r\n  flow: number;\r\n  capacity: number;\r\n}\r\n\r\nexport interface MaximumFlowOptions extends GraphBuildOptions {}\r\n\r\nexport interface MaximumFlowResult<NodeId extends string = string> {\r\n  source: NodeId;\r\n  sink: NodeId;\r\n  maxFlow: number;\r\n  augmentations: number;\r\n  flowByEdge: FlowEdgeResult<NodeId>[];\r\n  sourcePartition: NodeId[];\r\n  sinkPartition: NodeId[];\r\n  cutEdges: Array<Required<GraphEdge<NodeId>>>;\r\n}\r\n\r\nexport interface MinCostMaxFlowOptions extends GraphBuildOptions {\r\n  targetFlow?: number;\r\n}\r\n\r\nexport interface MinCostFlowEdgeResult<NodeId extends string = string>\r\n  extends FlowEdgeResult<NodeId> {\r\n  cost: number;\r\n}\r\n\r\nexport interface MinCostMaxFlowResult<NodeId extends string = string> {\r\n  source: NodeId;\r\n  sink: NodeId;\r\n  flow: number;\r\n  cost: number;\r\n  complete: boolean;\r\n  augmentations: number;\r\n  flowByEdge: MinCostFlowEdgeResult<NodeId>[];\r\n}\r\n\r\nexport type KMeansNormalization = 'none' | 'zscore' | 'minmax';\r\n\r\nexport interface KMeansOptions {\r\n  maxIterations?: number;\r\n  tolerance?: number;\r\n  seed?: number;\r\n  nInit?: number;\r\n  normalization?: KMeansNormalization;\r\n  useKMeansPlusPlus?: boolean;\r\n}\r\n\r\nexport interface KMeansCluster {\r\n  centroid: number[];\r\n  indices: number[];\r\n}\r\n\r\nexport interface KMeansResult {\r\n  assignments: number[];\r\n  clusters: KMeansCluster[];\r\n  iterations: number;\r\n  inertia: number;\r\n  converged: boolean;\r\n  silhouette: number | null;\r\n  selectedSeed: number;\r\n}\r\n\r\nexport interface KMeansAutoOptions extends KMeansOptions {\r\n  kMin?: number;\r\n  kMax?: number;\r\n}\r\n\r\nexport interface KMeansAutoCandidate {\r\n  k: number;\r\n  silhouette: number | null;\r\n  inertia: number;\r\n}\r\n\r\nexport interface KMeansAutoResult extends KMeansResult {\r\n  selectedK: number;\r\n  candidates: KMeansAutoCandidate[];\r\n}\r\n\r\nexport interface TravelingSalesmanOptions<NodeId extends string = string>\r\n  extends GraphBuildOptions {\r\n  start?: NodeId;\r\n  returnToStart?: boolean;\r\n  twoOptPasses?: number;\r\n  multiStartCount?: number;\r\n  startCandidates?: NodeId[];\r\n  seed?: number;\r\n  shortestPathAlgorithm?: ShortestPathAlgorithm;\r\n}\r\n\r\nexport interface TravelingSalesmanSegment<NodeId extends string = string> {\r\n  from: NodeId;\r\n  to: NodeId;\r\n  distance: number;\r\n  path: NodeId[];\r\n}\r\n\r\nexport interface TravelingSalesmanResult<NodeId extends string = string> {\r\n  order: NodeId[];\r\n  distance: number;\r\n  segments: TravelingSalesmanSegment<NodeId>[];\r\n  visitedCount: number;\r\n  complete: boolean;\r\n  unreachableNodes: NodeId[];\r\n  lowerBound: number;\r\n  optimalityGap: number | null;\r\n}\r\n\r\ninterface SingleSourceShortestResult<NodeId extends string = string> {\r\n  distanceByNode: Map<NodeId, number>;\r\n  previousByNode: Map<NodeId, NodeId>;\r\n  explored: number;\r\n  negativeCycleNodes: Set<NodeId>;\r\n}\r\n\r\ninterface ShortestPathEngineResult<NodeId extends string = string> {\r\n  algorithm: ShortestPathAlgorithm;\r\n  result: SingleSourceShortestResult<NodeId>;\r\n  hasNegativeWeights: boolean;\r\n}\r\n\r\ninterface PointNormalizationTransform {\r\n  normalize: (point: number[]) => number[];\r\n  denormalize: (point: number[]) => number[];\r\n}\r\n\r\ninterface KMeansRunResult {\r\n  assignments: number[];\r\n  centroidsNormalized: number[][];\r\n  iterations: number;\r\n  inertia: number;\r\n  converged: boolean;\r\n}\r\n\r\nclass MinPriorityQueue<Value> {\r\n  private heap: Array<{ priority: number; value: Value }> = [];\r\n\r\n  get size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  push(value: Value, priority: number): void {\r\n    this.heap.push({ priority, value });\r\n    this.siftUp(this.heap.length - 1);\r\n  }\r\n\r\n  pop(): { priority: number; value: Value } | undefined {\r\n    if (this.heap.length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    const top = this.heap[0];\r\n    const last = this.heap.pop();\r\n\r\n    if (this.heap.length > 0 && last) {\r\n      this.heap[0] = last;\r\n      this.siftDown(0);\r\n    }\r\n\r\n    return top;\r\n  }\r\n\r\n  private siftUp(index: number): void {\r\n    let cursor = index;\r\n\r\n    while (cursor > 0) {\r\n      const parent = Math.floor((cursor - 1) / 2);\r\n      const current = this.heap[cursor];\r\n      const parentItem = this.heap[parent];\r\n\r\n      if (!current || !parentItem) {\r\n        return;\r\n      }\r\n      if (parentItem.priority <= current.priority) {\r\n        return;\r\n      }\r\n\r\n      this.heap[parent] = current;\r\n      this.heap[cursor] = parentItem;\r\n      cursor = parent;\r\n    }\r\n  }\r\n\r\n  private siftDown(index: number): void {\r\n    let cursor = index;\r\n\r\n    while (true) {\r\n      const left = cursor * 2 + 1;\r\n      const right = cursor * 2 + 2;\r\n      let smallest = cursor;\r\n\r\n      const current = this.heap[smallest];\r\n      const leftItem = this.heap[left];\r\n      const rightItem = this.heap[right];\r\n\r\n      if (current && leftItem && leftItem.priority < current.priority) {\r\n        smallest = left;\r\n      }\r\n\r\n      const currentSmallest = this.heap[smallest];\r\n      if (\r\n        currentSmallest &&\r\n        rightItem &&\r\n        rightItem.priority < currentSmallest.priority\r\n      ) {\r\n        smallest = right;\r\n      }\r\n\r\n      if (smallest === cursor) {\r\n        return;\r\n      }\r\n\r\n      const cursorItem = this.heap[cursor];\r\n      const smallestItem = this.heap[smallest];\r\n      if (!cursorItem || !smallestItem) {\r\n        return;\r\n      }\r\n\r\n      this.heap[cursor] = smallestItem;\r\n      this.heap[smallest] = cursorItem;\r\n      cursor = smallest;\r\n    }\r\n  }\r\n}\r\n\r\nfunction defaultTieBreaker(left: string, right: string): number {\r\n  return left.localeCompare(right);\r\n}\r\n\r\nfunction canonicalUndirectedEdge<NodeId extends string>(\r\n  left: NodeId,\r\n  right: NodeId,\r\n): { from: NodeId; to: NodeId } {\r\n  return defaultTieBreaker(left, right) <= 0\r\n    ? { from: left, to: right }\r\n    : { from: right, to: left };\r\n}\r\n\r\nfunction undirectedEdgeKey<NodeId extends string>(left: NodeId, right: NodeId): string {\r\n  const edge = canonicalUndirectedEdge(left, right);\r\n  return `${edge.from}\\u0000${edge.to}`;\r\n}\r\n\r\nfunction asNodeId<NodeId extends string>(input: GraphNodeInput<NodeId>): NodeId {\r\n  return typeof input === 'string' ? input : input.id;\r\n}\r\n\r\nclass DisjointSet<NodeId extends string> {\r\n  private parent = new Map<NodeId, NodeId>();\r\n\r\n  private rank = new Map<NodeId, number>();\r\n\r\n  constructor(nodes: NodeId[]) {\r\n    for (const nodeId of nodes) {\r\n      this.parent.set(nodeId, nodeId);\r\n      this.rank.set(nodeId, 0);\r\n    }\r\n  }\r\n\r\n  find(nodeId: NodeId): NodeId {\r\n    const parent = this.parent.get(nodeId);\r\n    if (!parent || parent === nodeId) {\r\n      return nodeId;\r\n    }\r\n\r\n    const root = this.find(parent);\r\n    this.parent.set(nodeId, root);\r\n    return root;\r\n  }\r\n\r\n  union(left: NodeId, right: NodeId): boolean {\r\n    const leftRoot = this.find(left);\r\n    const rightRoot = this.find(right);\r\n    if (leftRoot === rightRoot) {\r\n      return false;\r\n    }\r\n\r\n    const leftRank = this.rank.get(leftRoot) ?? 0;\r\n    const rightRank = this.rank.get(rightRoot) ?? 0;\r\n\r\n    if (leftRank < rightRank) {\r\n      this.parent.set(leftRoot, rightRoot);\r\n      return true;\r\n    }\r\n\r\n    if (leftRank > rightRank) {\r\n      this.parent.set(rightRoot, leftRoot);\r\n      return true;\r\n    }\r\n\r\n    this.parent.set(rightRoot, leftRoot);\r\n    this.rank.set(leftRoot, leftRank + 1);\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction dedupeNodeList<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n): NodeId[] {\r\n  const seen = new Set<NodeId>();\r\n  const ordered: NodeId[] = [];\r\n\r\n  for (const node of nodes) {\r\n    const nodeId = asNodeId(node);\r\n    if (!seen.has(nodeId)) {\r\n      seen.add(nodeId);\r\n      ordered.push(nodeId);\r\n    }\r\n  }\r\n\r\n  for (const edge of edges) {\r\n    if (!seen.has(edge.from)) {\r\n      seen.add(edge.from);\r\n      ordered.push(edge.from);\r\n    }\r\n    if (!seen.has(edge.to)) {\r\n      seen.add(edge.to);\r\n      ordered.push(edge.to);\r\n    }\r\n  }\r\n\r\n  return ordered;\r\n}\r\n\r\nfunction normalizeWeight(weight: number | undefined): number {\r\n  if (weight === undefined) {\r\n    return 1;\r\n  }\r\n\r\n  if (!Number.isFinite(weight)) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      `Graph edge weight must be finite, received ${weight}`,\r\n    );\r\n  }\r\n\r\n  return weight;\r\n}\r\n\r\nfunction initializeNeighborMap<NodeId extends string>(\r\n  nodeIds: NodeId[],\r\n): Map<NodeId, Map<NodeId, number>> {\r\n  const map = new Map<NodeId, Map<NodeId, number>>();\r\n  for (const nodeId of nodeIds) {\r\n    map.set(nodeId, new Map<NodeId, number>());\r\n  }\r\n  return map;\r\n}\r\n\r\nfunction maybeUpdateEdge<NodeId extends string>(\r\n  map: Map<NodeId, Map<NodeId, number>>,\r\n  from: NodeId,\r\n  to: NodeId,\r\n  weight: number,\r\n): void {\r\n  const outgoing = map.get(from);\r\n  if (!outgoing) {\r\n    return;\r\n  }\r\n\r\n  const existing = outgoing.get(to);\r\n  if (existing === undefined || weight < existing) {\r\n    outgoing.set(to, weight);\r\n  }\r\n}\r\n\r\nfunction buildNormalizedEdgeMap<NodeId extends string>(\r\n  nodeIds: NodeId[],\r\n  edges: GraphEdge<NodeId>[],\r\n  directed: boolean,\r\n): Map<NodeId, Map<NodeId, number>> {\r\n  const neighbors = initializeNeighborMap(nodeIds);\r\n\r\n  for (const edge of edges) {\r\n    if (edge.from === edge.to) {\r\n      continue;\r\n    }\r\n\r\n    const weight = normalizeWeight(edge.weight);\r\n    if (!neighbors.has(edge.from) || !neighbors.has(edge.to)) {\r\n      continue;\r\n    }\r\n\r\n    maybeUpdateEdge(neighbors, edge.from, edge.to, weight);\r\n    if (!directed) {\r\n      maybeUpdateEdge(neighbors, edge.to, edge.from, weight);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n}\r\n\r\nfunction toNeighborList<NodeId extends string>(\r\n  edgeMap: Map<NodeId, Map<NodeId, number>>,\r\n): Map<NodeId, GraphNeighbor<NodeId>[]> {\r\n  const neighborsByNode = new Map<NodeId, GraphNeighbor<NodeId>[]>();\r\n\r\n  for (const [nodeId, outgoing] of edgeMap.entries()) {\r\n    const neighbors: GraphNeighbor<NodeId>[] = [];\r\n    for (const [targetId, weight] of outgoing.entries()) {\r\n      neighbors.push({ id: targetId, weight });\r\n    }\r\n    neighborsByNode.set(nodeId, neighbors);\r\n  }\r\n\r\n  return neighborsByNode;\r\n}\r\n\r\nfunction createIncomingByNode<NodeId extends string>(\r\n  nodeIds: NodeId[],\r\n  neighborsByNode: Map<NodeId, GraphNeighbor<NodeId>[]>,\r\n): Map<NodeId, GraphNeighbor<NodeId>[]> {\r\n  const incomingByNode = new Map<NodeId, GraphNeighbor<NodeId>[]>();\r\n  for (const nodeId of nodeIds) {\r\n    incomingByNode.set(nodeId, []);\r\n  }\r\n\r\n  for (const [fromId, neighbors] of neighborsByNode.entries()) {\r\n    for (const neighbor of neighbors) {\r\n      const incoming = incomingByNode.get(neighbor.id);\r\n      if (!incoming) {\r\n        continue;\r\n      }\r\n      incoming.push({ id: fromId, weight: neighbor.weight });\r\n    }\r\n  }\r\n\r\n  return incomingByNode;\r\n}\r\n\r\nfunction toEdgeList<NodeId extends string>(\r\n  neighborsByNode: Map<NodeId, GraphNeighbor<NodeId>[]>,\r\n): Array<Required<GraphEdge<NodeId>>> {\r\n  const edges: Array<Required<GraphEdge<NodeId>>> = [];\r\n  for (const [fromId, neighbors] of neighborsByNode.entries()) {\r\n    for (const neighbor of neighbors) {\r\n      edges.push({\r\n        from: fromId,\r\n        to: neighbor.id,\r\n        weight: neighbor.weight,\r\n      });\r\n    }\r\n  }\r\n  return edges;\r\n}\r\n\r\nfunction hasNegativeWeights<NodeId extends string>(\r\n  adjacency: GraphAdjacency<NodeId>,\r\n): boolean {\r\n  for (const edge of adjacency.edges) {\r\n    if (edge.weight < 0) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction reconstructPath<NodeId extends string>(\r\n  source: NodeId,\r\n  target: NodeId,\r\n  previousByNode: Map<NodeId, NodeId>,\r\n): NodeId[] {\r\n  if (source === target) {\r\n    return [source];\r\n  }\r\n\r\n  const reversed: NodeId[] = [target];\r\n  let cursor: NodeId | undefined = target;\r\n\r\n  while (cursor && cursor !== source) {\r\n    const previous = previousByNode.get(cursor);\r\n    if (!previous) {\r\n      return [];\r\n    }\r\n    reversed.push(previous);\r\n    cursor = previous;\r\n  }\r\n\r\n  reversed.reverse();\r\n  return reversed[0] === source ? reversed : [];\r\n}\r\n\r\nfunction sumNeighborWeights<NodeId extends string>(\r\n  neighbors: GraphNeighbor<NodeId>[],\r\n): number {\r\n  return neighbors.reduce((sum, neighbor) => sum + neighbor.weight, 0);\r\n}\r\n\r\nfunction collectUniqueUndirectedEdges<NodeId extends string>(\r\n  adjacency: GraphAdjacency<NodeId>,\r\n): Array<Required<GraphEdge<NodeId>>> {\r\n  const byKey = new Map<string, Required<GraphEdge<NodeId>>>();\r\n\r\n  for (const edge of adjacency.edges) {\r\n    const canonical = canonicalUndirectedEdge(edge.from, edge.to);\r\n    const key = undirectedEdgeKey(canonical.from, canonical.to);\r\n    const existing = byKey.get(key);\r\n    if (!existing || edge.weight < existing.weight - 1e-12) {\r\n      byKey.set(key, {\r\n        from: canonical.from,\r\n        to: canonical.to,\r\n        weight: edge.weight,\r\n      });\r\n    }\r\n  }\r\n\r\n  return Array.from(byKey.values());\r\n}\r\n\r\nfunction computeModularity<NodeId extends string>(\r\n  adjacency: GraphAdjacency<NodeId>,\r\n  communityByNode: Map<NodeId, number>,\r\n): number {\r\n  const uniqueEdges = collectUniqueUndirectedEdges(adjacency);\r\n  let totalEdgeWeight = 0;\r\n  for (const edge of uniqueEdges) {\r\n    totalEdgeWeight += edge.weight;\r\n  }\r\n\r\n  if (!Number.isFinite(totalEdgeWeight) || totalEdgeWeight <= 0) {\r\n    return 0;\r\n  }\r\n\r\n  const degreeByNode = new Map<NodeId, number>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    degreeByNode.set(\r\n      nodeId,\r\n      sumNeighborWeights(adjacency.neighborsByNode.get(nodeId) ?? []),\r\n    );\r\n  }\r\n\r\n  const totalWeightByCommunity = new Map<number, number>();\r\n  const internalWeightByCommunity = new Map<number, number>();\r\n\r\n  for (const nodeId of adjacency.nodes) {\r\n    const community = communityByNode.get(nodeId);\r\n    if (community === undefined) {\r\n      continue;\r\n    }\r\n    const degree = degreeByNode.get(nodeId) ?? 0;\r\n    totalWeightByCommunity.set(\r\n      community,\r\n      (totalWeightByCommunity.get(community) ?? 0) + degree,\r\n    );\r\n  }\r\n\r\n  for (const edge of uniqueEdges) {\r\n    const fromCommunity = communityByNode.get(edge.from);\r\n    const toCommunity = communityByNode.get(edge.to);\r\n    if (fromCommunity === undefined || toCommunity === undefined) {\r\n      continue;\r\n    }\r\n    if (fromCommunity !== toCommunity) {\r\n      continue;\r\n    }\r\n\r\n    internalWeightByCommunity.set(\r\n      fromCommunity,\r\n      (internalWeightByCommunity.get(fromCommunity) ?? 0) + edge.weight,\r\n    );\r\n  }\r\n\r\n  let modularity = 0;\r\n  for (const [community, totalWeight] of totalWeightByCommunity.entries()) {\r\n    const internal = internalWeightByCommunity.get(community) ?? 0;\r\n    modularity +=\r\n      internal / totalEdgeWeight -\r\n      Math.pow(totalWeight / (2 * totalEdgeWeight), 2);\r\n  }\r\n\r\n  return modularity;\r\n}\r\n\r\nfunction buildCommunityResult<NodeId extends string>(\r\n  adjacency: GraphAdjacency<NodeId>,\r\n  labelsByNode: Map<NodeId, number>,\r\n  iterations: number,\r\n  converged: boolean,\r\n  algorithm: CommunityDetectionResult<NodeId>['algorithm'],\r\n): CommunityDetectionResult<NodeId> {\r\n  const communitiesRaw = new Map<number, NodeId[]>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    const label = labelsByNode.get(nodeId);\r\n    if (label === undefined) {\r\n      continue;\r\n    }\r\n    const members = communitiesRaw.get(label) ?? [];\r\n    members.push(nodeId);\r\n    communitiesRaw.set(label, members);\r\n  }\r\n\r\n  const communities = Array.from(communitiesRaw.values()).map((members) =>\r\n    [...members].sort(defaultTieBreaker),\r\n  );\r\n  communities.sort((left, right) =>\r\n    defaultTieBreaker(left[0] ?? '', right[0] ?? ''),\r\n  );\r\n\r\n  const communityByNode = new Map<NodeId, number>();\r\n  for (let index = 0; index < communities.length; index += 1) {\r\n    for (const nodeId of communities[index] ?? []) {\r\n      communityByNode.set(nodeId, index);\r\n    }\r\n  }\r\n\r\n  return {\r\n    communities,\r\n    communityByNode,\r\n    iterations,\r\n    converged,\r\n    algorithm,\r\n    modularity: computeModularity(adjacency, communityByNode),\r\n  };\r\n}\r\n\r\nfunction buildNeighborIdSetMap<NodeId extends string>(\r\n  adjacency: GraphAdjacency<NodeId>,\r\n): Map<NodeId, Set<NodeId>> {\r\n  const output = new Map<NodeId, Set<NodeId>>();\r\n\r\n  for (const nodeId of adjacency.nodes) {\r\n    output.set(nodeId, new Set<NodeId>());\r\n  }\r\n\r\n  for (const [nodeId, neighbors] of adjacency.neighborsByNode.entries()) {\r\n    const set = output.get(nodeId);\r\n    if (!set) {\r\n      continue;\r\n    }\r\n    for (const neighbor of neighbors) {\r\n      set.add(neighbor.id);\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction computeSimilarityScore<NodeId extends string>(\r\n  leftId: NodeId,\r\n  rightId: NodeId,\r\n  neighborSets: Map<NodeId, Set<NodeId>>,\r\n  metric: SimilarityMetric,\r\n): number {\r\n  const left = neighborSets.get(leftId) ?? new Set<NodeId>();\r\n  const right = neighborSets.get(rightId) ?? new Set<NodeId>();\r\n  const leftSize = left.size;\r\n  const rightSize = right.size;\r\n\r\n  const iterate = leftSize <= rightSize ? left : right;\r\n  const lookup = iterate === left ? right : left;\r\n  let common = 0;\r\n  let adamicAdar = 0;\r\n  let resourceAllocation = 0;\r\n\r\n  for (const neighbor of iterate) {\r\n    if (!lookup.has(neighbor)) {\r\n      continue;\r\n    }\r\n\r\n    common += 1;\r\n    const degree = neighborSets.get(neighbor)?.size ?? 0;\r\n    if (degree > 1) {\r\n      adamicAdar += 1 / Math.log(degree);\r\n    }\r\n    if (degree > 0) {\r\n      resourceAllocation += 1 / degree;\r\n    }\r\n  }\r\n\r\n  if (metric === 'common-neighbors') {\r\n    return common;\r\n  }\r\n  if (metric === 'preferential-attachment') {\r\n    return leftSize * rightSize;\r\n  }\r\n  if (metric === 'adamic-adar') {\r\n    return adamicAdar;\r\n  }\r\n  if (metric === 'resource-allocation') {\r\n    return resourceAllocation;\r\n  }\r\n  if (metric === 'jaccard') {\r\n    const union = leftSize + rightSize - common;\r\n    return union > 0 ? common / union : 0;\r\n  }\r\n  if (metric === 'cosine') {\r\n    return leftSize > 0 && rightSize > 0\r\n      ? common / Math.sqrt(leftSize * rightSize)\r\n      : 0;\r\n  }\r\n\r\n  const overlapDenominator = Math.min(leftSize, rightSize);\r\n  return overlapDenominator > 0 ? common / overlapDenominator : 0;\r\n}\r\n\r\nfunction routeDistanceForPath<NodeId extends string>(\r\n  path: NodeId[],\r\n  adjacency: GraphAdjacency<NodeId>,\r\n): number {\r\n  if (path.length <= 1) {\r\n    return 0;\r\n  }\r\n\r\n  let total = 0;\r\n  for (let index = 1; index < path.length; index += 1) {\r\n    const fromId = path[index - 1];\r\n    const toId = path[index];\r\n    if (!fromId || !toId) {\r\n      return Number.POSITIVE_INFINITY;\r\n    }\r\n\r\n    const weight = adjacency.neighborsByNode\r\n      .get(fromId)\r\n      ?.find((neighbor) => neighbor.id === toId)?.weight;\r\n    if (weight === undefined || !Number.isFinite(weight)) {\r\n      return Number.POSITIVE_INFINITY;\r\n    }\r\n    total += weight;\r\n  }\r\n\r\n  return total;\r\n}\r\n\r\nfunction pathKey<NodeId extends string>(path: NodeId[]): string {\r\n  return path.join('\\u0000');\r\n}\r\n\r\nfunction hasSamePrefix<NodeId extends string>(\r\n  path: NodeId[],\r\n  prefix: NodeId[],\r\n): boolean {\r\n  if (prefix.length > path.length) {\r\n    return false;\r\n  }\r\n  for (let index = 0; index < prefix.length; index += 1) {\r\n    if (path[index] !== prefix[index]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction chooseShortestPathAlgorithm(\r\n  requested: ShortestPathAlgorithm,\r\n  hasNegative: boolean,\r\n): ShortestPathAlgorithm {\r\n  if (requested === 'auto') {\r\n    return hasNegative ? 'bellman-ford' : 'dijkstra';\r\n  }\r\n  return requested;\r\n}\r\n\r\nfunction runDijkstra<NodeId extends string>(\r\n  adjacency: GraphAdjacency<NodeId>,\r\n  source: NodeId,\r\n): SingleSourceShortestResult<NodeId> {\r\n  if (hasNegativeWeights(adjacency)) {\r\n    throw new GraphAlgorithmError(\r\n      'NEGATIVE_WEIGHT',\r\n      'Dijkstra cannot run on negative graph weights.',\r\n    );\r\n  }\r\n\r\n  const distanceByNode = new Map<NodeId, number>();\r\n  const previousByNode = new Map<NodeId, NodeId>();\r\n  const settled = new Set<NodeId>();\r\n  const queue = new MinPriorityQueue<NodeId>();\r\n\r\n  for (const nodeId of adjacency.nodes) {\r\n    distanceByNode.set(nodeId, Number.POSITIVE_INFINITY);\r\n  }\r\n\r\n  distanceByNode.set(source, 0);\r\n  queue.push(source, 0);\r\n\r\n  while (queue.size > 0) {\r\n    const item = queue.pop();\r\n    if (!item) {\r\n      break;\r\n    }\r\n\r\n    const nodeId = item.value;\r\n    if (settled.has(nodeId)) {\r\n      continue;\r\n    }\r\n    settled.add(nodeId);\r\n\r\n    const currentDistance = distanceByNode.get(nodeId);\r\n    if (currentDistance === undefined || !Number.isFinite(currentDistance)) {\r\n      continue;\r\n    }\r\n\r\n    const neighbors = adjacency.neighborsByNode.get(nodeId) ?? [];\r\n    for (const neighbor of neighbors) {\r\n      const nextDistance = currentDistance + neighbor.weight;\r\n      const existingDistance = distanceByNode.get(neighbor.id);\r\n\r\n      if (\r\n        existingDistance === undefined ||\r\n        nextDistance < existingDistance - 1e-12\r\n      ) {\r\n        distanceByNode.set(neighbor.id, nextDistance);\r\n        previousByNode.set(neighbor.id, nodeId);\r\n        queue.push(neighbor.id, nextDistance);\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    distanceByNode,\r\n    previousByNode,\r\n    explored: settled.size,\r\n    negativeCycleNodes: new Set<NodeId>(),\r\n  };\r\n}\r\n\r\nfunction runBellmanFord<NodeId extends string>(\r\n  adjacency: GraphAdjacency<NodeId>,\r\n  source: NodeId,\r\n): SingleSourceShortestResult<NodeId> {\r\n  const distanceByNode = new Map<NodeId, number>();\r\n  const previousByNode = new Map<NodeId, NodeId>();\r\n\r\n  for (const nodeId of adjacency.nodes) {\r\n    distanceByNode.set(nodeId, Number.POSITIVE_INFINITY);\r\n  }\r\n  distanceByNode.set(source, 0);\r\n\r\n  const totalNodes = adjacency.nodes.length;\r\n\r\n  for (let iteration = 0; iteration < totalNodes - 1; iteration += 1) {\r\n    let changed = false;\r\n\r\n    for (const edge of adjacency.edges) {\r\n      const fromDistance = distanceByNode.get(edge.from);\r\n      if (fromDistance === undefined || !Number.isFinite(fromDistance)) {\r\n        continue;\r\n      }\r\n\r\n      const candidate = fromDistance + edge.weight;\r\n      const current = distanceByNode.get(edge.to);\r\n      if (current === undefined || candidate < current - 1e-12) {\r\n        distanceByNode.set(edge.to, candidate);\r\n        previousByNode.set(edge.to, edge.from);\r\n        changed = true;\r\n      }\r\n    }\r\n\r\n    if (!changed) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  const negativeCycleNodes = new Set<NodeId>();\r\n  const queue: NodeId[] = [];\r\n\r\n  for (const edge of adjacency.edges) {\r\n    const fromDistance = distanceByNode.get(edge.from);\r\n    const toDistance = distanceByNode.get(edge.to);\r\n\r\n    if (\r\n      fromDistance !== undefined &&\r\n      Number.isFinite(fromDistance) &&\r\n      toDistance !== undefined &&\r\n      fromDistance + edge.weight < toDistance - 1e-12\r\n    ) {\r\n      if (!negativeCycleNodes.has(edge.to)) {\r\n        negativeCycleNodes.add(edge.to);\r\n        queue.push(edge.to);\r\n      }\r\n      if (!negativeCycleNodes.has(edge.from)) {\r\n        negativeCycleNodes.add(edge.from);\r\n        queue.push(edge.from);\r\n      }\r\n    }\r\n  }\r\n\r\n  let cursor = 0;\r\n  while (cursor < queue.length) {\r\n    const nodeId = queue[cursor];\r\n    cursor += 1;\r\n    if (!nodeId) {\r\n      continue;\r\n    }\r\n\r\n    for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n      if (!negativeCycleNodes.has(neighbor.id)) {\r\n        negativeCycleNodes.add(neighbor.id);\r\n        queue.push(neighbor.id);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (negativeCycleNodes.size > 0) {\r\n    for (const nodeId of negativeCycleNodes) {\r\n      distanceByNode.set(nodeId, Number.NEGATIVE_INFINITY);\r\n      previousByNode.delete(nodeId);\r\n    }\r\n  }\r\n\r\n  let explored = 0;\r\n  for (const nodeId of adjacency.nodes) {\r\n    const distance = distanceByNode.get(nodeId);\r\n    if (distance !== undefined && Number.isFinite(distance)) {\r\n      explored += 1;\r\n    }\r\n  }\r\n\r\n  return {\r\n    distanceByNode,\r\n    previousByNode,\r\n    explored,\r\n    negativeCycleNodes,\r\n  };\r\n}\r\n\r\nfunction runShortestPathEngine<NodeId extends string>(\r\n  adjacency: GraphAdjacency<NodeId>,\r\n  source: NodeId,\r\n  requestedAlgorithm: ShortestPathAlgorithm,\r\n): ShortestPathEngineResult<NodeId> {\r\n  const hasNegative = hasNegativeWeights(adjacency);\r\n  const algorithm = chooseShortestPathAlgorithm(requestedAlgorithm, hasNegative);\r\n\r\n  if (algorithm === 'dijkstra') {\r\n    return {\r\n      algorithm,\r\n      result: runDijkstra(adjacency, source),\r\n      hasNegativeWeights: hasNegative,\r\n    };\r\n  }\r\n\r\n  return {\r\n    algorithm,\r\n    result: runBellmanFord(adjacency, source),\r\n    hasNegativeWeights: hasNegative,\r\n  };\r\n}\r\n\r\nfunction createRandom(seed: number | undefined): () => number {\r\n  if (seed === undefined || !Number.isFinite(seed)) {\r\n    return Math.random;\r\n  }\r\n\r\n  let state = (Math.floor(seed) >>> 0) || 1;\r\n  return () => {\r\n    state = (state * 1664525 + 1013904223) >>> 0;\r\n    return state / 4294967296;\r\n  };\r\n}\r\n\r\n// squaredDistance and euclideanDistance are now imported from './distance'\r\n\r\nfunction normalizePoints(\r\n  points: number[][],\r\n  mode: KMeansNormalization,\r\n): PointNormalizationTransform {\r\n  const dimensionality = points[0]?.length ?? 0;\r\n\r\n  if (mode === 'none') {\r\n    return {\r\n      normalize: (point) => [...point],\r\n      denormalize: (point) => [...point],\r\n    };\r\n  }\r\n\r\n  const means = new Array<number>(dimensionality).fill(0);\r\n  const mins = new Array<number>(dimensionality).fill(Number.POSITIVE_INFINITY);\r\n  const maxs = new Array<number>(dimensionality).fill(Number.NEGATIVE_INFINITY);\r\n\r\n  for (const point of points) {\r\n    for (let axis = 0; axis < dimensionality; axis += 1) {\r\n      const value = point[axis] ?? 0;\r\n      means[axis] = (means[axis] ?? 0) + value;\r\n      mins[axis] = Math.min(mins[axis] ?? value, value);\r\n      maxs[axis] = Math.max(maxs[axis] ?? value, value);\r\n    }\r\n  }\r\n\r\n  for (let axis = 0; axis < dimensionality; axis += 1) {\r\n    means[axis] = (means[axis] ?? 0) / points.length;\r\n  }\r\n\r\n  if (mode === 'minmax') {\r\n    const ranges = maxs.map((max, axis) => {\r\n      const min = mins[axis] ?? 0;\r\n      return max - min;\r\n    });\r\n\r\n    return {\r\n      normalize: (point) =>\r\n        point.map((value, axis) => {\r\n          const min = mins[axis] ?? 0;\r\n          const range = ranges[axis] ?? 0;\r\n          if (Math.abs(range) < 1e-12) {\r\n            return 0;\r\n          }\r\n          return (value - min) / range;\r\n        }),\r\n      denormalize: (point) =>\r\n        point.map((value, axis) => {\r\n          const min = mins[axis] ?? 0;\r\n          const range = ranges[axis] ?? 0;\r\n          return value * range + min;\r\n        }),\r\n    };\r\n  }\r\n\r\n  const variances = new Array<number>(dimensionality).fill(0);\r\n  for (const point of points) {\r\n    for (let axis = 0; axis < dimensionality; axis += 1) {\r\n      const delta = (point[axis] ?? 0) - (means[axis] ?? 0);\r\n      variances[axis] = (variances[axis] ?? 0) + delta * delta;\r\n    }\r\n  }\r\n\r\n  const stdDevs = variances.map((variance) => Math.sqrt(variance / points.length));\r\n\r\n  return {\r\n    normalize: (point) =>\r\n      point.map((value, axis) => {\r\n        const stdDev = stdDevs[axis] ?? 0;\r\n        if (stdDev < 1e-12) {\r\n          return 0;\r\n        }\r\n        return (value - (means[axis] ?? 0)) / stdDev;\r\n      }),\r\n    denormalize: (point) =>\r\n      point.map((value, axis) => {\r\n        const stdDev = stdDevs[axis] ?? 0;\r\n        return value * stdDev + (means[axis] ?? 0);\r\n      }),\r\n  };\r\n}\r\n\r\nfunction initializeCentroids(\r\n  points: number[][],\r\n  k: number,\r\n  random: () => number,\r\n  useKMeansPlusPlus: boolean,\r\n): number[][] {\r\n  if (points.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  if (!useKMeansPlusPlus) {\r\n    const centroids: number[][] = [];\r\n    const selected = new Set<number>();\r\n    while (centroids.length < k) {\r\n      const index = Math.floor(random() * points.length);\r\n      if (selected.has(index)) {\r\n        continue;\r\n      }\r\n      selected.add(index);\r\n      centroids.push([...(points[index] ?? points[0] ?? [])]);\r\n    }\r\n    return centroids;\r\n  }\r\n\r\n  const centroids: number[][] = [];\r\n  const selected = new Set<number>();\r\n\r\n  const first = Math.floor(random() * points.length);\r\n  selected.add(first);\r\n  centroids.push([...(points[first] ?? points[0] ?? [])]);\r\n\r\n  while (centroids.length < k) {\r\n    const distanceWeights = new Array<number>(points.length).fill(0);\r\n    let totalWeight = 0;\r\n\r\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\r\n      if (selected.has(pointIndex)) {\r\n        continue;\r\n      }\r\n\r\n      const point = points[pointIndex];\r\n      if (!point) {\r\n        continue;\r\n      }\r\n\r\n      let bestDistance = Number.POSITIVE_INFINITY;\r\n      for (const centroid of centroids) {\r\n        bestDistance = Math.min(bestDistance, squaredDistance(point, centroid));\r\n      }\r\n\r\n      distanceWeights[pointIndex] = bestDistance;\r\n      totalWeight += bestDistance;\r\n    }\r\n\r\n    if (!Number.isFinite(totalWeight) || totalWeight <= 0) {\r\n      for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\r\n        if (!selected.has(pointIndex)) {\r\n          selected.add(pointIndex);\r\n          centroids.push([...(points[pointIndex] ?? points[0] ?? [])]);\r\n          break;\r\n        }\r\n      }\r\n      continue;\r\n    }\r\n\r\n    const threshold = random() * totalWeight;\r\n    let running = 0;\r\n    let pickedIndex = -1;\r\n\r\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\r\n      if (selected.has(pointIndex)) {\r\n        continue;\r\n      }\r\n      running += distanceWeights[pointIndex] ?? 0;\r\n      if (running >= threshold) {\r\n        pickedIndex = pointIndex;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (pickedIndex < 0) {\r\n      for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\r\n        if (!selected.has(pointIndex)) {\r\n          pickedIndex = pointIndex;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (pickedIndex < 0) {\r\n      break;\r\n    }\r\n\r\n    selected.add(pickedIndex);\r\n    centroids.push([...(points[pickedIndex] ?? points[0] ?? [])]);\r\n  }\r\n\r\n  return centroids;\r\n}\r\n\r\nfunction runSingleKMeans(\r\n  points: number[][],\r\n  k: number,\r\n  random: () => number,\r\n  maxIterations: number,\r\n  tolerance: number,\r\n  useKMeansPlusPlus: boolean,\r\n): KMeansRunResult {\r\n  const dimensionality = points[0]?.length ?? 0;\r\n  let centroids = initializeCentroids(points, k, random, useKMeansPlusPlus);\r\n\r\n  if (centroids.length !== k) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'Unable to initialize centroids for k-means.',\r\n    );\r\n  }\r\n\r\n  const assignments = new Array<number>(points.length).fill(-1);\r\n  let iterations = 0;\r\n  let converged = false;\r\n  let inertia = Number.POSITIVE_INFINITY;\r\n\r\n  while (iterations < maxIterations) {\r\n    iterations += 1;\r\n    let changed = false;\r\n    inertia = 0;\r\n\r\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\r\n      const point = points[pointIndex];\r\n      if (!point) {\r\n        continue;\r\n      }\r\n\r\n      let bestCluster = 0;\r\n      let bestDistance = Number.POSITIVE_INFINITY;\r\n\r\n      for (let clusterIndex = 0; clusterIndex < centroids.length; clusterIndex += 1) {\r\n        const centroid = centroids[clusterIndex];\r\n        if (!centroid) {\r\n          continue;\r\n        }\r\n        const distance = squaredDistance(point, centroid);\r\n        if (distance < bestDistance) {\r\n          bestDistance = distance;\r\n          bestCluster = clusterIndex;\r\n        }\r\n      }\r\n\r\n      inertia += bestDistance;\r\n      if (assignments[pointIndex] !== bestCluster) {\r\n        assignments[pointIndex] = bestCluster;\r\n        changed = true;\r\n      }\r\n    }\r\n\r\n    const nextCentroids = new Array<number[]>(k);\r\n    const counts = new Array<number>(k).fill(0);\r\n\r\n    for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {\r\n      nextCentroids[clusterIndex] = new Array<number>(dimensionality).fill(0);\r\n    }\r\n\r\n    for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\r\n      const clusterIndex = assignments[pointIndex];\r\n      if (clusterIndex < 0) {\r\n        continue;\r\n      }\r\n\r\n      const point = points[pointIndex];\r\n      const centroid = nextCentroids[clusterIndex];\r\n      if (!point || !centroid) {\r\n        continue;\r\n      }\r\n\r\n      counts[clusterIndex] = (counts[clusterIndex] ?? 0) + 1;\r\n      for (let axis = 0; axis < dimensionality; axis += 1) {\r\n        centroid[axis] = (centroid[axis] ?? 0) + (point[axis] ?? 0);\r\n      }\r\n    }\r\n\r\n    for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {\r\n      const count = counts[clusterIndex] ?? 0;\r\n      if (count > 0) {\r\n        const centroid = nextCentroids[clusterIndex];\r\n        if (!centroid) {\r\n          continue;\r\n        }\r\n        for (let axis = 0; axis < dimensionality; axis += 1) {\r\n          centroid[axis] = (centroid[axis] ?? 0) / count;\r\n        }\r\n      } else {\r\n        let farthestIndex = 0;\r\n        let farthestDistance = -1;\r\n\r\n        for (let pointIndex = 0; pointIndex < points.length; pointIndex += 1) {\r\n          const assigned = assignments[pointIndex];\r\n          const centroid = centroids[assigned];\r\n          const point = points[pointIndex];\r\n          if (!centroid || !point) {\r\n            continue;\r\n          }\r\n\r\n          const distance = squaredDistance(point, centroid);\r\n          if (distance > farthestDistance) {\r\n            farthestDistance = distance;\r\n            farthestIndex = pointIndex;\r\n          }\r\n        }\r\n\r\n        nextCentroids[clusterIndex] = [...(points[farthestIndex] ?? points[0] ?? [])];\r\n      }\r\n    }\r\n\r\n    let maxShift = 0;\r\n    for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {\r\n      const previous = centroids[clusterIndex];\r\n      const next = nextCentroids[clusterIndex];\r\n      if (!previous || !next) {\r\n        continue;\r\n      }\r\n      maxShift = Math.max(maxShift, Math.sqrt(squaredDistance(previous, next)));\r\n    }\r\n\r\n    centroids = nextCentroids;\r\n\r\n    if (!changed || maxShift <= tolerance) {\r\n      converged = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return {\r\n    assignments,\r\n    centroidsNormalized: centroids,\r\n    iterations,\r\n    inertia,\r\n    converged,\r\n  };\r\n}\r\n\r\nfunction computeSilhouette(points: number[][], assignments: number[], k: number): number | null {\r\n  if (points.length <= 1 || k <= 1) {\r\n    return null;\r\n  }\r\n\r\n  const clusters: number[][] = Array.from({ length: k }, (): number[] => []);\r\n  for (let index = 0; index < assignments.length; index += 1) {\r\n    const cluster = assignments[index] ?? -1;\r\n    if (cluster >= 0 && cluster < k) {\r\n      const clusterMembers = clusters[cluster];\r\n      if (clusterMembers) {\r\n        clusterMembers.push(index);\r\n      }\r\n    }\r\n  }\r\n\r\n  let total = 0;\r\n  let counted = 0;\r\n\r\n  for (let index = 0; index < points.length; index += 1) {\r\n    const point = points[index];\r\n    const ownCluster = assignments[index] ?? -1;\r\n\r\n    if (!point || ownCluster < 0 || ownCluster >= k) {\r\n      continue;\r\n    }\r\n\r\n    const ownMembers = clusters[ownCluster] ?? [];\r\n    if (ownMembers.length <= 1) {\r\n      continue;\r\n    }\r\n\r\n    let a = 0;\r\n    for (const neighborIndex of ownMembers) {\r\n      if (neighborIndex === index) {\r\n        continue;\r\n      }\r\n      const neighbor = points[neighborIndex];\r\n      if (!neighbor) {\r\n        continue;\r\n      }\r\n      a += euclideanDistance(point, neighbor);\r\n    }\r\n    a /= ownMembers.length - 1;\r\n\r\n    let b = Number.POSITIVE_INFINITY;\r\n\r\n    for (let cluster = 0; cluster < k; cluster += 1) {\r\n      if (cluster === ownCluster) {\r\n        continue;\r\n      }\r\n\r\n      const members = clusters[cluster] ?? [];\r\n      if (members.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      let distanceToCluster = 0;\r\n      for (const neighborIndex of members) {\r\n        const neighbor = points[neighborIndex];\r\n        if (!neighbor) {\r\n          continue;\r\n        }\r\n        distanceToCluster += euclideanDistance(point, neighbor);\r\n      }\r\n      distanceToCluster /= members.length;\r\n      b = Math.min(b, distanceToCluster);\r\n    }\r\n\r\n    if (!Number.isFinite(b)) {\r\n      continue;\r\n    }\r\n\r\n    const denominator = Math.max(a, b);\r\n    if (denominator <= 0) {\r\n      continue;\r\n    }\r\n\r\n    total += (b - a) / denominator;\r\n    counted += 1;\r\n  }\r\n\r\n  if (counted === 0) {\r\n    return null;\r\n  }\r\n\r\n  return total / counted;\r\n}\r\n\r\nfunction routeDistanceFromMatrix<NodeId extends string>(\r\n  route: NodeId[],\r\n  distanceMatrix: Map<NodeId, Map<NodeId, number>>,\r\n): number {\r\n  let total = 0;\r\n\r\n  for (let index = 1; index < route.length; index += 1) {\r\n    const fromId = route[index - 1];\r\n    const toId = route[index];\r\n    if (!fromId || !toId) {\r\n      return Number.POSITIVE_INFINITY;\r\n    }\r\n\r\n    const distance = distanceMatrix.get(fromId)?.get(toId);\r\n    if (distance === undefined || !Number.isFinite(distance)) {\r\n      return Number.POSITIVE_INFINITY;\r\n    }\r\n\r\n    total += distance;\r\n  }\r\n\r\n  return total;\r\n}\r\n\r\nfunction optimizeRouteTwoOpt<NodeId extends string>(\r\n  route: NodeId[],\r\n  distanceMatrix: Map<NodeId, Map<NodeId, number>>,\r\n  passes: number,\r\n): NodeId[] {\r\n  if (route.length < 4 || passes <= 0) {\r\n    return route;\r\n  }\r\n\r\n  let best = [...route];\r\n  let bestDistance = routeDistanceFromMatrix(best, distanceMatrix);\r\n\r\n  if (!Number.isFinite(bestDistance)) {\r\n    return best;\r\n  }\r\n\r\n  for (let pass = 0; pass < passes; pass += 1) {\r\n    let improved = false;\r\n\r\n    for (let start = 1; start < best.length - 2; start += 1) {\r\n      for (let end = start + 1; end < best.length - 1; end += 1) {\r\n        const head = best.slice(0, start);\r\n        const middle = best.slice(start, end + 1).reverse();\r\n        const tail = best.slice(end + 1);\r\n        const candidate = head.concat(middle, tail);\r\n        const candidateDistance = routeDistanceFromMatrix(\r\n          candidate,\r\n          distanceMatrix,\r\n        );\r\n\r\n        if (candidateDistance + 1e-9 < bestDistance) {\r\n          best = candidate;\r\n          bestDistance = candidateDistance;\r\n          improved = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!improved) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return best;\r\n}\r\n\r\nfunction createDeterministicStartList<NodeId extends string>(\r\n  nodes: NodeId[],\r\n  options: TravelingSalesmanOptions<NodeId>,\r\n): NodeId[] {\r\n  const starts: NodeId[] = [];\r\n  const used = new Set<NodeId>();\r\n\r\n  if (options.start && nodes.includes(options.start)) {\r\n    starts.push(options.start);\r\n    used.add(options.start);\r\n  }\r\n\r\n  for (const candidate of options.startCandidates ?? []) {\r\n    if (nodes.includes(candidate) && !used.has(candidate)) {\r\n      starts.push(candidate);\r\n      used.add(candidate);\r\n    }\r\n  }\r\n\r\n  const random = createRandom(options.seed);\r\n  const pool = nodes.filter((nodeId) => !used.has(nodeId));\r\n\r\n  for (let index = pool.length - 1; index > 0; index -= 1) {\r\n    const swapIndex = Math.floor(random() * (index + 1));\r\n    const left = pool[index];\r\n    const right = pool[swapIndex];\r\n    if (left !== undefined && right !== undefined) {\r\n      pool[index] = right;\r\n      pool[swapIndex] = left;\r\n    }\r\n  }\r\n\r\n  const desiredCount = Math.max(\r\n    1,\r\n    Math.min(nodes.length, options.multiStartCount ?? Math.min(8, nodes.length)),\r\n  );\r\n\r\n  for (const nodeId of pool) {\r\n    if (starts.length >= desiredCount) {\r\n      break;\r\n    }\r\n    starts.push(nodeId);\r\n  }\r\n\r\n  if (starts.length === 0 && nodes.length > 0) {\r\n    starts.push(nodes[0]!);\r\n  }\r\n\r\n  return starts;\r\n}\r\n\r\nfunction buildGreedyRoute<NodeId extends string>(\r\n  start: NodeId,\r\n  nodes: NodeId[],\r\n  distanceMatrix: Map<NodeId, Map<NodeId, number>>,\r\n  returnToStart: boolean,\r\n): NodeId[] {\r\n  const route: NodeId[] = [start];\r\n  const unvisited = new Set(nodes.filter((nodeId) => nodeId !== start));\r\n  let cursor = start;\r\n\r\n  while (unvisited.size > 0) {\r\n    let nextNode: NodeId | null = null;\r\n    let nextDistance = Number.POSITIVE_INFINITY;\r\n\r\n    const distances = distanceMatrix.get(cursor);\r\n    for (const candidate of unvisited) {\r\n      const candidateDistance = distances?.get(candidate) ?? Number.POSITIVE_INFINITY;\r\n      if (candidateDistance < nextDistance) {\r\n        nextDistance = candidateDistance;\r\n        nextNode = candidate;\r\n      }\r\n    }\r\n\r\n    if (!nextNode || !Number.isFinite(nextDistance)) {\r\n      break;\r\n    }\r\n\r\n    route.push(nextNode);\r\n    unvisited.delete(nextNode);\r\n    cursor = nextNode;\r\n  }\r\n\r\n  if (returnToStart && route.length > 1) {\r\n    route.push(start);\r\n  }\r\n\r\n  return route;\r\n}\r\n\r\nfunction computeMstLowerBound<NodeId extends string>(\r\n  nodes: NodeId[],\r\n  distanceMatrix: Map<NodeId, Map<NodeId, number>>,\r\n): number {\r\n  if (nodes.length <= 1) {\r\n    return 0;\r\n  }\r\n\r\n  const visited = new Set<NodeId>();\r\n  visited.add(nodes[0]!);\r\n  let total = 0;\r\n\r\n  while (visited.size < nodes.length) {\r\n    let bestDistance = Number.POSITIVE_INFINITY;\r\n    let nextNode: NodeId | null = null;\r\n\r\n    for (const fromId of visited) {\r\n      const distances = distanceMatrix.get(fromId);\r\n      for (const toId of nodes) {\r\n        if (visited.has(toId)) {\r\n          continue;\r\n        }\r\n\r\n        const distance = distances?.get(toId) ?? Number.POSITIVE_INFINITY;\r\n        if (distance < bestDistance) {\r\n          bestDistance = distance;\r\n          nextNode = toId;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!nextNode || !Number.isFinite(bestDistance)) {\r\n      return Number.POSITIVE_INFINITY;\r\n    }\r\n\r\n    visited.add(nextNode);\r\n    total += bestDistance;\r\n  }\r\n\r\n  return total;\r\n}\r\n\r\nexport function buildGraphAdjacency<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: GraphBuildOptions = {},\r\n): GraphAdjacency<NodeId> {\r\n  const directed = options.directed ?? true;\r\n  const nodeIds = dedupeNodeList(nodes, edges);\r\n  const edgeMap = buildNormalizedEdgeMap(nodeIds, edges, directed);\r\n  const neighborsByNode = toNeighborList(edgeMap);\r\n  const incomingByNode = createIncomingByNode(nodeIds, neighborsByNode);\r\n\r\n  return {\r\n    nodes: nodeIds,\r\n    neighborsByNode,\r\n    incomingByNode,\r\n    edges: toEdgeList(neighborsByNode),\r\n    directed,\r\n  };\r\n}\r\n\r\nexport function stronglyConnectedComponents<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: StronglyConnectedComponentsOptions = {},\r\n): StronglyConnectedComponentsResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n  const components: NodeId[][] = [];\r\n\r\n  if (!adjacency.directed) {\r\n    const visited = new Set<NodeId>();\r\n\r\n    for (const source of adjacency.nodes) {\r\n      if (visited.has(source)) {\r\n        continue;\r\n      }\r\n\r\n      const queue: NodeId[] = [source];\r\n      visited.add(source);\r\n      const component: NodeId[] = [];\r\n\r\n      let cursor = 0;\r\n      while (cursor < queue.length) {\r\n        const nodeId = queue[cursor];\r\n        cursor += 1;\r\n        if (!nodeId) {\r\n          continue;\r\n        }\r\n\r\n        component.push(nodeId);\r\n        for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n          if (!visited.has(neighbor.id)) {\r\n            visited.add(neighbor.id);\r\n            queue.push(neighbor.id);\r\n          }\r\n        }\r\n      }\r\n\r\n      component.sort(defaultTieBreaker);\r\n      components.push(component);\r\n    }\r\n  } else {\r\n    let index = 0;\r\n    const indexByNode = new Map<NodeId, number>();\r\n    const lowLinkByNode = new Map<NodeId, number>();\r\n    const stack: NodeId[] = [];\r\n    const inStack = new Set<NodeId>();\r\n\r\n    const strongConnect = (nodeId: NodeId): void => {\r\n      indexByNode.set(nodeId, index);\r\n      lowLinkByNode.set(nodeId, index);\r\n      index += 1;\r\n      stack.push(nodeId);\r\n      inStack.add(nodeId);\r\n\r\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n        if (!indexByNode.has(neighbor.id)) {\r\n          strongConnect(neighbor.id);\r\n          const currentLow = lowLinkByNode.get(nodeId) ?? 0;\r\n          const neighborLow = lowLinkByNode.get(neighbor.id) ?? 0;\r\n          lowLinkByNode.set(nodeId, Math.min(currentLow, neighborLow));\r\n        } else if (inStack.has(neighbor.id)) {\r\n          const currentLow = lowLinkByNode.get(nodeId) ?? 0;\r\n          const neighborIndex = indexByNode.get(neighbor.id) ?? 0;\r\n          lowLinkByNode.set(nodeId, Math.min(currentLow, neighborIndex));\r\n        }\r\n      }\r\n\r\n      if ((lowLinkByNode.get(nodeId) ?? -1) === (indexByNode.get(nodeId) ?? -2)) {\r\n        const component: NodeId[] = [];\r\n\r\n        while (stack.length > 0) {\r\n          const member = stack.pop();\r\n          if (!member) {\r\n            break;\r\n          }\r\n          inStack.delete(member);\r\n          component.push(member);\r\n          if (member === nodeId) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        component.sort(defaultTieBreaker);\r\n        components.push(component);\r\n      }\r\n    };\r\n\r\n    for (const nodeId of adjacency.nodes) {\r\n      if (!indexByNode.has(nodeId)) {\r\n        strongConnect(nodeId);\r\n      }\r\n    }\r\n  }\r\n\r\n  components.sort((left, right) => {\r\n    const firstLeft = left[0] ?? '';\r\n    const firstRight = right[0] ?? '';\r\n    return defaultTieBreaker(firstLeft, firstRight);\r\n  });\r\n\r\n  const componentByNode = new Map<NodeId, number>();\r\n  for (let componentIndex = 0; componentIndex < components.length; componentIndex += 1) {\r\n    for (const nodeId of components[componentIndex] ?? []) {\r\n      componentByNode.set(nodeId, componentIndex);\r\n    }\r\n  }\r\n\r\n  return {\r\n    components,\r\n    componentByNode,\r\n  };\r\n}\r\n\r\nexport function weaklyConnectedComponents<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n): WeaklyConnectedComponentsResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed: false });\r\n  const components: NodeId[][] = [];\r\n  const componentByNode = new Map<NodeId, number>();\r\n  const visited = new Set<NodeId>();\r\n\r\n  for (const source of adjacency.nodes) {\r\n    if (visited.has(source)) {\r\n      continue;\r\n    }\r\n\r\n    const queue: NodeId[] = [source];\r\n    visited.add(source);\r\n    const component: NodeId[] = [];\r\n\r\n    let cursor = 0;\r\n    while (cursor < queue.length) {\r\n      const nodeId = queue[cursor];\r\n      cursor += 1;\r\n      if (!nodeId) {\r\n        continue;\r\n      }\r\n\r\n      component.push(nodeId);\r\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n        if (!visited.has(neighbor.id)) {\r\n          visited.add(neighbor.id);\r\n          queue.push(neighbor.id);\r\n        }\r\n      }\r\n    }\r\n\r\n    component.sort(defaultTieBreaker);\r\n    const componentIndex = components.length;\r\n    components.push(component);\r\n    for (const nodeId of component) {\r\n      componentByNode.set(nodeId, componentIndex);\r\n    }\r\n  }\r\n\r\n  components.sort((left, right) => {\r\n    const firstLeft = left[0] ?? '';\r\n    const firstRight = right[0] ?? '';\r\n    return defaultTieBreaker(firstLeft, firstRight);\r\n  });\r\n\r\n  componentByNode.clear();\r\n  for (let componentIndex = 0; componentIndex < components.length; componentIndex += 1) {\r\n    const component = components[componentIndex] ?? [];\r\n    for (const nodeId of component) {\r\n      componentByNode.set(nodeId, componentIndex);\r\n    }\r\n  }\r\n\r\n  return {\r\n    components,\r\n    componentByNode,\r\n  };\r\n}\r\n\r\nexport function topologicalSort<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: TopologicalSortOptions<NodeId> = {},\r\n): TopologicalSortResult<NodeId> {\r\n  const nodeIds = dedupeNodeList(nodes, edges);\r\n  const tieBreaker =\r\n    options.tieBreaker ??\r\n    ((left: NodeId, right: NodeId) => defaultTieBreaker(left, right));\r\n  const priorityByNode = options.priorityByNode;\r\n  const priorityAccessor =\r\n    options.priority ??\r\n    ((nodeId: NodeId) => {\r\n      if (priorityByNode instanceof Map) {\r\n        return priorityByNode.get(nodeId) ?? 0;\r\n      }\r\n      if (priorityByNode) {\r\n        return priorityByNode[nodeId] ?? 0;\r\n      }\r\n      return 0;\r\n    });\r\n  const compareNodes = (left: NodeId, right: NodeId): number => {\r\n    const priorityDelta = priorityAccessor(right) - priorityAccessor(left);\r\n    if (Math.abs(priorityDelta) > 1e-12) {\r\n      return priorityDelta;\r\n    }\r\n    return tieBreaker(left, right);\r\n  };\r\n\r\n  const outgoing = new Map<NodeId, Set<NodeId>>();\r\n  const indegree = new Map<NodeId, number>();\r\n\r\n  for (const nodeId of nodeIds) {\r\n    outgoing.set(nodeId, new Set<NodeId>());\r\n    indegree.set(nodeId, 0);\r\n  }\r\n\r\n  for (const edge of edges) {\r\n    if (edge.from === edge.to) {\r\n      continue;\r\n    }\r\n    if (!outgoing.has(edge.from) || !outgoing.has(edge.to)) {\r\n      continue;\r\n    }\r\n\r\n    const targets = outgoing.get(edge.from);\r\n    if (!targets || targets.has(edge.to)) {\r\n      continue;\r\n    }\r\n\r\n    targets.add(edge.to);\r\n    indegree.set(edge.to, (indegree.get(edge.to) ?? 0) + 1);\r\n  }\r\n\r\n  const queue = nodeIds\r\n    .filter((nodeId) => (indegree.get(nodeId) ?? 0) === 0)\r\n    .sort(compareNodes);\r\n\r\n  const order: NodeId[] = [];\r\n\r\n  while (queue.length > 0) {\r\n    const nodeId = queue.shift();\r\n    if (!nodeId) {\r\n      continue;\r\n    }\r\n\r\n    order.push(nodeId);\r\n    const targets = Array.from(outgoing.get(nodeId) ?? []).sort(compareNodes);\r\n\r\n    for (const targetId of targets) {\r\n      const next = (indegree.get(targetId) ?? 0) - 1;\r\n      indegree.set(targetId, next);\r\n      if (next === 0) {\r\n        queue.push(targetId);\r\n      }\r\n    }\r\n\r\n    queue.sort(compareNodes);\r\n  }\r\n\r\n  const orderSet = new Set(order);\r\n  const leftovers = nodeIds.filter((nodeId) => !orderSet.has(nodeId));\r\n  leftovers.sort(compareNodes);\r\n\r\n  const directedScc = stronglyConnectedComponents(nodeIds, edges, { directed: true });\r\n  const selfLoopNodes = new Set<NodeId>(\r\n    edges.filter((edge) => edge.from === edge.to).map((edge) => edge.from),\r\n  );\r\n\r\n  const cycleNodes = new Set<NodeId>();\r\n  for (const component of directedScc.components) {\r\n    if (component.length > 1) {\r\n      for (const nodeId of component) {\r\n        cycleNodes.add(nodeId);\r\n      }\r\n    } else if (component.length === 1) {\r\n      const nodeId = component[0];\r\n      if (nodeId && selfLoopNodes.has(nodeId)) {\r\n        cycleNodes.add(nodeId);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const nodeId of leftovers) {\r\n    cycleNodes.add(nodeId);\r\n  }\r\n\r\n  for (const nodeId of leftovers) {\r\n    if (!orderSet.has(nodeId)) {\r\n      order.push(nodeId);\r\n      orderSet.add(nodeId);\r\n    }\r\n  }\r\n\r\n  return {\r\n    order,\r\n    cycleNodes: Array.from(cycleNodes).sort(compareNodes),\r\n    isDag: cycleNodes.size === 0,\r\n  };\r\n}\r\n\r\nexport function degreeCentrality<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: GraphBuildOptions = {},\r\n): Map<NodeId, DegreeCentralityRecord> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n  const total = adjacency.nodes.length;\r\n  const denominator =\r\n    total <= 1\r\n      ? 1\r\n      : adjacency.directed\r\n        ? 2 * (total - 1)\r\n        : Math.max(1, total - 1);\r\n\r\n  const output = new Map<NodeId, DegreeCentralityRecord>();\r\n\r\n  for (const nodeId of adjacency.nodes) {\r\n    const outDegree = adjacency.neighborsByNode.get(nodeId)?.length ?? 0;\r\n    const inDegree = adjacency.incomingByNode.get(nodeId)?.length ?? 0;\r\n    const degree = adjacency.directed ? inDegree + outDegree : outDegree;\r\n\r\n    output.set(nodeId, {\r\n      inDegree,\r\n      outDegree,\r\n      degree,\r\n      normalized: degree / denominator,\r\n    });\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nexport interface ClosenessCentralityOptions extends GraphBuildOptions {\r\n  mode?: ClosenessCentralityMode;\r\n  shortestPathAlgorithm?: ShortestPathAlgorithm;\r\n}\r\n\r\nexport function closenessCentrality<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: ClosenessCentralityOptions = {},\r\n): Map<NodeId, ClosenessCentralityRecord> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n  const total = adjacency.nodes.length;\r\n  const totalOthers = Math.max(0, total - 1);\r\n  const mode: ClosenessCentralityMode = options.mode ?? 'harmonic';\r\n  const output = new Map<NodeId, ClosenessCentralityRecord>();\r\n\r\n  for (const source of adjacency.nodes) {\r\n    const engine = runShortestPathEngine(\r\n      adjacency,\r\n      source,\r\n      options.shortestPathAlgorithm ?? 'auto',\r\n    );\r\n\r\n    const distances = engine.result.distanceByNode;\r\n    const negativeCycle = engine.result.negativeCycleNodes.size > 0;\r\n    let reachableCount = 0;\r\n    let distanceSum = 0;\r\n    let harmonicSum = 0;\r\n\r\n    for (const target of adjacency.nodes) {\r\n      if (target === source) {\r\n        continue;\r\n      }\r\n\r\n      const distance = distances.get(target);\r\n      if (distance === undefined || !Number.isFinite(distance) || distance <= 0) {\r\n        continue;\r\n      }\r\n\r\n      reachableCount += 1;\r\n      distanceSum += distance;\r\n      harmonicSum += 1 / distance;\r\n    }\r\n\r\n    let score = 0;\r\n    let normalized = 0;\r\n\r\n    if (!negativeCycle) {\r\n      if (mode === 'classic') {\r\n        score =\r\n          reachableCount > 0 && distanceSum > 0\r\n            ? reachableCount / distanceSum\r\n            : 0;\r\n        normalized = totalOthers > 0 ? score * (reachableCount / totalOthers) : 0;\r\n      } else {\r\n        score = harmonicSum;\r\n        normalized = totalOthers > 0 ? harmonicSum / totalOthers : 0;\r\n      }\r\n    }\r\n\r\n    output.set(source, {\r\n      reachableCount,\r\n      distanceSum,\r\n      score,\r\n      normalized,\r\n      mode,\r\n      negativeCycle,\r\n    });\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nexport function betweennessCentrality<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: GraphBuildOptions = {},\r\n): Map<NodeId, BetweennessCentralityRecord> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n  if (hasNegativeWeights(adjacency)) {\r\n    throw new GraphAlgorithmError(\r\n      'NEGATIVE_WEIGHT',\r\n      'Betweenness centrality requires non-negative graph weights.',\r\n    );\r\n  }\r\n\r\n  const output = new Map<NodeId, number>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    output.set(nodeId, 0);\r\n  }\r\n\r\n  for (const source of adjacency.nodes) {\r\n    const stack: NodeId[] = [];\r\n    const predecessors = new Map<NodeId, NodeId[]>();\r\n    const sigma = new Map<NodeId, number>();\r\n    const distance = new Map<NodeId, number>();\r\n    const queue = new MinPriorityQueue<NodeId>();\r\n    const settled = new Set<NodeId>();\r\n\r\n    for (const nodeId of adjacency.nodes) {\r\n      predecessors.set(nodeId, []);\r\n      sigma.set(nodeId, 0);\r\n      distance.set(nodeId, Number.POSITIVE_INFINITY);\r\n    }\r\n\r\n    sigma.set(source, 1);\r\n    distance.set(source, 0);\r\n    queue.push(source, 0);\r\n\r\n    while (queue.size > 0) {\r\n      const item = queue.pop();\r\n      if (!item) {\r\n        break;\r\n      }\r\n\r\n      const nodeId = item.value;\r\n      if (settled.has(nodeId)) {\r\n        continue;\r\n      }\r\n\r\n      settled.add(nodeId);\r\n      stack.push(nodeId);\r\n\r\n      const distanceToNode = distance.get(nodeId);\r\n      if (distanceToNode === undefined || !Number.isFinite(distanceToNode)) {\r\n        continue;\r\n      }\r\n\r\n      const sigmaToNode = sigma.get(nodeId) ?? 0;\r\n\r\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n        const candidateDistance = distanceToNode + neighbor.weight;\r\n        const knownDistance = distance.get(neighbor.id);\r\n\r\n        if (\r\n          knownDistance === undefined ||\r\n          candidateDistance < knownDistance - 1e-12\r\n        ) {\r\n          distance.set(neighbor.id, candidateDistance);\r\n          queue.push(neighbor.id, candidateDistance);\r\n          sigma.set(neighbor.id, sigmaToNode);\r\n          predecessors.set(neighbor.id, [nodeId]);\r\n        } else if (\r\n          knownDistance !== undefined &&\r\n          Math.abs(candidateDistance - knownDistance) <= 1e-12\r\n        ) {\r\n          sigma.set(neighbor.id, (sigma.get(neighbor.id) ?? 0) + sigmaToNode);\r\n          predecessors.get(neighbor.id)?.push(nodeId);\r\n        }\r\n      }\r\n    }\r\n\r\n    const dependency = new Map<NodeId, number>();\r\n    for (const nodeId of adjacency.nodes) {\r\n      dependency.set(nodeId, 0);\r\n    }\r\n\r\n    while (stack.length > 0) {\r\n      const nodeId = stack.pop();\r\n      if (!nodeId) {\r\n        continue;\r\n      }\r\n\r\n      const sigmaNode = sigma.get(nodeId) ?? 0;\r\n      const dependencyNode = dependency.get(nodeId) ?? 0;\r\n\r\n      for (const predecessor of predecessors.get(nodeId) ?? []) {\r\n        const sigmaPredecessor = sigma.get(predecessor) ?? 0;\r\n        if (sigmaNode <= 0) {\r\n          continue;\r\n        }\r\n\r\n        const contribution =\r\n          (sigmaPredecessor / sigmaNode) * (1 + dependencyNode);\r\n        dependency.set(\r\n          predecessor,\r\n          (dependency.get(predecessor) ?? 0) + contribution,\r\n        );\r\n      }\r\n\r\n      if (nodeId !== source) {\r\n        output.set(nodeId, (output.get(nodeId) ?? 0) + dependencyNode);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!adjacency.directed) {\r\n    for (const nodeId of adjacency.nodes) {\r\n      output.set(nodeId, (output.get(nodeId) ?? 0) / 2);\r\n    }\r\n  }\r\n\r\n  const total = adjacency.nodes.length;\r\n  const normalization =\r\n    total <= 2\r\n      ? Number.POSITIVE_INFINITY\r\n      : adjacency.directed\r\n        ? (total - 1) * (total - 2)\r\n        : ((total - 1) * (total - 2)) / 2;\r\n\r\n  const records = new Map<NodeId, BetweennessCentralityRecord>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    const raw = output.get(nodeId) ?? 0;\r\n    records.set(nodeId, {\r\n      raw,\r\n      normalized:\r\n        Number.isFinite(normalization) && normalization > 0\r\n          ? raw / normalization\r\n          : 0,\r\n    });\r\n  }\r\n\r\n  return records;\r\n}\r\n\r\nexport function pageRank<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: PageRankOptions = {},\r\n): PageRankResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n\r\n  if (hasNegativeWeights(adjacency)) {\r\n    throw new GraphAlgorithmError(\r\n      'NEGATIVE_WEIGHT',\r\n      'PageRank requires non-negative graph weights.',\r\n    );\r\n  }\r\n\r\n  const totalNodes = adjacency.nodes.length;\r\n  if (totalNodes === 0) {\r\n    return {\r\n      byNode: new Map<NodeId, PageRankRecord>(),\r\n      order: [],\r\n      iterations: 0,\r\n      converged: true,\r\n      dampingFactor: options.dampingFactor ?? 0.85,\r\n    };\r\n  }\r\n\r\n  const dampingFactor = options.dampingFactor ?? 0.85;\r\n  if (\r\n    !Number.isFinite(dampingFactor) ||\r\n    dampingFactor < 0 ||\r\n    dampingFactor >= 1\r\n  ) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      `PageRank dampingFactor must be in [0, 1), received ${dampingFactor}.`,\r\n    );\r\n  }\r\n\r\n  const tolerance = Math.max(0, options.tolerance ?? 1e-9);\r\n  const maxIterations = Math.max(1, Math.floor(options.maxIterations ?? 200));\r\n  const initialScore = 1 / totalNodes;\r\n\r\n  const outgoingWeightSum = new Map<NodeId, number>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    const totalWeight = (adjacency.neighborsByNode.get(nodeId) ?? []).reduce(\r\n      (sum, neighbor) => sum + neighbor.weight,\r\n      0,\r\n    );\r\n    outgoingWeightSum.set(nodeId, totalWeight);\r\n  }\r\n\r\n  let scores = new Map<NodeId, number>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    scores.set(nodeId, initialScore);\r\n  }\r\n\r\n  let iterations = 0;\r\n  let converged = false;\r\n\r\n  for (let iteration = 0; iteration < maxIterations; iteration += 1) {\r\n    iterations = iteration + 1;\r\n    const next = new Map<NodeId, number>();\r\n    const teleportMass = (1 - dampingFactor) / totalNodes;\r\n\r\n    let sinkMass = 0;\r\n    for (const nodeId of adjacency.nodes) {\r\n      const outgoingWeight = outgoingWeightSum.get(nodeId) ?? 0;\r\n      if (outgoingWeight <= 1e-12) {\r\n        sinkMass += scores.get(nodeId) ?? 0;\r\n      }\r\n      next.set(nodeId, teleportMass);\r\n    }\r\n\r\n    const sinkContribution = (dampingFactor * sinkMass) / totalNodes;\r\n    if (sinkContribution > 0) {\r\n      for (const nodeId of adjacency.nodes) {\r\n        next.set(nodeId, (next.get(nodeId) ?? 0) + sinkContribution);\r\n      }\r\n    }\r\n\r\n    for (const nodeId of adjacency.nodes) {\r\n      const outgoingWeight = outgoingWeightSum.get(nodeId) ?? 0;\r\n      if (outgoingWeight <= 1e-12) {\r\n        continue;\r\n      }\r\n\r\n      const score = scores.get(nodeId) ?? 0;\r\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n        const transfer = (dampingFactor * score * neighbor.weight) / outgoingWeight;\r\n        next.set(neighbor.id, (next.get(neighbor.id) ?? 0) + transfer);\r\n      }\r\n    }\r\n\r\n    let delta = 0;\r\n    for (const nodeId of adjacency.nodes) {\r\n      const previous = scores.get(nodeId) ?? 0;\r\n      const current = next.get(nodeId) ?? 0;\r\n      delta += Math.abs(previous - current);\r\n    }\r\n\r\n    scores = next;\r\n    if (delta <= tolerance) {\r\n      converged = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  let scoreSum = 0;\r\n  for (const nodeId of adjacency.nodes) {\r\n    scoreSum += scores.get(nodeId) ?? 0;\r\n  }\r\n\r\n  if (!Number.isFinite(scoreSum) || scoreSum <= 0) {\r\n    scores = new Map<NodeId, number>();\r\n    for (const nodeId of adjacency.nodes) {\r\n      scores.set(nodeId, initialScore);\r\n    }\r\n    scoreSum = 1;\r\n  } else if (Math.abs(scoreSum - 1) > 1e-12) {\r\n    for (const nodeId of adjacency.nodes) {\r\n      scores.set(nodeId, (scores.get(nodeId) ?? 0) / scoreSum);\r\n    }\r\n  }\r\n\r\n  const order = [...adjacency.nodes].sort((left, right) => {\r\n    const scoreDelta = (scores.get(right) ?? 0) - (scores.get(left) ?? 0);\r\n    if (Math.abs(scoreDelta) > 1e-12) {\r\n      return scoreDelta;\r\n    }\r\n    return defaultTieBreaker(left, right);\r\n  });\r\n\r\n  const maxScore = order.length > 0 ? (scores.get(order[0]!) ?? 0) : 0;\r\n  const byNode = new Map<NodeId, PageRankRecord>();\r\n  for (let index = 0; index < order.length; index += 1) {\r\n    const nodeId = order[index];\r\n    if (!nodeId) {\r\n      continue;\r\n    }\r\n    const score = scores.get(nodeId) ?? 0;\r\n    byNode.set(nodeId, {\r\n      score,\r\n      normalized: maxScore > 0 ? score / maxScore : 0,\r\n      rank: index + 1,\r\n    });\r\n  }\r\n\r\n  return {\r\n    byNode,\r\n    order,\r\n    iterations,\r\n    converged,\r\n    dampingFactor,\r\n  };\r\n}\r\n\r\nexport function minimumSpanningTree<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: MinimumSpanningTreeOptions<NodeId> = {},\r\n): MinimumSpanningTreeResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed: false });\r\n  const tieBreaker =\r\n    options.tieBreaker ??\r\n    ((left: NodeId, right: NodeId) => defaultTieBreaker(left, right));\r\n  const candidateByKey = new Map<string, Required<GraphEdge<NodeId>>>();\r\n\r\n  for (const edge of adjacency.edges) {\r\n    if (edge.from === edge.to) {\r\n      continue;\r\n    }\r\n    const canonical = canonicalUndirectedEdge(edge.from, edge.to);\r\n    const key = undirectedEdgeKey(canonical.from, canonical.to);\r\n    const existing = candidateByKey.get(key);\r\n    if (!existing || edge.weight < existing.weight - 1e-12) {\r\n      candidateByKey.set(key, {\r\n        from: canonical.from,\r\n        to: canonical.to,\r\n        weight: edge.weight,\r\n      });\r\n    }\r\n  }\r\n\r\n  const candidates = Array.from(candidateByKey.values());\r\n  candidates.sort((left, right) => {\r\n    const weightDelta = left.weight - right.weight;\r\n    if (Math.abs(weightDelta) > 1e-12) {\r\n      return weightDelta;\r\n    }\r\n\r\n    const fromDelta = tieBreaker(left.from, right.from);\r\n    if (fromDelta !== 0) {\r\n      return fromDelta;\r\n    }\r\n    return tieBreaker(left.to, right.to);\r\n  });\r\n\r\n  const disjointSet = new DisjointSet(adjacency.nodes);\r\n  const selected: Array<Required<GraphEdge<NodeId>>> = [];\r\n  let totalWeight = 0;\r\n\r\n  for (const edge of candidates) {\r\n    if (disjointSet.union(edge.from, edge.to)) {\r\n      selected.push(edge);\r\n      totalWeight += edge.weight;\r\n    }\r\n  }\r\n\r\n  const roots = new Set<NodeId>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    roots.add(disjointSet.find(nodeId));\r\n  }\r\n  const componentCount = roots.size;\r\n\r\n  return {\r\n    edges: selected,\r\n    totalWeight,\r\n    componentCount,\r\n    spanning:\r\n      adjacency.nodes.length <= 1 ||\r\n      (componentCount === 1 && selected.length === adjacency.nodes.length - 1),\r\n  };\r\n}\r\n\r\nexport function articulationPointsAndBridges<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n): ArticulationBridgeResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed: false });\r\n  const discoveredAt = new Map<NodeId, number>();\r\n  const lowLink = new Map<NodeId, number>();\r\n  const parentByNode = new Map<NodeId, NodeId | null>();\r\n  const articulationPoints = new Set<NodeId>();\r\n  const bridgeByKey = new Map<string, Required<GraphEdge<NodeId>>>();\r\n\r\n  let discoveryCounter = 0;\r\n\r\n  const visit = (nodeId: NodeId): void => {\r\n    discoveredAt.set(nodeId, discoveryCounter);\r\n    lowLink.set(nodeId, discoveryCounter);\r\n    discoveryCounter += 1;\r\n\r\n    let childCount = 0;\r\n    const parent = parentByNode.get(nodeId) ?? null;\r\n\r\n    for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n      const discoveredNeighbor = discoveredAt.get(neighbor.id);\r\n      if (discoveredNeighbor === undefined) {\r\n        parentByNode.set(neighbor.id, nodeId);\r\n        childCount += 1;\r\n        visit(neighbor.id);\r\n\r\n        const lowNode = lowLink.get(nodeId) ?? 0;\r\n        const lowNeighbor = lowLink.get(neighbor.id) ?? 0;\r\n        lowLink.set(nodeId, Math.min(lowNode, lowNeighbor));\r\n\r\n        const discoveredNode = discoveredAt.get(nodeId) ?? 0;\r\n        if (parent === null && childCount > 1) {\r\n          articulationPoints.add(nodeId);\r\n        }\r\n        if (parent !== null && lowNeighbor >= discoveredNode) {\r\n          articulationPoints.add(nodeId);\r\n        }\r\n        if (lowNeighbor > discoveredNode) {\r\n          const canonical = canonicalUndirectedEdge(nodeId, neighbor.id);\r\n          const key = undirectedEdgeKey(canonical.from, canonical.to);\r\n          const existing = bridgeByKey.get(key);\r\n          if (!existing || neighbor.weight < existing.weight - 1e-12) {\r\n            bridgeByKey.set(key, {\r\n              from: canonical.from,\r\n              to: canonical.to,\r\n              weight: neighbor.weight,\r\n            });\r\n          }\r\n        }\r\n      } else if (neighbor.id !== parent) {\r\n        const lowNode = lowLink.get(nodeId) ?? 0;\r\n        lowLink.set(nodeId, Math.min(lowNode, discoveredNeighbor));\r\n      }\r\n    }\r\n  };\r\n\r\n  for (const nodeId of adjacency.nodes) {\r\n    if (!discoveredAt.has(nodeId)) {\r\n      parentByNode.set(nodeId, null);\r\n      visit(nodeId);\r\n    }\r\n  }\r\n\r\n  const bridges = Array.from(bridgeByKey.values());\r\n  bridges.sort((left, right) => {\r\n    const fromDelta = defaultTieBreaker(left.from, right.from);\r\n    if (fromDelta !== 0) {\r\n      return fromDelta;\r\n    }\r\n\r\n    const toDelta = defaultTieBreaker(left.to, right.to);\r\n    if (toDelta !== 0) {\r\n      return toDelta;\r\n    }\r\n\r\n    return left.weight - right.weight;\r\n  });\r\n\r\n  return {\r\n    articulationPoints: Array.from(articulationPoints).sort(defaultTieBreaker),\r\n    bridges,\r\n  };\r\n}\r\n\r\nexport function analyzeGraph<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: GraphAnalysisOptions = {},\r\n): GraphAnalysisResult<NodeId> {\r\n  const scc = stronglyConnectedComponents(nodes, edges, options);\r\n  const weak = weaklyConnectedComponents(nodes, edges);\r\n  const articulation = articulationPointsAndBridges(nodes, edges);\r\n  const dedupedNodes = dedupeNodeList(nodes, edges);\r\n  const orderedNodeIds = [...dedupedNodes].sort(defaultTieBreaker);\r\n  let betweennessByNode = new Map<NodeId, BetweennessCentralityRecord>();\r\n  let pageRankByNode = new Map<NodeId, PageRankRecord>();\r\n\r\n  try {\r\n    betweennessByNode = betweennessCentrality(nodes, edges, options);\r\n  } catch (error) {\r\n    if (\r\n      !(error instanceof GraphAlgorithmError) ||\r\n      error.code !== 'NEGATIVE_WEIGHT'\r\n    ) {\r\n      throw error;\r\n    }\r\n\r\n    betweennessByNode = new Map<NodeId, BetweennessCentralityRecord>();\r\n    for (const nodeId of orderedNodeIds) {\r\n      betweennessByNode.set(nodeId, {\r\n        raw: 0,\r\n        normalized: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  try {\r\n    const pageRankResult = pageRank(nodes, edges, {\r\n      directed: options.directed ?? true,\r\n      ...(options.pageRankOptions ?? {}),\r\n    });\r\n    pageRankByNode = pageRankResult.byNode;\r\n  } catch (error) {\r\n    if (\r\n      !(error instanceof GraphAlgorithmError) ||\r\n      error.code !== 'NEGATIVE_WEIGHT'\r\n    ) {\r\n      throw error;\r\n    }\r\n\r\n    const defaultScore = dedupedNodes.length > 0 ? 1 / dedupedNodes.length : 0;\r\n    pageRankByNode = new Map<NodeId, PageRankRecord>();\r\n    for (let index = 0; index < orderedNodeIds.length; index += 1) {\r\n      const nodeId = orderedNodeIds[index];\r\n      if (!nodeId) {\r\n        continue;\r\n      }\r\n      pageRankByNode.set(nodeId, {\r\n        score: defaultScore,\r\n        normalized: 1,\r\n        rank: index + 1,\r\n      });\r\n    }\r\n  }\r\n\r\n  return {\r\n    degree: degreeCentrality(nodes, edges, options),\r\n    closeness: closenessCentrality(nodes, edges, {\r\n      ...options,\r\n      mode: options.closenessMode ?? 'harmonic',\r\n      shortestPathAlgorithm: options.shortestPathAlgorithm,\r\n    }),\r\n    betweenness: betweennessByNode,\r\n    pageRank: pageRankByNode,\r\n    stronglyConnectedComponents: scc.components,\r\n    weaklyConnectedComponents: weak.components,\r\n    articulationPoints: articulation.articulationPoints,\r\n    bridges: articulation.bridges,\r\n  };\r\n}\r\n\r\nexport function shortestPath<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  source: NodeId,\r\n  target: NodeId,\r\n  options: ShortestPathOptions = {},\r\n): ShortestPathResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n  if (\r\n    !adjacency.neighborsByNode.has(source) ||\r\n    !adjacency.neighborsByNode.has(target)\r\n  ) {\r\n    return {\r\n      source,\r\n      target,\r\n      path: [],\r\n      distance: Number.POSITIVE_INFINITY,\r\n      reachable: false,\r\n      explored: 0,\r\n      algorithm: options.algorithm ?? 'auto',\r\n      hasNegativeWeights: hasNegativeWeights(adjacency),\r\n      negativeCycle: false,\r\n    };\r\n  }\r\n\r\n  const engine = runShortestPathEngine(\r\n    adjacency,\r\n    source,\r\n    options.algorithm ?? 'auto',\r\n  );\r\n\r\n  if (engine.result.negativeCycleNodes.has(target)) {\r\n    if (options.failOnNegativeCycle ?? false) {\r\n      throw new GraphAlgorithmError(\r\n        'NEGATIVE_CYCLE',\r\n        `Negative cycle reaches target node \"${target}\".`,\r\n      );\r\n    }\r\n\r\n    return {\r\n      source,\r\n      target,\r\n      path: [],\r\n      distance: Number.NEGATIVE_INFINITY,\r\n      reachable: false,\r\n      explored: engine.result.explored,\r\n      algorithm: engine.algorithm,\r\n      hasNegativeWeights: engine.hasNegativeWeights,\r\n      negativeCycle: true,\r\n    };\r\n  }\r\n\r\n  const distance =\r\n    engine.result.distanceByNode.get(target) ?? Number.POSITIVE_INFINITY;\r\n  const reachable = Number.isFinite(distance);\r\n\r\n  const path = reachable\r\n    ? reconstructPath(source, target, engine.result.previousByNode)\r\n    : [];\r\n\r\n  return {\r\n    source,\r\n    target,\r\n    path,\r\n    distance,\r\n    reachable: reachable && path.length > 0,\r\n    explored: engine.result.explored,\r\n    algorithm: engine.algorithm,\r\n    hasNegativeWeights: engine.hasNegativeWeights,\r\n    negativeCycle: engine.result.negativeCycleNodes.size > 0,\r\n  };\r\n}\r\n\r\nexport function labelPropagationCommunities<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: LabelPropagationOptions<NodeId> = {},\r\n): CommunityDetectionResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, {\r\n    directed: options.directed ?? false,\r\n  });\r\n  if (hasNegativeWeights(adjacency)) {\r\n    throw new GraphAlgorithmError(\r\n      'NEGATIVE_WEIGHT',\r\n      'Label propagation requires non-negative graph weights.',\r\n    );\r\n  }\r\n\r\n  const tieBreaker =\r\n    options.tieBreaker ??\r\n    ((left: NodeId, right: NodeId) => defaultTieBreaker(left, right));\r\n  const nodeOrder = [...adjacency.nodes].sort(tieBreaker);\r\n  const labelByNode = new Map<NodeId, number>();\r\n  for (let index = 0; index < nodeOrder.length; index += 1) {\r\n    const nodeId = nodeOrder[index];\r\n    if (nodeId) {\r\n      labelByNode.set(nodeId, index);\r\n    }\r\n  }\r\n\r\n  const maxIterations = Math.max(1, options.maxIterations ?? 100);\r\n  let iterations = 0;\r\n  let converged = false;\r\n\r\n  for (let iteration = 0; iteration < maxIterations; iteration += 1) {\r\n    iterations = iteration + 1;\r\n    let changed = false;\r\n\r\n    for (const nodeId of nodeOrder) {\r\n      const neighbors = adjacency.neighborsByNode.get(nodeId) ?? [];\r\n      if (neighbors.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      const scoreByLabel = new Map<number, number>();\r\n      for (const neighbor of neighbors) {\r\n        const neighborLabel = labelByNode.get(neighbor.id);\r\n        if (neighborLabel === undefined) {\r\n          continue;\r\n        }\r\n        scoreByLabel.set(\r\n          neighborLabel,\r\n          (scoreByLabel.get(neighborLabel) ?? 0) + neighbor.weight,\r\n        );\r\n      }\r\n\r\n      const currentLabel = labelByNode.get(nodeId);\r\n      if (currentLabel === undefined || scoreByLabel.size === 0) {\r\n        continue;\r\n      }\r\n\r\n      let bestLabel = currentLabel;\r\n      let bestScore = Number.NEGATIVE_INFINITY;\r\n\r\n      for (const [candidateLabel, score] of scoreByLabel.entries()) {\r\n        if (score > bestScore + 1e-12) {\r\n          bestScore = score;\r\n          bestLabel = candidateLabel;\r\n          continue;\r\n        }\r\n        if (Math.abs(score - bestScore) <= 1e-12 && candidateLabel < bestLabel) {\r\n          bestLabel = candidateLabel;\r\n        }\r\n      }\r\n\r\n      if (bestLabel !== currentLabel) {\r\n        labelByNode.set(nodeId, bestLabel);\r\n        changed = true;\r\n      }\r\n    }\r\n\r\n    if (!changed) {\r\n      converged = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return buildCommunityResult(\r\n    adjacency,\r\n    labelByNode,\r\n    iterations,\r\n    converged,\r\n    'label-propagation',\r\n  );\r\n}\r\n\r\nexport function louvainCommunities<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: LouvainOptions<NodeId> = {},\r\n): CommunityDetectionResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, {\r\n    directed: options.directed ?? false,\r\n  });\r\n\r\n  if (hasNegativeWeights(adjacency)) {\r\n    throw new GraphAlgorithmError(\r\n      'NEGATIVE_WEIGHT',\r\n      'Louvain requires non-negative graph weights.',\r\n    );\r\n  }\r\n\r\n  const tieBreaker =\r\n    options.tieBreaker ??\r\n    ((left: NodeId, right: NodeId) => defaultTieBreaker(left, right));\r\n  const nodeOrder = [...adjacency.nodes].sort(tieBreaker);\r\n  const maxPasses = Math.max(1, options.maxPasses ?? 32);\r\n  const tolerance = Math.max(0, options.tolerance ?? 1e-9);\r\n\r\n  const degreeByNode = new Map<NodeId, number>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    degreeByNode.set(\r\n      nodeId,\r\n      sumNeighborWeights(adjacency.neighborsByNode.get(nodeId) ?? []),\r\n    );\r\n  }\r\n\r\n  let totalDegree = 0;\r\n  for (const degree of degreeByNode.values()) {\r\n    totalDegree += degree;\r\n  }\r\n\r\n  const labelByNode = new Map<NodeId, number>();\r\n  const communityWeight = new Map<number, number>();\r\n  for (let index = 0; index < nodeOrder.length; index += 1) {\r\n    const nodeId = nodeOrder[index];\r\n    if (!nodeId) {\r\n      continue;\r\n    }\r\n    labelByNode.set(nodeId, index);\r\n    const degree = degreeByNode.get(nodeId) ?? 0;\r\n    communityWeight.set(index, degree);\r\n  }\r\n\r\n  if (totalDegree <= 1e-12) {\r\n    return buildCommunityResult(adjacency, labelByNode, 0, true, 'louvain');\r\n  }\r\n\r\n  let iterations = 0;\r\n  let converged = false;\r\n\r\n  for (let pass = 0; pass < maxPasses; pass += 1) {\r\n    iterations = pass + 1;\r\n    let changed = false;\r\n\r\n    for (const nodeId of nodeOrder) {\r\n      const currentLabel = labelByNode.get(nodeId);\r\n      if (currentLabel === undefined) {\r\n        continue;\r\n      }\r\n\r\n      const nodeDegree = degreeByNode.get(nodeId) ?? 0;\r\n      communityWeight.set(\r\n        currentLabel,\r\n        (communityWeight.get(currentLabel) ?? 0) - nodeDegree,\r\n      );\r\n\r\n      const edgeWeightByCommunity = new Map<number, number>();\r\n      for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n        const candidateLabel = labelByNode.get(neighbor.id);\r\n        if (candidateLabel === undefined) {\r\n          continue;\r\n        }\r\n\r\n        edgeWeightByCommunity.set(\r\n          candidateLabel,\r\n          (edgeWeightByCommunity.get(candidateLabel) ?? 0) + neighbor.weight,\r\n        );\r\n      }\r\n\r\n      let bestLabel = currentLabel;\r\n      let bestGain = 0;\r\n\r\n      for (const [candidateLabel, edgeWeight] of edgeWeightByCommunity.entries()) {\r\n        const candidateWeight = communityWeight.get(candidateLabel) ?? 0;\r\n        const gain = edgeWeight - (candidateWeight * nodeDegree) / totalDegree;\r\n\r\n        if (gain > bestGain + tolerance) {\r\n          bestGain = gain;\r\n          bestLabel = candidateLabel;\r\n          continue;\r\n        }\r\n\r\n        if (\r\n          Math.abs(gain - bestGain) <= tolerance &&\r\n          candidateLabel < bestLabel\r\n        ) {\r\n          bestLabel = candidateLabel;\r\n        }\r\n      }\r\n\r\n      if (bestLabel !== currentLabel && bestGain > tolerance) {\r\n        labelByNode.set(nodeId, bestLabel);\r\n        communityWeight.set(\r\n          bestLabel,\r\n          (communityWeight.get(bestLabel) ?? 0) + nodeDegree,\r\n        );\r\n        changed = true;\r\n      } else {\r\n        communityWeight.set(\r\n          currentLabel,\r\n          (communityWeight.get(currentLabel) ?? 0) + nodeDegree,\r\n        );\r\n      }\r\n    }\r\n\r\n    if (!changed) {\r\n      converged = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return buildCommunityResult(\r\n    adjacency,\r\n    labelByNode,\r\n    iterations,\r\n    converged,\r\n    'louvain',\r\n  );\r\n}\r\n\r\nexport function nodeSimilarity<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: SimilarityOptions = {},\r\n): NodeSimilarityResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, {\r\n    directed: options.directed ?? false,\r\n  });\r\n  const metric = options.metric ?? 'jaccard';\r\n  const minScore = options.minScore ?? 0;\r\n  const neighborSets = buildNeighborIdSetMap(adjacency);\r\n  const orderedNodes = [...adjacency.nodes].sort(defaultTieBreaker);\r\n  const pairs: Array<Omit<NodeSimilarityRecord<NodeId>, 'rank'>> = [];\r\n\r\n  for (let leftIndex = 0; leftIndex < orderedNodes.length; leftIndex += 1) {\r\n    const leftId = orderedNodes[leftIndex];\r\n    if (!leftId) {\r\n      continue;\r\n    }\r\n    for (\r\n      let rightIndex = leftIndex + 1;\r\n      rightIndex < orderedNodes.length;\r\n      rightIndex += 1\r\n    ) {\r\n      const rightId = orderedNodes[rightIndex];\r\n      if (!rightId) {\r\n        continue;\r\n      }\r\n      const score = computeSimilarityScore(leftId, rightId, neighborSets, metric);\r\n      if (score < minScore - 1e-12) {\r\n        continue;\r\n      }\r\n      pairs.push({\r\n        left: leftId,\r\n        right: rightId,\r\n        score,\r\n        metric,\r\n      });\r\n    }\r\n  }\r\n\r\n  pairs.sort((left, right) => {\r\n    const scoreDelta = right.score - left.score;\r\n    if (Math.abs(scoreDelta) > 1e-12) {\r\n      return scoreDelta;\r\n    }\r\n    const leftDelta = defaultTieBreaker(left.left, right.left);\r\n    if (leftDelta !== 0) {\r\n      return leftDelta;\r\n    }\r\n    return defaultTieBreaker(left.right, right.right);\r\n  });\r\n\r\n  return {\r\n    metric,\r\n    pairs: pairs.map((pair, index) => ({\r\n      ...pair,\r\n      rank: index + 1,\r\n    })),\r\n  };\r\n}\r\n\r\nexport function kNearestNeighbors<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: KNearestNeighborsOptions = {},\r\n): KNearestNeighborsResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, {\r\n    directed: options.directed ?? false,\r\n  });\r\n  const metric = options.metric ?? 'jaccard';\r\n  const minScore = options.minScore ?? 0;\r\n  const k = Math.max(1, Math.floor(options.k ?? 5));\r\n  const neighborSets = buildNeighborIdSetMap(adjacency);\r\n  const orderedNodes = [...adjacency.nodes].sort(defaultTieBreaker);\r\n  const neighborsByNode = new Map<NodeId, KNearestNeighbor<NodeId>[]>();\r\n\r\n  for (const nodeId of orderedNodes) {\r\n    const candidates: KNearestNeighbor<NodeId>[] = [];\r\n    for (const otherId of orderedNodes) {\r\n      if (nodeId === otherId) {\r\n        continue;\r\n      }\r\n      const score = computeSimilarityScore(nodeId, otherId, neighborSets, metric);\r\n      if (score < minScore - 1e-12) {\r\n        continue;\r\n      }\r\n      candidates.push({\r\n        nodeId: otherId,\r\n        score,\r\n      });\r\n    }\r\n\r\n    candidates.sort((left, right) => {\r\n      const scoreDelta = right.score - left.score;\r\n      if (Math.abs(scoreDelta) > 1e-12) {\r\n        return scoreDelta;\r\n      }\r\n      return defaultTieBreaker(left.nodeId, right.nodeId);\r\n    });\r\n\r\n    neighborsByNode.set(nodeId, candidates.slice(0, k));\r\n  }\r\n\r\n  return {\r\n    metric,\r\n    k,\r\n    neighborsByNode,\r\n  };\r\n}\r\n\r\nexport function predictLinks<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: LinkPredictionOptions<NodeId> = {},\r\n): LinkPredictionResult<NodeId> {\r\n  const directed = options.directed ?? false;\r\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed });\r\n  const metric = options.metric ?? 'jaccard';\r\n  const minScore = options.minScore ?? 0;\r\n  const limit = Math.max(1, Math.floor(options.limit ?? 20));\r\n  const allowExistingEdges = options.allowExistingEdges ?? false;\r\n  const neighborSets = buildNeighborIdSetMap(adjacency);\r\n  const orderedNodes = [...adjacency.nodes].sort(defaultTieBreaker);\r\n  const sourceFilterSet = options.sourceFilter\r\n    ? new Set(options.sourceFilter)\r\n    : null;\r\n  const targetFilterSet = options.targetFilter\r\n    ? new Set(options.targetFilter)\r\n    : null;\r\n  const existingEdgeKeys = new Set<string>();\r\n\r\n  for (const edge of adjacency.edges) {\r\n    if (directed) {\r\n      existingEdgeKeys.add(`${edge.from}\\u0000${edge.to}`);\r\n    } else {\r\n      existingEdgeKeys.add(undirectedEdgeKey(edge.from, edge.to));\r\n    }\r\n  }\r\n\r\n  const predictions: Array<Omit<LinkPredictionRecord<NodeId>, 'rank'>> = [];\r\n\r\n  if (directed) {\r\n    for (const fromId of orderedNodes) {\r\n      if (sourceFilterSet && !sourceFilterSet.has(fromId)) {\r\n        continue;\r\n      }\r\n      for (const toId of orderedNodes) {\r\n        if (fromId === toId) {\r\n          continue;\r\n        }\r\n        if (targetFilterSet && !targetFilterSet.has(toId)) {\r\n          continue;\r\n        }\r\n        if (\r\n          !allowExistingEdges &&\r\n          existingEdgeKeys.has(`${fromId}\\u0000${toId}`)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        const score = computeSimilarityScore(fromId, toId, neighborSets, metric);\r\n        if (score < minScore - 1e-12) {\r\n          continue;\r\n        }\r\n        predictions.push({\r\n          from: fromId,\r\n          to: toId,\r\n          score,\r\n          metric,\r\n        });\r\n      }\r\n    }\r\n  } else {\r\n    for (let leftIndex = 0; leftIndex < orderedNodes.length; leftIndex += 1) {\r\n      const fromId = orderedNodes[leftIndex];\r\n      if (!fromId) {\r\n        continue;\r\n      }\r\n      for (\r\n        let rightIndex = leftIndex + 1;\r\n        rightIndex < orderedNodes.length;\r\n        rightIndex += 1\r\n      ) {\r\n        const toId = orderedNodes[rightIndex];\r\n        if (!toId) {\r\n          continue;\r\n        }\r\n\r\n        if (\r\n          sourceFilterSet &&\r\n          !sourceFilterSet.has(fromId) &&\r\n          !sourceFilterSet.has(toId)\r\n        ) {\r\n          continue;\r\n        }\r\n        if (\r\n          targetFilterSet &&\r\n          !targetFilterSet.has(fromId) &&\r\n          !targetFilterSet.has(toId)\r\n        ) {\r\n          continue;\r\n        }\r\n        if (\r\n          !allowExistingEdges &&\r\n          existingEdgeKeys.has(undirectedEdgeKey(fromId, toId))\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        const score = computeSimilarityScore(fromId, toId, neighborSets, metric);\r\n        if (score < minScore - 1e-12) {\r\n          continue;\r\n        }\r\n        predictions.push({\r\n          from: fromId,\r\n          to: toId,\r\n          score,\r\n          metric,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  predictions.sort((left, right) => {\r\n    const scoreDelta = right.score - left.score;\r\n    if (Math.abs(scoreDelta) > 1e-12) {\r\n      return scoreDelta;\r\n    }\r\n    const fromDelta = defaultTieBreaker(left.from, right.from);\r\n    if (fromDelta !== 0) {\r\n      return fromDelta;\r\n    }\r\n    return defaultTieBreaker(left.to, right.to);\r\n  });\r\n\r\n  return {\r\n    metric,\r\n    predictions: predictions.slice(0, limit).map((prediction, index) => ({\r\n      ...prediction,\r\n      rank: index + 1,\r\n    })),\r\n  };\r\n}\r\n\r\nexport function linkPrediction<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: LinkPredictionOptions<NodeId> = {},\r\n): LinkPredictionResult<NodeId> {\r\n  return predictLinks(nodes, edges, options);\r\n}\r\n\r\nexport function aStarShortestPath<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  source: NodeId,\r\n  target: NodeId,\r\n  options: AStarOptions<NodeId> = {},\r\n): AStarResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n  if (hasNegativeWeights(adjacency)) {\r\n    throw new GraphAlgorithmError(\r\n      'NEGATIVE_WEIGHT',\r\n      'A* requires non-negative graph weights.',\r\n    );\r\n  }\r\n\r\n  if (\r\n    !adjacency.neighborsByNode.has(source) ||\r\n    !adjacency.neighborsByNode.has(target)\r\n  ) {\r\n    return {\r\n      source,\r\n      target,\r\n      path: [],\r\n      distance: Number.POSITIVE_INFINITY,\r\n      reachable: false,\r\n      explored: 0,\r\n      estimatedDistance: Number.POSITIVE_INFINITY,\r\n    };\r\n  }\r\n\r\n  const heuristic =\r\n    options.heuristic ??\r\n    ((_nodeId: NodeId, _targetId: NodeId): number => 0);\r\n\r\n  const queue = new MinPriorityQueue<NodeId>();\r\n  const gScore = new Map<NodeId, number>();\r\n  const previousByNode = new Map<NodeId, NodeId>();\r\n  const closedSet = new Set<NodeId>();\r\n\r\n  for (const nodeId of adjacency.nodes) {\r\n    gScore.set(nodeId, Number.POSITIVE_INFINITY);\r\n  }\r\n\r\n  gScore.set(source, 0);\r\n  const startHeuristic = heuristic(source, target);\r\n  if (!Number.isFinite(startHeuristic)) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'A* heuristic must return finite values.',\r\n    );\r\n  }\r\n  queue.push(source, startHeuristic);\r\n\r\n  let explored = 0;\r\n\r\n  while (queue.size > 0) {\r\n    const item = queue.pop();\r\n    if (!item) {\r\n      break;\r\n    }\r\n\r\n    const nodeId = item.value;\r\n    if (closedSet.has(nodeId)) {\r\n      continue;\r\n    }\r\n    closedSet.add(nodeId);\r\n    explored += 1;\r\n\r\n    if (nodeId === target) {\r\n      break;\r\n    }\r\n\r\n    const currentDistance = gScore.get(nodeId);\r\n    if (currentDistance === undefined || !Number.isFinite(currentDistance)) {\r\n      continue;\r\n    }\r\n\r\n    for (const neighbor of adjacency.neighborsByNode.get(nodeId) ?? []) {\r\n      const candidate = currentDistance + neighbor.weight;\r\n      const known = gScore.get(neighbor.id) ?? Number.POSITIVE_INFINITY;\r\n      if (candidate >= known - 1e-12) {\r\n        continue;\r\n      }\r\n\r\n      const estimate = heuristic(neighbor.id, target);\r\n      if (!Number.isFinite(estimate)) {\r\n        throw new GraphAlgorithmError(\r\n          'INVALID_ARGUMENT',\r\n          'A* heuristic must return finite values.',\r\n        );\r\n      }\r\n\r\n      gScore.set(neighbor.id, candidate);\r\n      previousByNode.set(neighbor.id, nodeId);\r\n      queue.push(neighbor.id, candidate + estimate);\r\n    }\r\n  }\r\n\r\n  const distance = gScore.get(target) ?? Number.POSITIVE_INFINITY;\r\n  const reachable = Number.isFinite(distance);\r\n  const path = reachable ? reconstructPath(source, target, previousByNode) : [];\r\n\r\n  return {\r\n    source,\r\n    target,\r\n    path,\r\n    distance,\r\n    reachable: reachable && path.length > 0,\r\n    explored,\r\n    estimatedDistance: distance,\r\n  };\r\n}\r\n\r\nexport function allPairsShortestPaths<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: AllPairsShortestPathsOptions = {},\r\n): AllPairsShortestPathsResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n  const requestedAlgorithm = options.algorithm ?? 'auto';\r\n  const chosenAlgorithm = chooseShortestPathAlgorithm(\r\n    requestedAlgorithm,\r\n    hasNegativeWeights(adjacency),\r\n  );\r\n\r\n  const distanceBySource = new Map<NodeId, Map<NodeId, number>>();\r\n  const previousBySource = new Map<NodeId, Map<NodeId, NodeId>>();\r\n  let negativeCycle = false;\r\n\r\n  for (const source of adjacency.nodes) {\r\n    const engine = runShortestPathEngine(adjacency, source, chosenAlgorithm);\r\n    if (engine.result.negativeCycleNodes.size > 0) {\r\n      negativeCycle = true;\r\n      if (options.failOnNegativeCycle ?? false) {\r\n        throw new GraphAlgorithmError(\r\n          'NEGATIVE_CYCLE',\r\n          `Negative cycle reaches source node \"${source}\".`,\r\n        );\r\n      }\r\n    }\r\n\r\n    const distance = new Map<NodeId, number>();\r\n    const previous = new Map<NodeId, NodeId>();\r\n    for (const nodeId of adjacency.nodes) {\r\n      distance.set(\r\n        nodeId,\r\n        engine.result.distanceByNode.get(nodeId) ?? Number.POSITIVE_INFINITY,\r\n      );\r\n      const prev = engine.result.previousByNode.get(nodeId);\r\n      if (prev) {\r\n        previous.set(nodeId, prev);\r\n      }\r\n    }\r\n\r\n    distanceBySource.set(source, distance);\r\n    previousBySource.set(source, previous);\r\n  }\r\n\r\n  return {\r\n    nodes: adjacency.nodes,\r\n    distanceBySource,\r\n    previousBySource,\r\n    algorithm: chosenAlgorithm,\r\n    hasNegativeWeights: hasNegativeWeights(adjacency),\r\n    negativeCycle,\r\n  };\r\n}\r\n\r\nexport function yenKShortestPaths<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  source: NodeId,\r\n  target: NodeId,\r\n  options: YenKShortestPathsOptions = {},\r\n): YenKShortestPathsResult<NodeId> {\r\n  const directed = options.directed ?? true;\r\n  const k = Math.max(1, Math.floor(options.k ?? 3));\r\n  const shortestPathAlgorithm = options.shortestPathAlgorithm ?? 'auto';\r\n  const adjacency = buildGraphAdjacency(nodes, edges, { directed });\r\n\r\n  if (\r\n    !adjacency.neighborsByNode.has(source) ||\r\n    !adjacency.neighborsByNode.has(target)\r\n  ) {\r\n    return {\r\n      source,\r\n      target,\r\n      paths: [],\r\n      complete: false,\r\n    };\r\n  }\r\n\r\n  const first = shortestPath(adjacency.nodes, adjacency.edges, source, target, {\r\n    directed,\r\n    algorithm: shortestPathAlgorithm,\r\n  });\r\n  if (!first.reachable || first.path.length === 0) {\r\n    return {\r\n      source,\r\n      target,\r\n      paths: [],\r\n      complete: false,\r\n    };\r\n  }\r\n\r\n  const accepted: PathRecord<NodeId>[] = [\r\n    {\r\n      path: first.path,\r\n      distance: first.distance,\r\n    },\r\n  ];\r\n  const candidates = new Map<string, PathRecord<NodeId>>();\r\n\r\n  for (let pathIndex = 1; pathIndex < k; pathIndex += 1) {\r\n    const previous = accepted[pathIndex - 1]?.path ?? [];\r\n    if (previous.length < 2) {\r\n      break;\r\n    }\r\n\r\n    for (let spurIndex = 0; spurIndex < previous.length - 1; spurIndex += 1) {\r\n      const spurNode = previous[spurIndex];\r\n      if (!spurNode) {\r\n        continue;\r\n      }\r\n\r\n      const rootPath = previous.slice(0, spurIndex + 1);\r\n      const rootNodeExclusion = new Set(rootPath.slice(0, -1));\r\n      const removedEdgeKeys = new Set<string>();\r\n\r\n      for (const pathRecord of accepted) {\r\n        if (\r\n          pathRecord.path.length > spurIndex + 1 &&\r\n          hasSamePrefix(pathRecord.path, rootPath)\r\n        ) {\r\n          const fromId = pathRecord.path[spurIndex];\r\n          const toId = pathRecord.path[spurIndex + 1];\r\n          if (fromId && toId) {\r\n            removedEdgeKeys.add(`${fromId}\\u0000${toId}`);\r\n          }\r\n        }\r\n      }\r\n\r\n      const filteredEdges = adjacency.edges.filter((edge) => {\r\n        if (removedEdgeKeys.has(`${edge.from}\\u0000${edge.to}`)) {\r\n          return false;\r\n        }\r\n        if (rootNodeExclusion.has(edge.from) || rootNodeExclusion.has(edge.to)) {\r\n          return false;\r\n        }\r\n        return true;\r\n      });\r\n\r\n      const spurPath = shortestPath(\r\n        adjacency.nodes,\r\n        filteredEdges,\r\n        spurNode,\r\n        target,\r\n        {\r\n          directed,\r\n          algorithm: shortestPathAlgorithm,\r\n        },\r\n      );\r\n\r\n      if (!spurPath.reachable || spurPath.path.length === 0) {\r\n        continue;\r\n      }\r\n\r\n      const totalPath = rootPath.slice(0, -1).concat(spurPath.path);\r\n      const totalDistance = routeDistanceForPath(totalPath, adjacency);\r\n      if (!Number.isFinite(totalDistance)) {\r\n        continue;\r\n      }\r\n\r\n      const key = pathKey(totalPath);\r\n      if (!candidates.has(key)) {\r\n        candidates.set(key, {\r\n          path: totalPath,\r\n          distance: totalDistance,\r\n        });\r\n      }\r\n    }\r\n\r\n    if (candidates.size === 0) {\r\n      break;\r\n    }\r\n\r\n    const next = Array.from(candidates.values()).sort((left, right) => {\r\n      const distanceDelta = left.distance - right.distance;\r\n      if (Math.abs(distanceDelta) > 1e-12) {\r\n        return distanceDelta;\r\n      }\r\n      return defaultTieBreaker(pathKey(left.path), pathKey(right.path));\r\n    })[0];\r\n\r\n    if (!next) {\r\n      break;\r\n    }\r\n\r\n    accepted.push(next);\r\n    candidates.delete(pathKey(next.path));\r\n  }\r\n\r\n  return {\r\n    source,\r\n    target,\r\n    paths: accepted,\r\n    complete: accepted.length >= k,\r\n  };\r\n}\r\n\r\nexport function maximumFlow<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  source: NodeId,\r\n  sink: NodeId,\r\n  options: MaximumFlowOptions = {},\r\n): MaximumFlowResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n  if (\r\n    !adjacency.neighborsByNode.has(source) ||\r\n    !adjacency.neighborsByNode.has(sink)\r\n  ) {\r\n    return {\r\n      source,\r\n      sink,\r\n      maxFlow: 0,\r\n      augmentations: 0,\r\n      flowByEdge: [],\r\n      sourcePartition: [],\r\n      sinkPartition: [],\r\n      cutEdges: [],\r\n    };\r\n  }\r\n\r\n  const originalEdges: Array<Required<GraphEdge<NodeId>>> = [];\r\n  for (const edge of adjacency.edges) {\r\n    if (edge.weight < 0) {\r\n      throw new GraphAlgorithmError(\r\n        'NEGATIVE_WEIGHT',\r\n        'Maximum flow requires non-negative capacities.',\r\n      );\r\n    }\r\n    originalEdges.push(edge);\r\n  }\r\n\r\n  interface ResidualEdge {\r\n    to: NodeId;\r\n    reverseIndex: number;\r\n    capacity: number;\r\n    originalIndex: number | null;\r\n  }\r\n\r\n  const residual = new Map<NodeId, ResidualEdge[]>();\r\n  for (const nodeId of adjacency.nodes) {\r\n    residual.set(nodeId, []);\r\n  }\r\n\r\n  const addResidualEdge = (\r\n    from: NodeId,\r\n    to: NodeId,\r\n    capacity: number,\r\n    originalIndex: number,\r\n  ): void => {\r\n    const fromEdges = residual.get(from);\r\n    const toEdges = residual.get(to);\r\n    if (!fromEdges || !toEdges) {\r\n      return;\r\n    }\r\n\r\n    const forwardIndex = fromEdges.length;\r\n    const reverseIndex = toEdges.length;\r\n    fromEdges.push({\r\n      to,\r\n      reverseIndex,\r\n      capacity,\r\n      originalIndex,\r\n    });\r\n    toEdges.push({\r\n      to: from,\r\n      reverseIndex: forwardIndex,\r\n      capacity: 0,\r\n      originalIndex: null,\r\n    });\r\n  };\r\n\r\n  for (let index = 0; index < originalEdges.length; index += 1) {\r\n    const edge = originalEdges[index];\r\n    if (!edge) {\r\n      continue;\r\n    }\r\n    addResidualEdge(edge.from, edge.to, edge.weight, index);\r\n  }\r\n\r\n  let maxFlow = 0;\r\n  let augmentations = 0;\r\n  const flowByOriginal = new Array<number>(originalEdges.length).fill(0);\r\n\r\n  while (true) {\r\n    const parent = new Map<NodeId, { from: NodeId; edgeIndex: number }>();\r\n    const queue: NodeId[] = [source];\r\n    parent.set(source, { from: source, edgeIndex: -1 });\r\n\r\n    let queueIndex = 0;\r\n    while (queueIndex < queue.length && !parent.has(sink)) {\r\n      const nodeId = queue[queueIndex];\r\n      queueIndex += 1;\r\n      if (!nodeId) {\r\n        continue;\r\n      }\r\n\r\n      const edgesFromNode = residual.get(nodeId) ?? [];\r\n      for (let edgeIndex = 0; edgeIndex < edgesFromNode.length; edgeIndex += 1) {\r\n        const edge = edgesFromNode[edgeIndex];\r\n        if (!edge || edge.capacity <= 1e-12) {\r\n          continue;\r\n        }\r\n        if (parent.has(edge.to)) {\r\n          continue;\r\n        }\r\n\r\n        parent.set(edge.to, { from: nodeId, edgeIndex });\r\n        queue.push(edge.to);\r\n      }\r\n    }\r\n\r\n    if (!parent.has(sink)) {\r\n      break;\r\n    }\r\n\r\n    let bottleneck = Number.POSITIVE_INFINITY;\r\n    let cursor: NodeId = sink;\r\n\r\n    while (cursor !== source) {\r\n      const parentEntry = parent.get(cursor);\r\n      if (!parentEntry) {\r\n        bottleneck = 0;\r\n        break;\r\n      }\r\n      const edge = residual.get(parentEntry.from)?.[parentEntry.edgeIndex];\r\n      if (!edge) {\r\n        bottleneck = 0;\r\n        break;\r\n      }\r\n      bottleneck = Math.min(bottleneck, edge.capacity);\r\n      cursor = parentEntry.from;\r\n    }\r\n\r\n    if (!Number.isFinite(bottleneck) || bottleneck <= 1e-12) {\r\n      break;\r\n    }\r\n\r\n    cursor = sink;\r\n    while (cursor !== source) {\r\n      const parentEntry = parent.get(cursor);\r\n      if (!parentEntry) {\r\n        break;\r\n      }\r\n      const edge = residual.get(parentEntry.from)?.[parentEntry.edgeIndex];\r\n      const reverse = edge\r\n        ? residual.get(edge.to)?.[edge.reverseIndex]\r\n        : undefined;\r\n      if (!edge || !reverse) {\r\n        break;\r\n      }\r\n\r\n      edge.capacity -= bottleneck;\r\n      reverse.capacity += bottleneck;\r\n\r\n      if (edge.originalIndex !== null) {\r\n        flowByOriginal[edge.originalIndex] =\r\n          (flowByOriginal[edge.originalIndex] ?? 0) + bottleneck;\r\n      } else if (reverse.originalIndex !== null) {\r\n        flowByOriginal[reverse.originalIndex] =\r\n          (flowByOriginal[reverse.originalIndex] ?? 0) - bottleneck;\r\n      }\r\n\r\n      cursor = parentEntry.from;\r\n    }\r\n\r\n    maxFlow += bottleneck;\r\n    augmentations += 1;\r\n  }\r\n\r\n  const reachableFromSource = new Set<NodeId>();\r\n  const partitionQueue: NodeId[] = [source];\r\n  reachableFromSource.add(source);\r\n  let partitionCursor = 0;\r\n\r\n  while (partitionCursor < partitionQueue.length) {\r\n    const nodeId = partitionQueue[partitionCursor];\r\n    partitionCursor += 1;\r\n    if (!nodeId) {\r\n      continue;\r\n    }\r\n\r\n    for (const edge of residual.get(nodeId) ?? []) {\r\n      if (edge.capacity <= 1e-12 || reachableFromSource.has(edge.to)) {\r\n        continue;\r\n      }\r\n      reachableFromSource.add(edge.to);\r\n      partitionQueue.push(edge.to);\r\n    }\r\n  }\r\n\r\n  const sourcePartition = adjacency.nodes\r\n    .filter((nodeId) => reachableFromSource.has(nodeId))\r\n    .sort(defaultTieBreaker);\r\n  const sinkPartition = adjacency.nodes\r\n    .filter((nodeId) => !reachableFromSource.has(nodeId))\r\n    .sort(defaultTieBreaker);\r\n\r\n  const cutEdges = originalEdges\r\n    .filter(\r\n      (edge) =>\r\n        reachableFromSource.has(edge.from) && !reachableFromSource.has(edge.to),\r\n    )\r\n    .sort((left, right) => {\r\n      const fromDelta = defaultTieBreaker(left.from, right.from);\r\n      if (fromDelta !== 0) {\r\n        return fromDelta;\r\n      }\r\n      return defaultTieBreaker(left.to, right.to);\r\n    });\r\n\r\n  const flowByEdge = originalEdges\r\n    .map((edge, index) => ({\r\n      from: edge.from,\r\n      to: edge.to,\r\n      flow: Math.max(0, flowByOriginal[index] ?? 0),\r\n      capacity: edge.weight,\r\n    }))\r\n    .sort((left, right) => {\r\n      const fromDelta = defaultTieBreaker(left.from, right.from);\r\n      if (fromDelta !== 0) {\r\n        return fromDelta;\r\n      }\r\n      return defaultTieBreaker(left.to, right.to);\r\n    });\r\n\r\n  return {\r\n    source,\r\n    sink,\r\n    maxFlow,\r\n    augmentations,\r\n    flowByEdge,\r\n    sourcePartition,\r\n    sinkPartition,\r\n    cutEdges,\r\n  };\r\n}\r\n\r\nexport function minCostMaxFlow<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: FlowEdge<NodeId>[],\r\n  source: NodeId,\r\n  sink: NodeId,\r\n  options: MinCostMaxFlowOptions = {},\r\n): MinCostMaxFlowResult<NodeId> {\r\n  const edgeProjection: GraphEdge<NodeId>[] = edges.map((edge) => ({\r\n    from: edge.from,\r\n    to: edge.to,\r\n    weight: edge.capacity,\r\n  }));\r\n  const nodeIds = dedupeNodeList(nodes, edgeProjection);\r\n  const directed = options.directed ?? true;\r\n\r\n  if (!nodeIds.includes(source) || !nodeIds.includes(sink)) {\r\n    return {\r\n      source,\r\n      sink,\r\n      flow: 0,\r\n      cost: 0,\r\n      complete: false,\r\n      augmentations: 0,\r\n      flowByEdge: [],\r\n    };\r\n  }\r\n\r\n  interface ResidualCostEdge {\r\n    to: NodeId;\r\n    reverseIndex: number;\r\n    capacity: number;\r\n    cost: number;\r\n    originalIndex: number | null;\r\n  }\r\n\r\n  interface OriginalCostEdge {\r\n    from: NodeId;\r\n    to: NodeId;\r\n    capacity: number;\r\n    cost: number;\r\n  }\r\n\r\n  const originals: OriginalCostEdge[] = [];\r\n  for (const edge of edges) {\r\n    if (!Number.isFinite(edge.capacity) || edge.capacity < 0) {\r\n      throw new GraphAlgorithmError(\r\n        'INVALID_ARGUMENT',\r\n        `Flow edge capacity must be non-negative and finite, received ${edge.capacity}.`,\r\n      );\r\n    }\r\n    const cost = edge.cost ?? 0;\r\n    if (!Number.isFinite(cost)) {\r\n      throw new GraphAlgorithmError(\r\n        'INVALID_ARGUMENT',\r\n        `Flow edge cost must be finite, received ${cost}.`,\r\n      );\r\n    }\r\n\r\n    originals.push({\r\n      from: edge.from,\r\n      to: edge.to,\r\n      capacity: edge.capacity,\r\n      cost,\r\n    });\r\n\r\n    if (!directed) {\r\n      originals.push({\r\n        from: edge.to,\r\n        to: edge.from,\r\n        capacity: edge.capacity,\r\n        cost,\r\n      });\r\n    }\r\n  }\r\n\r\n  const residual = new Map<NodeId, ResidualCostEdge[]>();\r\n  for (const nodeId of nodeIds) {\r\n    residual.set(nodeId, []);\r\n  }\r\n\r\n  const addResidualEdge = (\r\n    from: NodeId,\r\n    to: NodeId,\r\n    capacity: number,\r\n    cost: number,\r\n    originalIndex: number,\r\n  ): void => {\r\n    const fromEdges = residual.get(from);\r\n    const toEdges = residual.get(to);\r\n    if (!fromEdges || !toEdges) {\r\n      return;\r\n    }\r\n\r\n    const forwardIndex = fromEdges.length;\r\n    const reverseIndex = toEdges.length;\r\n    fromEdges.push({\r\n      to,\r\n      reverseIndex,\r\n      capacity,\r\n      cost,\r\n      originalIndex,\r\n    });\r\n    toEdges.push({\r\n      to: from,\r\n      reverseIndex: forwardIndex,\r\n      capacity: 0,\r\n      cost: -cost,\r\n      originalIndex: null,\r\n    });\r\n  };\r\n\r\n  for (let index = 0; index < originals.length; index += 1) {\r\n    const edge = originals[index];\r\n    if (!edge) {\r\n      continue;\r\n    }\r\n    addResidualEdge(edge.from, edge.to, edge.capacity, edge.cost, index);\r\n  }\r\n\r\n  const targetFlowRaw = options.targetFlow;\r\n  const targetFlow =\r\n    targetFlowRaw === undefined ? Number.POSITIVE_INFINITY : targetFlowRaw;\r\n  if (!Number.isFinite(targetFlow) && targetFlow !== Number.POSITIVE_INFINITY) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      `targetFlow must be finite or omitted, received ${targetFlow}.`,\r\n    );\r\n  }\r\n  if (targetFlow < 0) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      `targetFlow must be non-negative, received ${targetFlow}.`,\r\n    );\r\n  }\r\n\r\n  let flow = 0;\r\n  let cost = 0;\r\n  let augmentations = 0;\r\n  const flowByOriginal = new Array<number>(originals.length).fill(0);\r\n\r\n  while (flow < targetFlow - 1e-12) {\r\n    const distance = new Map<NodeId, number>();\r\n    const parent = new Map<NodeId, { from: NodeId; edgeIndex: number }>();\r\n\r\n    for (const nodeId of nodeIds) {\r\n      distance.set(nodeId, Number.POSITIVE_INFINITY);\r\n    }\r\n    distance.set(source, 0);\r\n\r\n    for (let iteration = 0; iteration < nodeIds.length - 1; iteration += 1) {\r\n      let changed = false;\r\n      for (const nodeId of nodeIds) {\r\n        const currentDistance = distance.get(nodeId);\r\n        if (currentDistance === undefined || !Number.isFinite(currentDistance)) {\r\n          continue;\r\n        }\r\n\r\n        const edgesFromNode = residual.get(nodeId) ?? [];\r\n        for (\r\n          let edgeIndex = 0;\r\n          edgeIndex < edgesFromNode.length;\r\n          edgeIndex += 1\r\n        ) {\r\n          const edge = edgesFromNode[edgeIndex];\r\n          if (!edge || edge.capacity <= 1e-12) {\r\n            continue;\r\n          }\r\n\r\n          const candidateDistance = currentDistance + edge.cost;\r\n          const knownDistance =\r\n            distance.get(edge.to) ?? Number.POSITIVE_INFINITY;\r\n\r\n          if (candidateDistance < knownDistance - 1e-12) {\r\n            distance.set(edge.to, candidateDistance);\r\n            parent.set(edge.to, { from: nodeId, edgeIndex });\r\n            changed = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!changed) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    const sinkDistance = distance.get(sink) ?? Number.POSITIVE_INFINITY;\r\n    if (!Number.isFinite(sinkDistance)) {\r\n      break;\r\n    }\r\n\r\n    let bottleneck = Math.min(targetFlow - flow, Number.POSITIVE_INFINITY);\r\n    let cursor: NodeId = sink;\r\n\r\n    while (cursor !== source) {\r\n      const parentEntry = parent.get(cursor);\r\n      if (!parentEntry) {\r\n        bottleneck = 0;\r\n        break;\r\n      }\r\n      const edge = residual.get(parentEntry.from)?.[parentEntry.edgeIndex];\r\n      if (!edge) {\r\n        bottleneck = 0;\r\n        break;\r\n      }\r\n      bottleneck = Math.min(bottleneck, edge.capacity);\r\n      cursor = parentEntry.from;\r\n    }\r\n\r\n    if (!Number.isFinite(bottleneck) || bottleneck <= 1e-12) {\r\n      break;\r\n    }\r\n\r\n    cursor = sink;\r\n    while (cursor !== source) {\r\n      const parentEntry = parent.get(cursor);\r\n      if (!parentEntry) {\r\n        break;\r\n      }\r\n      const edge = residual.get(parentEntry.from)?.[parentEntry.edgeIndex];\r\n      const reverse = edge\r\n        ? residual.get(edge.to)?.[edge.reverseIndex]\r\n        : undefined;\r\n      if (!edge || !reverse) {\r\n        break;\r\n      }\r\n\r\n      edge.capacity -= bottleneck;\r\n      reverse.capacity += bottleneck;\r\n\r\n      if (edge.originalIndex !== null) {\r\n        flowByOriginal[edge.originalIndex] =\r\n          (flowByOriginal[edge.originalIndex] ?? 0) + bottleneck;\r\n      } else if (reverse.originalIndex !== null) {\r\n        flowByOriginal[reverse.originalIndex] =\r\n          (flowByOriginal[reverse.originalIndex] ?? 0) - bottleneck;\r\n      }\r\n\r\n      cursor = parentEntry.from;\r\n    }\r\n\r\n    flow += bottleneck;\r\n    cost += bottleneck * sinkDistance;\r\n    augmentations += 1;\r\n  }\r\n\r\n  const flowByEdge = originals\r\n    .map((edge, index) => ({\r\n      from: edge.from,\r\n      to: edge.to,\r\n      flow: Math.max(0, flowByOriginal[index] ?? 0),\r\n      capacity: edge.capacity,\r\n      cost: edge.cost,\r\n    }))\r\n    .sort((left, right) => {\r\n      const fromDelta = defaultTieBreaker(left.from, right.from);\r\n      if (fromDelta !== 0) {\r\n        return fromDelta;\r\n      }\r\n      return defaultTieBreaker(left.to, right.to);\r\n    });\r\n\r\n  return {\r\n    source,\r\n    sink,\r\n    flow,\r\n    cost,\r\n    complete:\r\n      targetFlow === Number.POSITIVE_INFINITY\r\n        ? true\r\n        : flow >= targetFlow - 1e-12,\r\n    augmentations,\r\n    flowByEdge,\r\n  };\r\n}\r\n\r\nexport function kMeansClustering(\r\n  points: number[][],\r\n  k: number,\r\n  options: KMeansOptions = {},\r\n): KMeansResult {\r\n  if (!Array.isArray(points) || points.length === 0) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'kMeansClustering requires at least one point.',\r\n    );\r\n  }\r\n\r\n  const dimensionality = points[0]?.length ?? 0;\r\n  if (dimensionality === 0) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'kMeansClustering requires points with at least one axis.',\r\n    );\r\n  }\r\n\r\n  for (const point of points) {\r\n    if (point.length !== dimensionality) {\r\n      throw new GraphAlgorithmError(\r\n        'INVALID_ARGUMENT',\r\n        'kMeansClustering requires all points to share dimensionality.',\r\n      );\r\n    }\r\n  }\r\n\r\n  const clusterCount = Math.max(1, Math.min(points.length, Math.floor(k)));\r\n  const maxIterations = Math.max(1, options.maxIterations ?? 120);\r\n  const tolerance = Math.max(0, options.tolerance ?? 1e-5);\r\n  const nInit = Math.max(1, options.nInit ?? 8);\r\n  const normalization = options.normalization ?? 'zscore';\r\n  const useKMeansPlusPlus = options.useKMeansPlusPlus ?? true;\r\n  const baseSeed =\r\n    options.seed === undefined || !Number.isFinite(options.seed)\r\n      ? Math.floor(Math.random() * 0xffffffff)\r\n      : Math.floor(options.seed);\r\n\r\n  const transform = normalizePoints(points, normalization);\r\n  const normalizedPoints = points.map((point) => transform.normalize(point));\r\n\r\n  let best: KMeansRunResult | null = null;\r\n  let bestSeed = baseSeed;\r\n\r\n  for (let attempt = 0; attempt < nInit; attempt += 1) {\r\n    const seed = (baseSeed + attempt * 2654435761) >>> 0;\r\n    const random = createRandom(seed);\r\n    const run = runSingleKMeans(\r\n      normalizedPoints,\r\n      clusterCount,\r\n      random,\r\n      maxIterations,\r\n      tolerance,\r\n      useKMeansPlusPlus,\r\n    );\r\n\r\n    if (!best || run.inertia < best.inertia - 1e-9) {\r\n      best = run;\r\n      bestSeed = seed;\r\n    }\r\n  }\r\n\r\n  if (!best) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'kMeansClustering failed to produce a valid run.',\r\n    );\r\n  }\r\n\r\n  const clusters: KMeansCluster[] = [];\r\n  for (let clusterIndex = 0; clusterIndex < clusterCount; clusterIndex += 1) {\r\n    const indices: number[] = [];\r\n    for (let pointIndex = 0; pointIndex < best.assignments.length; pointIndex += 1) {\r\n      if (best.assignments[pointIndex] === clusterIndex) {\r\n        indices.push(pointIndex);\r\n      }\r\n    }\r\n\r\n    clusters.push({\r\n      centroid: transform.denormalize(best.centroidsNormalized[clusterIndex] ?? []),\r\n      indices,\r\n    });\r\n  }\r\n\r\n  const silhouette = computeSilhouette(\r\n    normalizedPoints,\r\n    best.assignments,\r\n    clusterCount,\r\n  );\r\n\r\n  return {\r\n    assignments: best.assignments,\r\n    clusters,\r\n    iterations: best.iterations,\r\n    inertia: best.inertia,\r\n    converged: best.converged,\r\n    silhouette,\r\n    selectedSeed: bestSeed,\r\n  };\r\n}\r\n\r\nexport function kMeansAuto(points: number[][], options: KMeansAutoOptions = {}): KMeansAutoResult {\r\n  if (!Array.isArray(points) || points.length === 0) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'kMeansAuto requires at least one point.',\r\n    );\r\n  }\r\n\r\n  const minK = Math.max(2, options.kMin ?? 2);\r\n  const maxK = Math.max(\r\n    minK,\r\n    Math.min(points.length, options.kMax ?? Math.min(10, Math.ceil(Math.sqrt(points.length)) + 2)),\r\n  );\r\n\r\n  let bestResult: KMeansResult | null = null;\r\n  let bestK = minK;\r\n  const candidates: KMeansAutoCandidate[] = [];\r\n\r\n  for (let k = minK; k <= maxK; k += 1) {\r\n    const result = kMeansClustering(points, k, {\r\n      ...options,\r\n      seed:\r\n        options.seed === undefined || !Number.isFinite(options.seed)\r\n          ? undefined\r\n          : options.seed + k * 997,\r\n    });\r\n\r\n    candidates.push({\r\n      k,\r\n      silhouette: result.silhouette,\r\n      inertia: result.inertia,\r\n    });\r\n\r\n    if (!bestResult) {\r\n      bestResult = result;\r\n      bestK = k;\r\n      continue;\r\n    }\r\n\r\n    const currentSilhouette = result.silhouette ?? Number.NEGATIVE_INFINITY;\r\n    const bestSilhouette = bestResult.silhouette ?? Number.NEGATIVE_INFINITY;\r\n\r\n    if (currentSilhouette > bestSilhouette + 1e-9) {\r\n      bestResult = result;\r\n      bestK = k;\r\n      continue;\r\n    }\r\n\r\n    if (\r\n      Math.abs(currentSilhouette - bestSilhouette) <= 1e-9 &&\r\n      result.inertia < bestResult.inertia - 1e-9\r\n    ) {\r\n      bestResult = result;\r\n      bestK = k;\r\n    }\r\n  }\r\n\r\n  if (!bestResult) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'kMeansAuto failed to choose a cluster configuration.',\r\n    );\r\n  }\r\n\r\n  return {\r\n    ...bestResult,\r\n    selectedK: bestK,\r\n    candidates,\r\n  };\r\n}\r\n\r\nexport function travelingSalesmanApprox<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: TravelingSalesmanOptions<NodeId> = {},\r\n): TravelingSalesmanResult<NodeId> {\r\n  const adjacency = buildGraphAdjacency(nodes, edges, options);\r\n\r\n  if (adjacency.nodes.length === 0) {\r\n    return {\r\n      order: [],\r\n      distance: 0,\r\n      segments: [],\r\n      visitedCount: 0,\r\n      complete: true,\r\n      unreachableNodes: [],\r\n      lowerBound: 0,\r\n      optimalityGap: 0,\r\n    };\r\n  }\r\n\r\n  if (hasNegativeWeights(adjacency)) {\r\n    throw new GraphAlgorithmError(\r\n      'NEGATIVE_WEIGHT',\r\n      'TSP approximation requires non-negative graph weights.',\r\n    );\r\n  }\r\n\r\n  const returnToStart = options.returnToStart ?? true;\r\n  const twoOptPasses = Math.max(0, options.twoOptPasses ?? 3);\r\n  const starts = createDeterministicStartList(adjacency.nodes, options);\r\n\r\n  const distanceMatrix = new Map<NodeId, Map<NodeId, number>>();\r\n  const previousMatrix = new Map<NodeId, Map<NodeId, NodeId>>();\r\n\r\n  for (const source of adjacency.nodes) {\r\n    const engine = runShortestPathEngine(\r\n      adjacency,\r\n      source,\r\n      options.shortestPathAlgorithm ?? 'auto',\r\n    );\r\n\r\n    if (engine.result.negativeCycleNodes.size > 0) {\r\n      throw new GraphAlgorithmError(\r\n        'NEGATIVE_CYCLE',\r\n        'TSP approximation cannot run when negative cycles are reachable.',\r\n      );\r\n    }\r\n\r\n    distanceMatrix.set(source, engine.result.distanceByNode);\r\n    previousMatrix.set(source, engine.result.previousByNode);\r\n  }\r\n\r\n  let bestRoute: NodeId[] = [];\r\n  let bestDistance = Number.POSITIVE_INFINITY;\r\n\r\n  for (const start of starts) {\r\n    const greedyRoute = buildGreedyRoute(\r\n      start,\r\n      adjacency.nodes,\r\n      distanceMatrix,\r\n      returnToStart,\r\n    );\r\n\r\n    let candidateRoute = greedyRoute;\r\n    if (candidateRoute.length > 2) {\r\n      candidateRoute = optimizeRouteTwoOpt(\r\n        candidateRoute,\r\n        distanceMatrix,\r\n        twoOptPasses,\r\n      );\r\n    }\r\n\r\n    const candidateDistance = routeDistanceFromMatrix(\r\n      candidateRoute,\r\n      distanceMatrix,\r\n    );\r\n\r\n    if (candidateDistance < bestDistance) {\r\n      bestDistance = candidateDistance;\r\n      bestRoute = candidateRoute;\r\n    }\r\n  }\r\n\r\n  const visited = new Set(bestRoute);\r\n  const unreachableNodes = adjacency.nodes.filter((nodeId) => !visited.has(nodeId));\r\n  const complete = unreachableNodes.length === 0 && Number.isFinite(bestDistance);\r\n\r\n  const segments: TravelingSalesmanSegment<NodeId>[] = [];\r\n  let totalDistance = 0;\r\n\r\n  for (let index = 1; index < bestRoute.length; index += 1) {\r\n    const fromId = bestRoute[index - 1];\r\n    const toId = bestRoute[index];\r\n    if (!fromId || !toId) {\r\n      continue;\r\n    }\r\n\r\n    const distance = distanceMatrix.get(fromId)?.get(toId) ?? Number.POSITIVE_INFINITY;\r\n    const previous = previousMatrix.get(fromId) ?? new Map<NodeId, NodeId>();\r\n    const path = reconstructPath(fromId, toId, previous);\r\n\r\n    if (!Number.isFinite(distance) || path.length === 0) {\r\n      continue;\r\n    }\r\n\r\n    totalDistance += distance;\r\n    segments.push({\r\n      from: fromId,\r\n      to: toId,\r\n      distance,\r\n      path,\r\n    });\r\n  }\r\n\r\n  if (!complete) {\r\n    totalDistance = Number.POSITIVE_INFINITY;\r\n  }\r\n\r\n  const lowerBound = computeMstLowerBound(adjacency.nodes, distanceMatrix);\r\n  const optimalityGap =\r\n    complete &&\r\n    Number.isFinite(totalDistance) &&\r\n    Number.isFinite(lowerBound) &&\r\n    lowerBound > 0\r\n      ? (totalDistance - lowerBound) / lowerBound\r\n      : null;\r\n\r\n  return {\r\n    order: bestRoute,\r\n    distance: totalDistance,\r\n    segments,\r\n    visitedCount: visited.size,\r\n    complete,\r\n    unreachableNodes,\r\n    lowerBound,\r\n    optimalityGap,\r\n  };\r\n}\r\n\r\n//  Hierarchical Clustering \r\n\r\nexport type LinkageMethod = 'single' | 'complete' | 'average' | 'ward';\r\n\r\nexport interface DendrogramNode {\r\n  left: number;\r\n  right: number;\r\n  distance: number;\r\n  size: number;\r\n}\r\n\r\nexport interface HierarchicalClusterResult {\r\n  clusters: number[][];\r\n  assignments: number[];\r\n  dendrogram: DendrogramNode[];\r\n  silhouette: number | null;\r\n}\r\n\r\nexport function hierarchicalClustering(\r\n  points: number[][],\r\n  k: number,\r\n  options: {\r\n    linkage?: LinkageMethod;\r\n    distanceMetric?: 'euclidean' | 'cosine' | 'manhattan';\r\n  } = {},\r\n): HierarchicalClusterResult {\r\n  if (!Array.isArray(points) || points.length === 0) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'hierarchicalClustering requires at least one point.',\r\n    );\r\n  }\r\n\r\n  const n = points.length;\r\n  const clusterCount = Math.max(1, Math.min(n, Math.floor(k)));\r\n  const linkage = options.linkage ?? 'average';\r\n  const metric = options.distanceMetric ?? 'euclidean';\r\n\r\n  const distFn = (a: number[], b: number[]): number => {\r\n    switch (metric) {\r\n      case 'cosine': {\r\n        const sim = distanceCosineSimilarity(a, b);\r\n        return 1 - sim;\r\n      }\r\n      case 'manhattan':\r\n        return manhattanDistance(a, b);\r\n      default:\r\n        return euclideanDistance(a, b);\r\n    }\r\n  };\r\n\r\n  // Initialize: each point is its own cluster\r\n  // clusterMembers[i] = array of point indices in cluster i\r\n  const clusterMembers: number[][] = points.map((_, i) => [i]);\r\n  // active[i] = whether cluster i is still active\r\n  const active: boolean[] = new Array(n).fill(true);\r\n  const dendrogram: DendrogramNode[] = [];\r\n\r\n  // Precompute pairwise distances\r\n  const distMatrix: number[][] = Array.from({ length: n }, () =>\r\n    new Array<number>(n).fill(0),\r\n  );\r\n  for (let i = 0; i < n; i += 1) {\r\n    for (let j = i + 1; j < n; j += 1) {\r\n      const d = distFn(points[i], points[j]);\r\n      distMatrix[i][j] = d;\r\n      distMatrix[j][i] = d;\r\n    }\r\n  }\r\n\r\n  // Cluster distances (for lance-williams updates or direct computation)\r\n  const clusterDist: number[][] = Array.from({ length: n }, (_, i) =>\r\n    [...distMatrix[i]],\r\n  );\r\n\r\n  let activeCount = n;\r\n\r\n  while (activeCount > clusterCount) {\r\n    // Find closest pair of active clusters\r\n    let bestI = -1;\r\n    let bestJ = -1;\r\n    let bestDist = Number.POSITIVE_INFINITY;\r\n\r\n    for (let i = 0; i < clusterMembers.length; i += 1) {\r\n      if (!active[i]) continue;\r\n      for (let j = i + 1; j < clusterMembers.length; j += 1) {\r\n        if (!active[j]) continue;\r\n        if (clusterDist[i][j] < bestDist) {\r\n          bestDist = clusterDist[i][j];\r\n          bestI = i;\r\n          bestJ = j;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (bestI === -1 || bestJ === -1) break;\r\n\r\n    // Merge bestJ into bestI\r\n    dendrogram.push({\r\n      left: bestI < n ? -(bestI + 1) : bestI,\r\n      right: bestJ < n ? -(bestJ + 1) : bestJ,\r\n      distance: bestDist,\r\n      size: clusterMembers[bestI].length + clusterMembers[bestJ].length,\r\n    });\r\n\r\n    const mergedMembers = clusterMembers[bestI].concat(clusterMembers[bestJ]);\r\n    clusterMembers[bestI] = mergedMembers;\r\n    active[bestJ] = false;\r\n    activeCount -= 1;\r\n\r\n    // Update distances from merged cluster to all other active clusters\r\n    for (let other = 0; other < clusterMembers.length; other += 1) {\r\n      if (!active[other] || other === bestI) continue;\r\n\r\n      let newDist: number;\r\n      switch (linkage) {\r\n        case 'single':\r\n          newDist = Math.min(clusterDist[bestI][other], clusterDist[bestJ][other]);\r\n          break;\r\n        case 'complete':\r\n          newDist = Math.max(clusterDist[bestI][other], clusterDist[bestJ][other]);\r\n          break;\r\n        case 'ward': {\r\n          // Lance-Williams formula for Ward's method\r\n          const ni = clusterMembers[bestI].length - clusterMembers[bestJ].length;\r\n          const nj = clusterMembers[bestJ].length;\r\n          const nk = clusterMembers[other].length;\r\n          const total = ni + nj + nk;\r\n          newDist = Math.sqrt(\r\n            ((ni + nk) * clusterDist[bestI][other] * clusterDist[bestI][other] +\r\n              (nj + nk) * clusterDist[bestJ][other] * clusterDist[bestJ][other] -\r\n              nk * bestDist * bestDist) /\r\n              total,\r\n          );\r\n          break;\r\n        }\r\n        default: {\r\n          // average linkage\r\n          const sizeI = clusterMembers[bestI].length - clusterMembers[bestJ].length;\r\n          const sizeJ = clusterMembers[bestJ].length;\r\n          newDist =\r\n            (clusterDist[bestI][other] * sizeI +\r\n              clusterDist[bestJ][other] * sizeJ) /\r\n            (sizeI + sizeJ);\r\n          break;\r\n        }\r\n      }\r\n\r\n      clusterDist[bestI][other] = newDist;\r\n      clusterDist[other][bestI] = newDist;\r\n    }\r\n  }\r\n\r\n  // Build final cluster assignments\r\n  const assignments = new Array<number>(n).fill(-1);\r\n  const clusters: number[][] = [];\r\n  let clusterIdx = 0;\r\n  for (let i = 0; i < clusterMembers.length; i += 1) {\r\n    if (!active[i]) continue;\r\n    clusters.push(clusterMembers[i]);\r\n    for (const ptIdx of clusterMembers[i]) {\r\n      assignments[ptIdx] = clusterIdx;\r\n    }\r\n    clusterIdx += 1;\r\n  }\r\n\r\n  // Compute silhouette\r\n  const silhouette = computeSilhouette(points, assignments, clusters.length);\r\n\r\n  return {\r\n    clusters,\r\n    assignments,\r\n    dendrogram,\r\n    silhouette,\r\n  };\r\n}\r\n\r\n//  DBSCAN \r\n\r\nexport interface DbscanResult {\r\n  clusters: number[][];\r\n  assignments: number[];\r\n  noise: number[];\r\n  clusterCount: number;\r\n}\r\n\r\nexport function dbscan(\r\n  points: number[][],\r\n  epsilon: number,\r\n  minPoints: number,\r\n  options: {\r\n    distanceMetric?: 'euclidean' | 'cosine' | 'manhattan';\r\n  } = {},\r\n): DbscanResult {\r\n  if (!Array.isArray(points) || points.length === 0) {\r\n    throw new GraphAlgorithmError(\r\n      'INVALID_ARGUMENT',\r\n      'dbscan requires at least one point.',\r\n    );\r\n  }\r\n\r\n  const n = points.length;\r\n  const metric = options.distanceMetric ?? 'euclidean';\r\n\r\n  const distFn = (a: number[], b: number[]): number => {\r\n    switch (metric) {\r\n      case 'cosine':\r\n        return 1 - distanceCosineSimilarity(a, b);\r\n      case 'manhattan':\r\n        return manhattanDistance(a, b);\r\n      default:\r\n        return euclideanDistance(a, b);\r\n    }\r\n  };\r\n\r\n  const UNVISITED = -2;\r\n  const NOISE = -1;\r\n  const assignments = new Array<number>(n).fill(UNVISITED);\r\n  let currentCluster = 0;\r\n\r\n  // Find neighbors within epsilon\r\n  const regionQuery = (pointIdx: number): number[] => {\r\n    const neighbors: number[] = [];\r\n    for (let i = 0; i < n; i += 1) {\r\n      if (distFn(points[pointIdx], points[i]) <= epsilon) {\r\n        neighbors.push(i);\r\n      }\r\n    }\r\n    return neighbors;\r\n  };\r\n\r\n  for (let i = 0; i < n; i += 1) {\r\n    if (assignments[i] !== UNVISITED) continue;\r\n\r\n    const neighbors = regionQuery(i);\r\n\r\n    if (neighbors.length < minPoints) {\r\n      assignments[i] = NOISE;\r\n      continue;\r\n    }\r\n\r\n    // Start a new cluster\r\n    assignments[i] = currentCluster;\r\n    const seed = [...neighbors];\r\n    let seedIdx = 0;\r\n\r\n    while (seedIdx < seed.length) {\r\n      const j = seed[seedIdx];\r\n      seedIdx += 1;\r\n\r\n      if (assignments[j] === NOISE) {\r\n        assignments[j] = currentCluster;\r\n      }\r\n      if (assignments[j] !== UNVISITED) continue;\r\n\r\n      assignments[j] = currentCluster;\r\n      const jNeighbors = regionQuery(j);\r\n      if (jNeighbors.length >= minPoints) {\r\n        for (const neighbor of jNeighbors) {\r\n          if (!seed.includes(neighbor)) {\r\n            seed.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    currentCluster += 1;\r\n  }\r\n\r\n  // Build output\r\n  const clusters: number[][] = Array.from(\r\n    { length: currentCluster },\r\n    () => [],\r\n  );\r\n  const noise: number[] = [];\r\n\r\n  for (let i = 0; i < n; i += 1) {\r\n    if (assignments[i] === NOISE) {\r\n      noise.push(i);\r\n    } else {\r\n      clusters[assignments[i]].push(i);\r\n    }\r\n  }\r\n\r\n  return {\r\n    clusters,\r\n    assignments,\r\n    noise,\r\n    clusterCount: currentCluster,\r\n  };\r\n}\r\n","/**\r\n * Graph EDA  What Tukey Would Have Done With Graphs\r\n *\r\n * Treats graph structural properties as data series that deserve\r\n * full exploratory data analysis treatment.\r\n */\r\n\r\nimport { Series } from './index';\r\nimport type {\r\n  SeriesDescription,\r\n  GraphNodeInput,\r\n  GraphEdge,\r\n} from './index';\r\n\r\n//  Types \r\n\r\nexport interface GraphEdaSummary<NodeId extends string = string> {\r\n  nodeCount: number;\r\n  edgeCount: number;\r\n  density: number;\r\n  degreeDistribution: SeriesDescription;\r\n  inDegreeDistribution: SeriesDescription;\r\n  outDegreeDistribution: SeriesDescription;\r\n  clusteringCoefficients: Map<NodeId, number>;\r\n  globalClusteringCoefficient: number;\r\n  clusteringDistribution: SeriesDescription;\r\n  averagePathLength: number;\r\n  diameter: number;\r\n  reciprocity: number;\r\n  degreeAssortativity: number;\r\n}\r\n\r\nexport interface GraphOutlierResult<NodeId extends string = string> {\r\n  nodeId: NodeId;\r\n  score: number;\r\n  reason: string;\r\n}\r\n\r\n//  Helpers \r\n\r\nfunction resolveNodeId<NodeId extends string>(\r\n  node: GraphNodeInput<NodeId>,\r\n): NodeId {\r\n  if (typeof node === 'string') return node;\r\n  return node.id;\r\n}\r\n\r\nfunction buildAdjacencyMaps<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  directed: boolean,\r\n): {\r\n  nodeIds: NodeId[];\r\n  outNeighbors: Map<NodeId, Set<NodeId>>;\r\n  inNeighbors: Map<NodeId, Set<NodeId>>;\r\n  edgeSet: Set<string>;\r\n} {\r\n  const nodeIdSet = new Set<NodeId>();\r\n  for (const node of nodes) {\r\n    nodeIdSet.add(resolveNodeId(node));\r\n  }\r\n  for (const edge of edges) {\r\n    nodeIdSet.add(edge.from as NodeId);\r\n    nodeIdSet.add(edge.to as NodeId);\r\n  }\r\n\r\n  const nodeIds = Array.from(nodeIdSet).sort();\r\n  const outNeighbors = new Map<NodeId, Set<NodeId>>();\r\n  const inNeighbors = new Map<NodeId, Set<NodeId>>();\r\n  const edgeSet = new Set<string>();\r\n\r\n  for (const id of nodeIds) {\r\n    outNeighbors.set(id, new Set());\r\n    inNeighbors.set(id, new Set());\r\n  }\r\n\r\n  for (const edge of edges) {\r\n    const from = edge.from as NodeId;\r\n    const to = edge.to as NodeId;\r\n    outNeighbors.get(from)?.add(to);\r\n    inNeighbors.get(to)?.add(from);\r\n    edgeSet.add(`${from}\\0${to}`);\r\n\r\n    if (!directed) {\r\n      outNeighbors.get(to)?.add(from);\r\n      inNeighbors.get(from)?.add(to);\r\n      edgeSet.add(`${to}\\0${from}`);\r\n    }\r\n  }\r\n\r\n  return { nodeIds, outNeighbors, inNeighbors, edgeSet };\r\n}\r\n\r\n//  Clustering Coefficient \r\n\r\n/**\r\n * Compute the local clustering coefficient for each node.\r\n * For undirected graphs: the fraction of pairs of neighbors that are connected.\r\n * For directed graphs: uses the total number of directed triangles.\r\n */\r\nexport function clusteringCoefficient<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: { directed?: boolean } = {},\r\n): Map<NodeId, number> {\r\n  const directed = options.directed ?? false;\r\n  const { nodeIds, outNeighbors, edgeSet } = buildAdjacencyMaps(\r\n    nodes,\r\n    edges,\r\n    directed,\r\n  );\r\n\r\n  const result = new Map<NodeId, number>();\r\n\r\n  for (const nodeId of nodeIds) {\r\n    const neighbors = outNeighbors.get(nodeId)!;\r\n    const k = neighbors.size;\r\n\r\n    if (k < 2) {\r\n      result.set(nodeId, 0);\r\n      continue;\r\n    }\r\n\r\n    const neighborArr = Array.from(neighbors);\r\n    let triangles = 0;\r\n\r\n    for (let i = 0; i < neighborArr.length; i += 1) {\r\n      for (let j = i + 1; j < neighborArr.length; j += 1) {\r\n        const a = neighborArr[i];\r\n        const b = neighborArr[j];\r\n        if (directed) {\r\n          if (edgeSet.has(`${a}\\0${b}`)) triangles += 1;\r\n          if (edgeSet.has(`${b}\\0${a}`)) triangles += 1;\r\n        } else {\r\n          if (edgeSet.has(`${a}\\0${b}`) || edgeSet.has(`${b}\\0${a}`)) {\r\n            triangles += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const maxTriangles = directed ? k * (k - 1) : (k * (k - 1)) / 2;\r\n    result.set(nodeId, maxTriangles > 0 ? triangles / maxTriangles : 0);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n//  Graph EDA \r\n\r\n/**\r\n * Full exploratory data analysis of a graph's structural properties.\r\n * Returns distributions as Series descriptions for full Tukey-style EDA.\r\n */\r\nexport function graphEda<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: {\r\n    directed?: boolean;\r\n    samplePathLength?: number;\r\n  } = {},\r\n): GraphEdaSummary<NodeId> {\r\n  const directed = options.directed ?? false;\r\n  const { nodeIds, outNeighbors, inNeighbors, edgeSet } = buildAdjacencyMaps(\r\n    nodes,\r\n    edges,\r\n    directed,\r\n  );\r\n\r\n  const nodeCount = nodeIds.length;\r\n  const edgeCount = edges.length;\r\n\r\n  // Density\r\n  const maxEdges = directed\r\n    ? nodeCount * (nodeCount - 1)\r\n    : (nodeCount * (nodeCount - 1)) / 2;\r\n  const density = maxEdges > 0 ? edgeCount / maxEdges : 0;\r\n\r\n  // Degree distributions\r\n  const degrees: number[] = [];\r\n  const inDegrees: number[] = [];\r\n  const outDegrees: number[] = [];\r\n\r\n  for (const nodeId of nodeIds) {\r\n    const outDeg = outNeighbors.get(nodeId)?.size ?? 0;\r\n    const inDeg = inNeighbors.get(nodeId)?.size ?? 0;\r\n    outDegrees.push(outDeg);\r\n    inDegrees.push(inDeg);\r\n    degrees.push(directed ? outDeg + inDeg : outDeg);\r\n  }\r\n\r\n  const degreeSeries = new Series({ data: degrees });\r\n  const inDegreeSeries = new Series({ data: inDegrees });\r\n  const outDegreeSeries = new Series({ data: outDegrees });\r\n\r\n  // Clustering coefficients\r\n  const cc = clusteringCoefficient(nodes, edges, { directed });\r\n  const ccValues = Array.from(cc.values());\r\n  const globalCC =\r\n    ccValues.length > 0\r\n      ? ccValues.reduce((a, b) => a + b, 0) / ccValues.length\r\n      : 0;\r\n  const ccSeries = new Series({ data: ccValues.length > 0 ? ccValues : [0] });\r\n\r\n  // Reciprocity (fraction of edges with a reverse edge)\r\n  let reciprocalCount = 0;\r\n  if (directed) {\r\n    for (const edge of edges) {\r\n      if (edgeSet.has(`${edge.to}\\0${edge.from}`)) {\r\n        reciprocalCount += 1;\r\n      }\r\n    }\r\n  }\r\n  const reciprocity = directed && edgeCount > 0\r\n    ? reciprocalCount / edgeCount\r\n    : directed\r\n      ? 0\r\n      : 1;\r\n\r\n  // BFS-based path length sampling\r\n  const sampleSize = Math.min(\r\n    nodeCount,\r\n    options.samplePathLength ?? Math.min(nodeCount, 50),\r\n  );\r\n  let totalPathLength = 0;\r\n  let pathCount = 0;\r\n  let diameter = 0;\r\n\r\n  // Sample nodes deterministically\r\n  const sampleStep = Math.max(1, Math.floor(nodeCount / sampleSize));\r\n  for (let si = 0; si < nodeCount && si / sampleStep < sampleSize; si += sampleStep) {\r\n    const source = nodeIds[si];\r\n    // BFS from source\r\n    const dist = new Map<NodeId, number>();\r\n    dist.set(source, 0);\r\n    const queue: NodeId[] = [source];\r\n    let qi = 0;\r\n\r\n    while (qi < queue.length) {\r\n      const current = queue[qi];\r\n      qi += 1;\r\n      const currentDist = dist.get(current)!;\r\n      const neighbors = outNeighbors.get(current) ?? new Set<NodeId>();\r\n\r\n      for (const neighbor of neighbors) {\r\n        if (!dist.has(neighbor)) {\r\n          const d = currentDist + 1;\r\n          dist.set(neighbor, d);\r\n          queue.push(neighbor);\r\n          totalPathLength += d;\r\n          pathCount += 1;\r\n          if (d > diameter) diameter = d;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const averagePathLength = pathCount > 0 ? totalPathLength / pathCount : 0;\r\n\r\n  // Degree assortativity: Pearson correlation of degrees at edge endpoints\r\n  let assortativity = 0;\r\n  if (edges.length > 1) {\r\n    const sourceDegrees: number[] = [];\r\n    const targetDegrees: number[] = [];\r\n    for (const edge of edges) {\r\n      sourceDegrees.push(outNeighbors.get(edge.from as NodeId)?.size ?? 0);\r\n      targetDegrees.push(outNeighbors.get(edge.to as NodeId)?.size ?? 0);\r\n    }\r\n    const n = sourceDegrees.length;\r\n    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;\r\n    for (let i = 0; i < n; i += 1) {\r\n      sumX += sourceDegrees[i];\r\n      sumY += targetDegrees[i];\r\n      sumXY += sourceDegrees[i] * targetDegrees[i];\r\n      sumX2 += sourceDegrees[i] * sourceDegrees[i];\r\n      sumY2 += targetDegrees[i] * targetDegrees[i];\r\n    }\r\n    const numerator = n * sumXY - sumX * sumY;\r\n    const denominator = Math.sqrt(\r\n      (n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY),\r\n    );\r\n    assortativity = denominator > 0 ? numerator / denominator : 0;\r\n  }\r\n\r\n  return {\r\n    nodeCount,\r\n    edgeCount,\r\n    density,\r\n    degreeDistribution: degreeSeries.describe(),\r\n    inDegreeDistribution: inDegreeSeries.describe(),\r\n    outDegreeDistribution: outDegreeSeries.describe(),\r\n    clusteringCoefficients: cc,\r\n    globalClusteringCoefficient: globalCC,\r\n    clusteringDistribution: ccSeries.describe(),\r\n    averagePathLength,\r\n    diameter,\r\n    reciprocity,\r\n    degreeAssortativity: assortativity,\r\n  };\r\n}\r\n\r\n//  Graph Outliers \r\n\r\n/**\r\n * Graph-based outlier detection: nodes with unusual structural signatures.\r\n */\r\nexport function graphOutliers<NodeId extends string>(\r\n  nodes: GraphNodeInput<NodeId>[],\r\n  edges: GraphEdge<NodeId>[],\r\n  options: {\r\n    method?: 'degree' | 'clustering' | 'combined';\r\n    threshold?: number;\r\n  } = {},\r\n): GraphOutlierResult<NodeId>[] {\r\n  const method = options.method ?? 'combined';\r\n  const threshold = options.threshold ?? 2.0;\r\n  const directed = false;\r\n  const { nodeIds, outNeighbors } = buildAdjacencyMaps(nodes, edges, directed);\r\n\r\n  const results: GraphOutlierResult<NodeId>[] = [];\r\n\r\n  if (method === 'degree' || method === 'combined') {\r\n    const degrees = nodeIds.map((id) => outNeighbors.get(id)?.size ?? 0);\r\n    const degreeSeries = new Series({ data: degrees });\r\n    const mean = degreeSeries.mean();\r\n    const std = degreeSeries.stddev();\r\n\r\n    if (std > 0) {\r\n      for (let i = 0; i < nodeIds.length; i += 1) {\r\n        const zscore = Math.abs(degrees[i] - mean) / std;\r\n        if (zscore > threshold) {\r\n          results.push({\r\n            nodeId: nodeIds[i],\r\n            score: zscore,\r\n            reason: `degree outlier (z=${zscore.toFixed(2)}, degree=${degrees[i]})`,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (method === 'clustering' || method === 'combined') {\r\n    const cc = clusteringCoefficient(nodes, edges, { directed });\r\n    const ccValues = Array.from(cc.values());\r\n    const ccSeries = new Series({ data: ccValues.length > 0 ? ccValues : [0] });\r\n    const mean = ccSeries.mean();\r\n    const std = ccSeries.stddev();\r\n\r\n    if (std > 0) {\r\n      let i = 0;\r\n      for (const nodeId of nodeIds) {\r\n        const value = cc.get(nodeId) ?? 0;\r\n        const zscore = Math.abs(value - mean) / std;\r\n        if (zscore > threshold) {\r\n          // Avoid duplicates in combined mode\r\n          const existing = results.find((r) => r.nodeId === nodeId);\r\n          if (existing) {\r\n            existing.score = Math.max(existing.score, zscore);\r\n            existing.reason += `; clustering outlier (z=${zscore.toFixed(2)}, cc=${value.toFixed(3)})`;\r\n          } else {\r\n            results.push({\r\n              nodeId,\r\n              score: zscore,\r\n              reason: `clustering outlier (z=${zscore.toFixed(2)}, cc=${value.toFixed(3)})`,\r\n            });\r\n          }\r\n        }\r\n        i += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return results.sort((a, b) => b.score - a.score);\r\n}\r\n","/**\r\n * Twokeys - A small data exploration and manipulation library\r\n * Named after John Tukey, pioneer of exploratory data analysis (EDA)\r\n *\r\n * Features:\r\n * - Summary statistics (mean, median, mode, quartiles)\r\n * - Binning (histogram-like grouping)\r\n * - Smoothing (Hanning filter and median smoothing)\r\n * - Ranking and ranking analysis\r\n * - Outlier detection (using Tukey fences)\r\n * - Data transforms (logarithms, roots, inverses)\r\n */\r\n\r\nexport interface SeriesOptions {\r\n  data?: number[];\r\n}\r\n\r\nexport interface PointsOptions {\r\n  data?: number[][];\r\n  dimensionality?: number;\r\n  count?: number;\r\n}\r\n\r\nexport interface MedianResult {\r\n  datum: number;\r\n  depth: number;\r\n}\r\n\r\nexport interface ModeResult {\r\n  count: number;\r\n  data: number[];\r\n}\r\n\r\nexport interface RankInfo {\r\n  rank: number;\r\n  peers: number;\r\n}\r\n\r\nexport interface RankedResult {\r\n  up: Record<number, RankInfo>;\r\n  down: Record<number, RankInfo>;\r\n  groups: {\r\n    up: (number | number[])[];\r\n    down: (number | number[])[];\r\n  };\r\n}\r\n\r\nexport interface BinnedResult {\r\n  bins: number;\r\n  width: number;\r\n  binned: Record<\r\n    number,\r\n    {\r\n      from: number;\r\n      to: number;\r\n      data: number[];\r\n    }\r\n  >;\r\n}\r\n\r\nexport interface SeriesDescription {\r\n  original: number[];\r\n  summary: {\r\n    median: MedianResult;\r\n    mean: number;\r\n    mode: ModeResult;\r\n    hinges: MedianResult[];\r\n    adjacent: number[];\r\n    outliers: number[];\r\n    outer: number[];\r\n    outside: number[];\r\n    inside: number[];\r\n    extremes: number[];\r\n    iqr: number;\r\n    fences: number[];\r\n  };\r\n  smooths: {\r\n    smooth: number[];\r\n    hanning: number[];\r\n  };\r\n  transforms: {\r\n    logs: number[];\r\n    roots: number[];\r\n    inverse: number[];\r\n  };\r\n  counts: [number, number][];\r\n  sorted: number[];\r\n  ranked: RankedResult;\r\n  binned: BinnedResult;\r\n}\r\n\r\nexport interface PointsDescription {\r\n  original: number[][];\r\n  centroid: number[];\r\n  variances: number[];\r\n  correlationMatrix: number[][];\r\n  mahalanobisDistances: number[];\r\n  outlierCount: number;\r\n  dimensionSummaries: SeriesDescription[];\r\n}\r\n\r\n// Constants\r\nconst DEFAULT_MAX_RANDOM_INTEGER = 100;\r\nconst DEFAULT_MIN_RANDOM_INTEGER = 0;\r\nconst DEFAULT_RANDOM_SERIES_COUNT = 1000;\r\nconst DEFAULT_OUTLIER_MULTIPLE = 1.5;\r\nconst DEFAULT_JITTER_MULTIPLIER = 1;\r\nconst DEFAULT_SPLIT_PASSES = 2;\r\nconst DEFAULT_MAX_RANDOM_DIMENSIONALITY = 2;\r\n\r\n// Utility functions\r\nfunction randomInteger(max: number = DEFAULT_MAX_RANDOM_INTEGER): number {\r\n  return Math.floor(Math.random() * max);\r\n}\r\n\r\nfunction randomSeries(\r\n  count: number = DEFAULT_RANDOM_SERIES_COUNT,\r\n  max: number = DEFAULT_MAX_RANDOM_INTEGER\r\n): number[] {\r\n  const series: number[] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    series.push(randomInteger(max));\r\n  }\r\n  return series;\r\n}\r\n\r\nfunction randomPoint(\r\n  dimension: number = DEFAULT_MAX_RANDOM_DIMENSIONALITY,\r\n  max: number = DEFAULT_MAX_RANDOM_INTEGER\r\n): number[] {\r\n  const point: number[] = [];\r\n  for (let i = 0; i < dimension; i++) {\r\n    point.push(Math.floor((Math.random() * (max / 10)) % max));\r\n  }\r\n  return point;\r\n}\r\n\r\nfunction randomPoints(\r\n  count: number = DEFAULT_RANDOM_SERIES_COUNT,\r\n  dimension: number = DEFAULT_MAX_RANDOM_DIMENSIONALITY,\r\n  max: number = DEFAULT_MAX_RANDOM_INTEGER\r\n): number[][] {\r\n  const points: number[][] = [];\r\n  for (let i = 0; i < count; i++) {\r\n    points.push(randomPoint(dimension, max));\r\n  }\r\n  return points;\r\n}\r\n\r\n/**\r\n * Series class for 1D data exploration\r\n */\r\nexport class Series {\r\n  private data: {\r\n    original: number[];\r\n    sorted?: number[];\r\n    median?: number;\r\n    medianDepth?: number;\r\n    mean?: number;\r\n    variance?: number;\r\n    stddev?: number;\r\n    skewness?: number;\r\n    kurtosis?: number;\r\n    mode?: ModeResult;\r\n    extremes?: number[];\r\n    counts?: [number, number][];\r\n    hinges?: MedianResult[];\r\n    iqr?: number;\r\n    fences?: number[];\r\n    outer?: number[];\r\n    outside?: number[];\r\n    inside?: number[];\r\n    outliers?: number[];\r\n    ranked?: RankedResult;\r\n    adjacent?: number[];\r\n    binned?: BinnedResult;\r\n    logs?: number[];\r\n    roots?: number[];\r\n    inverse?: number[];\r\n    hanning?: number[];\r\n    smooth?: number[];\r\n    rough?: number[];\r\n    description?: SeriesDescription;\r\n  };\r\n\r\n  constructor(options: SeriesOptions = {}) {\r\n    this.data = {\r\n      original: options.data ?? randomSeries(),\r\n    };\r\n  }\r\n\r\n  // Sort\r\n  sorted(): number[] {\r\n    if (!this.data.sorted) {\r\n      this.data.sorted = this.getSorted(this.data.original);\r\n    }\r\n    return this.data.sorted;\r\n  }\r\n\r\n  private getSorted(arr: number[]): number[] {\r\n    return [...arr].sort((a, b) => {\r\n      if (a > b) return 1;\r\n      if (a === b) return 0;\r\n      return -1;\r\n    });\r\n  }\r\n\r\n  // Median\r\n  median(): MedianResult {\r\n    this.sorted();\r\n    if (this.data.median === undefined) {\r\n      this.data.median = this.getMedian(this.data.sorted!);\r\n    }\r\n    if (this.data.medianDepth === undefined) {\r\n      this.data.medianDepth = this.getMedianDepth(this.data.sorted!);\r\n    }\r\n    return {\r\n      datum: this.data.median,\r\n      depth: this.data.medianDepth,\r\n    };\r\n  }\r\n\r\n  private getMedianDepth(arr: number[], offset: number = 0): number {\r\n    if (!arr.length) return NaN;\r\n    return offset + (arr.length + 1) / 2;\r\n  }\r\n\r\n  private getMedian(arr: number[]): number {\r\n    const len = arr.length;\r\n    if (!len) return NaN;\r\n    if (len === 1) return arr[0];\r\n\r\n    const mid = Math.floor(len / 2);\r\n    if (len % 2 === 0) {\r\n      return (arr[mid - 1] + arr[mid]) / 2;\r\n    }\r\n    return arr[mid];\r\n  }\r\n\r\n  // Mean\r\n  mean(): number {\r\n    if (this.data.mean === undefined) {\r\n      this.data.mean = this.getMean(this.data.original);\r\n    }\r\n    return this.data.mean;\r\n  }\r\n\r\n  private getMean(arr: number[]): number {\r\n    if (!arr.length) return NaN;\r\n    let total = 0;\r\n    for (const num of arr) {\r\n      total += num;\r\n    }\r\n    return total / arr.length;\r\n  }\r\n\r\n  // Variance (sample variance: (x - mean) / (n - 1))\r\n  variance(): number {\r\n    if (this.data.variance === undefined) {\r\n      const m = this.mean();\r\n      const arr = this.data.original;\r\n      if (arr.length < 2) {\r\n        this.data.variance = NaN;\r\n      } else {\r\n        let sum = 0;\r\n        for (const val of arr) {\r\n          const delta = val - m;\r\n          sum += delta * delta;\r\n        }\r\n        this.data.variance = sum / (arr.length - 1);\r\n      }\r\n    }\r\n    return this.data.variance;\r\n  }\r\n\r\n  // Standard deviation: sqrt(variance)\r\n  stddev(): number {\r\n    if (this.data.stddev === undefined) {\r\n      this.data.stddev = Math.sqrt(this.variance());\r\n    }\r\n    return this.data.stddev;\r\n  }\r\n\r\n  // Exponential moving average series\r\n  ema(alpha: number): number[] {\r\n    const arr = this.data.original;\r\n    if (arr.length === 0) return [];\r\n    const result: number[] = [arr[0]];\r\n    for (let i = 1; i < arr.length; i += 1) {\r\n      const prev = result[i - 1];\r\n      result.push(prev * (1 - alpha) + arr[i] * alpha);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Z-score normalization: (x - mean) / stddev\r\n  zscore(): number[] {\r\n    const m = this.mean();\r\n    const s = this.stddev();\r\n    if (s === 0 || isNaN(s)) {\r\n      return this.data.original.map(() => 0);\r\n    }\r\n    return this.data.original.map((val) => (val - m) / s);\r\n  }\r\n\r\n  // Fisher-Pearson skewness: n/((n-1)(n-2)) * ((x-mean)/stddev)\r\n  skewness(): number {\r\n    if (this.data.skewness === undefined) {\r\n      const arr = this.data.original;\r\n      const n = arr.length;\r\n      if (n < 3) {\r\n        this.data.skewness = NaN;\r\n      } else {\r\n        const m = this.mean();\r\n        const s = this.stddev();\r\n        if (s === 0) {\r\n          this.data.skewness = 0;\r\n        } else {\r\n          let sum = 0;\r\n          for (const val of arr) {\r\n            const z = (val - m) / s;\r\n            sum += z * z * z;\r\n          }\r\n          this.data.skewness = (n / ((n - 1) * (n - 2))) * sum;\r\n        }\r\n      }\r\n    }\r\n    return this.data.skewness;\r\n  }\r\n\r\n  // Excess kurtosis: adjusted fourth moment minus 3\r\n  kurtosis(): number {\r\n    if (this.data.kurtosis === undefined) {\r\n      const arr = this.data.original;\r\n      const n = arr.length;\r\n      if (n < 4) {\r\n        this.data.kurtosis = NaN;\r\n      } else {\r\n        const m = this.mean();\r\n        const s = this.stddev();\r\n        if (s === 0) {\r\n          this.data.kurtosis = 0;\r\n        } else {\r\n          let sum = 0;\r\n          for (const val of arr) {\r\n            const z = (val - m) / s;\r\n            sum += z * z * z * z;\r\n          }\r\n          const rawKurt = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3)) * sum;\r\n          const correction = (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));\r\n          this.data.kurtosis = rawKurt - correction;\r\n        }\r\n      }\r\n    }\r\n    return this.data.kurtosis;\r\n  }\r\n\r\n  // Mode\r\n  mode(): ModeResult {\r\n    if (!this.data.mode) {\r\n      this.sorted();\r\n      this.data.mode = this.getMode(this.data.sorted!);\r\n    }\r\n    return this.data.mode;\r\n  }\r\n\r\n  private getMode(data: number[]): ModeResult {\r\n    if (!data.length) {\r\n      return { count: 0, data: [] };\r\n    }\r\n\r\n    // Count frequencies\r\n    const freq: Record<number, number> = {};\r\n    let maxCount = 0;\r\n\r\n    for (const val of data) {\r\n      freq[val] = (freq[val] || 0) + 1;\r\n      if (freq[val] > maxCount) {\r\n        maxCount = freq[val];\r\n      }\r\n    }\r\n\r\n    // Find all values with max frequency\r\n    const modes: number[] = [];\r\n    for (const [val, count] of Object.entries(freq)) {\r\n      if (count === maxCount) {\r\n        modes.push(Number(val));\r\n      }\r\n    }\r\n\r\n    return {\r\n      count: maxCount,\r\n      data: modes.sort((a, b) => a - b),\r\n    };\r\n  }\r\n\r\n  // Extremes\r\n  extremes(): number[] {\r\n    if (!this.data.extremes) {\r\n      this.sorted();\r\n      this.data.extremes = this.getExtremes(this.data.sorted!);\r\n    }\r\n    return this.data.extremes;\r\n  }\r\n\r\n  private getExtremes(data: number[]): number[] {\r\n    if (!data.length) return [];\r\n    return [data[0], data[data.length - 1]];\r\n  }\r\n\r\n  // Counts\r\n  counts(): [number, number][] {\r\n    if (!this.data.counts) {\r\n      this.sorted();\r\n      this.data.counts = this.getCounts(this.data.sorted!);\r\n    }\r\n    return this.data.counts;\r\n  }\r\n\r\n  private getCounts(data: number[]): [number, number][] {\r\n    const freq = new Map<number, number>();\r\n    for (const val of data) {\r\n      freq.set(val, (freq.get(val) || 0) + 1);\r\n    }\r\n    const result: [number, number][] = [];\r\n    for (const [val, count] of freq) {\r\n      result.push([val, count]);\r\n    }\r\n    return result.sort((a, b) => a[0] - b[0]);\r\n  }\r\n\r\n  // Hinges (quartiles)\r\n  hinges(): MedianResult[] {\r\n    if (!this.data.hinges) {\r\n      this.sorted();\r\n      this.data.hinges = this.getHinges(this.data.sorted!);\r\n    }\r\n    return this.data.hinges;\r\n  }\r\n\r\n  private getHinges(\r\n    arr: number[],\r\n    hinges: number = 2,\r\n    result: MedianResult[] = []\r\n  ): MedianResult[] {\r\n    const copy = [...arr];\r\n    const total = copy.length;\r\n\r\n    let hingeCount = hinges;\r\n    if (hingeCount % 2 !== 0) {\r\n      hingeCount++;\r\n    }\r\n\r\n    if (total <= hingeCount || hingeCount <= 0) {\r\n      return result;\r\n    }\r\n\r\n    const per = Math.floor(total / hingeCount);\r\n    const howMany = Math.floor(total / per) - 1;\r\n\r\n    for (let step = 0; step <= howMany; step++) {\r\n      const fragment = copy.slice(step * per, step * per + per);\r\n      result.push({\r\n        datum: this.getMedian(fragment),\r\n        depth: this.getMedianDepth(fragment, step * per),\r\n      });\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // IQR (Interquartile Range)\r\n  iqr(): number {\r\n    if (this.data.iqr === undefined) {\r\n      this.hinges();\r\n      this.data.iqr = this.getIQR(this.data.hinges!);\r\n    }\r\n    return this.data.iqr;\r\n  }\r\n\r\n  private getIQR(hinges: MedianResult[]): number {\r\n    const first = hinges[0]?.datum;\r\n    const second = hinges[1]?.datum;\r\n    if (first === undefined || second === undefined) {\r\n      return NaN;\r\n    }\r\n    return Math.abs(first - second);\r\n  }\r\n\r\n  // Fences\r\n  fences(): number[] {\r\n    if (!this.data.fences) {\r\n      this.median();\r\n      this.iqr();\r\n      this.data.fences = this.getFences();\r\n    }\r\n    return this.data.fences;\r\n  }\r\n\r\n  private getFences(multiple: number = DEFAULT_OUTLIER_MULTIPLE): number[] {\r\n    const base = this.data.median;\r\n    const iqr = this.data.iqr;\r\n    if (base === undefined || iqr === undefined || isNaN(iqr)) {\r\n      return [];\r\n    }\r\n    const extra = iqr * multiple;\r\n    return [base - extra, base + extra];\r\n  }\r\n\r\n  // Outer fences\r\n  outer(): number[] {\r\n    if (!this.data.outer) {\r\n      this.median();\r\n      this.iqr();\r\n      this.data.outer = this.getOuter();\r\n    }\r\n    return this.data.outer;\r\n  }\r\n\r\n  private getOuter(multiple: number = DEFAULT_OUTLIER_MULTIPLE): number[] {\r\n    const base = this.data.median;\r\n    const iqr = this.data.iqr;\r\n    if (base === undefined || iqr === undefined || isNaN(iqr)) {\r\n      return [];\r\n    }\r\n    const extra = 2 * iqr * multiple;\r\n    return [base - extra, base + extra];\r\n  }\r\n\r\n  // Outside values\r\n  outside(): number[] {\r\n    if (!this.data.outside) {\r\n      this.outer();\r\n      this.data.outside = this.getOutside();\r\n    }\r\n    return this.data.outside;\r\n  }\r\n\r\n  private getOutside(): number[] {\r\n    const results: number[] = [];\r\n    const sorted = this.data.sorted!;\r\n    const outer = this.data.outer;\r\n    if (!outer || outer.length === 0) return [];\r\n    const min = Math.min(...outer);\r\n    const max = Math.max(...outer);\r\n    for (const num of sorted) {\r\n      if (num > max || num < min) {\r\n        results.push(num);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  // Inside values\r\n  inside(): number[] {\r\n    if (!this.data.inside) {\r\n      this.fences();\r\n      this.data.inside = this.getInside();\r\n    }\r\n    return this.data.inside;\r\n  }\r\n\r\n  private getInside(): number[] {\r\n    const results: number[] = [];\r\n    const sorted = this.data.sorted!;\r\n    const fences = this.data.fences;\r\n    if (!fences || fences.length === 0) return [];\r\n    const min = Math.min(...fences);\r\n    const max = Math.max(...fences);\r\n    for (const num of sorted) {\r\n      if (num < max && num > min) {\r\n        results.push(num);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  // Outliers\r\n  outliers(): number[] {\r\n    if (!this.data.outliers) {\r\n      this.fences();\r\n      this.data.outliers = this.getOutliers();\r\n    }\r\n    return this.data.outliers;\r\n  }\r\n\r\n  private getOutliers(): number[] {\r\n    const results: number[] = [];\r\n    const sorted = this.data.sorted!;\r\n    const fences = this.data.fences!;\r\n    if (fences.length === 0) return [];\r\n    const min = Math.min(...fences);\r\n    const max = Math.max(...fences);\r\n    for (const num of sorted) {\r\n      if (num > max || num < min) {\r\n        results.push(num);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  // Ranked\r\n  ranked(): RankedResult {\r\n    if (!this.data.ranked) {\r\n      this.sorted();\r\n      this.data.ranked = this.getRanked(this.data.sorted!);\r\n    }\r\n    return this.data.ranked;\r\n  }\r\n\r\n  private getRanked(arr: number[], ties: boolean = true): RankedResult {\r\n    const up: Record<number, RankInfo> = {};\r\n    const down: Record<number, RankInfo> = {};\r\n    const total = arr.length;\r\n    const ranked: (number | number[])[] = [];\r\n\r\n    let tiedRank = NaN;\r\n    let tiedNumbers: number[] = [];\r\n\r\n    const reset = () => {\r\n      tiedRank = NaN;\r\n      tiedNumbers = [];\r\n    };\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n      const num = arr[i];\r\n\r\n      if (!ties) {\r\n        up[num] = { rank: i + 1, peers: 0 };\r\n        down[num] = { rank: total - i, peers: 0 };\r\n      } else {\r\n        const incr = i + 1;\r\n        const decr = i - 1;\r\n\r\n        if (num === arr[decr]) {\r\n          if (!isNaN(tiedRank) && tiedNumbers.length === 0) {\r\n            tiedNumbers.push(num);\r\n            ranked.push(tiedNumbers);\r\n            reset();\r\n          } else {\r\n            tiedNumbers.push(num);\r\n            tiedRank = decr;\r\n          }\r\n          if (num !== arr[incr]) {\r\n            ranked.push(tiedNumbers);\r\n            reset();\r\n          }\r\n        } else {\r\n          if (num !== arr[incr]) {\r\n            if (tiedNumbers.length > 0) {\r\n              ranked.push(tiedNumbers);\r\n              reset();\r\n            } else {\r\n              ranked.push(num);\r\n            }\r\n          } else {\r\n            tiedNumbers.push(num);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let offset = 0;\r\n    for (let i = 0; i < ranked.length; i++) {\r\n      const item = ranked[i];\r\n      if (typeof item === 'number') {\r\n        down[item] = { rank: i + 1 + offset, peers: 0 };\r\n        up[item] = { rank: total - i - offset, peers: 0 };\r\n      } else if (Array.isArray(item)) {\r\n        offset += item.length;\r\n        const usable = item[0];\r\n        down[usable] = { rank: i + 1 + offset, peers: item.length };\r\n        up[usable] = { rank: total - i - offset, peers: item.length };\r\n      } else {\r\n        offset += 1;\r\n      }\r\n    }\r\n\r\n    return {\r\n      up,\r\n      down,\r\n      groups: {\r\n        down: [...ranked],\r\n        up: [...ranked].reverse(),\r\n      },\r\n    };\r\n  }\r\n\r\n  // Adjacent\r\n  adjacent(): number[] {\r\n    if (!this.data.adjacent) {\r\n      this.fences();\r\n      this.data.adjacent = this.getAdjacent(this.data.sorted!, this.data.fences!);\r\n    }\r\n    return this.data.adjacent;\r\n  }\r\n\r\n  private getAdjacent(arr: number[], fences: number[]): number[] {\r\n    if (fences.length === 0) return [];\r\n\r\n    const low = fences[0];\r\n    const lows: number[] = [];\r\n    const high = fences[1];\r\n    const highs: number[] = [];\r\n\r\n    for (const val of arr) {\r\n      if (val > low) lows.push(val);\r\n      if (val < high) highs.push(val);\r\n    }\r\n\r\n    lows.sort((a, b) => a - b);\r\n    highs.sort((a, b) => a - b);\r\n\r\n    return [lows[0], highs[highs.length - 1]];\r\n  }\r\n\r\n  // Binned\r\n  binned(bins: number = NaN): BinnedResult {\r\n    if (!this.data.binned) {\r\n      this.sorted();\r\n      this.extremes();\r\n      this.data.binned = this.getBinned(this.data.sorted!, bins);\r\n    }\r\n    return this.data.binned;\r\n  }\r\n\r\n  private getBinned(\r\n    arr: number[],\r\n    bins: number = 10,\r\n    width: number = NaN,\r\n    includeZero: boolean = true\r\n  ): BinnedResult {\r\n    const binned: Record<number, { from: number; to: number; data: number[] }> = {};\r\n    const total = arr.length;\r\n    const zeroOffset = includeZero ? 0 : 1;\r\n\r\n    if (total === 0) {\r\n      return { bins: 0, width: NaN, binned: {} };\r\n    }\r\n\r\n    const extremes = this.data.extremes!;\r\n    let calculatedWidth = width;\r\n\r\n    if (extremes && isNaN(calculatedWidth) && extremes.length === 2) {\r\n      calculatedWidth = (extremes[1] - extremes[0]) / (Math.log(arr.length) / Math.LN2);\r\n      calculatedWidth = Math.floor(calculatedWidth);\r\n\r\n      let areIntegers = true;\r\n      for (const item of arr) {\r\n        if (item % 1 !== 0) {\r\n          areIntegers = false;\r\n          break;\r\n        }\r\n      }\r\n      if (areIntegers) {\r\n        calculatedWidth = Math.floor(calculatedWidth);\r\n      }\r\n    }\r\n\r\n    let binCount = Math.floor(extremes[1] / calculatedWidth) + 1;\r\n    if (!binCount || binCount < 1) {\r\n      binCount = 1;\r\n    }\r\n\r\n    for (const val of arr) {\r\n      const bin = Math.floor((val - zeroOffset) / calculatedWidth);\r\n      if (!binned[bin]) {\r\n        binned[bin] = {\r\n          from: bin * calculatedWidth + zeroOffset,\r\n          to: (bin + 1) * calculatedWidth + zeroOffset - 1,\r\n          data: [],\r\n        };\r\n      }\r\n      binned[bin].data.push(val);\r\n    }\r\n\r\n    return {\r\n      bins: binCount,\r\n      width: calculatedWidth,\r\n      binned,\r\n    };\r\n  }\r\n\r\n  // Transforms\r\n  logs(): number[] {\r\n    if (!this.data.logs) {\r\n      this.data.logs = this.getLogs(this.data.original);\r\n    }\r\n    return this.data.logs;\r\n  }\r\n\r\n  private getLogs(arr: number[]): number[] {\r\n    return arr.map((val) => Math.log(val));\r\n  }\r\n\r\n  roots(): number[] {\r\n    if (!this.data.roots) {\r\n      this.data.roots = this.getRoots(this.data.original);\r\n    }\r\n    return this.data.roots;\r\n  }\r\n\r\n  private getRoots(arr: number[]): number[] {\r\n    return arr.map((val) => Math.sqrt(val));\r\n  }\r\n\r\n  inverse(): number[] {\r\n    if (!this.data.inverse) {\r\n      this.data.inverse = this.getInverse(this.data.original);\r\n    }\r\n    return this.data.inverse;\r\n  }\r\n\r\n  private getInverse(arr: number[]): number[] {\r\n    return arr.map((val) => 1 / val);\r\n  }\r\n\r\n  // Smoothing\r\n  hanning(): number[] {\r\n    if (!this.data.hanning) {\r\n      this.data.hanning = this.getSkipMeans(this.data.original);\r\n    }\r\n    return this.data.hanning;\r\n  }\r\n\r\n  private getSkipMeans(arr: number[]): number[] {\r\n    const results: number[] = [];\r\n    for (let i = 0; i < arr.length; i++) {\r\n      if (i !== 0 && i !== arr.length - 1) {\r\n        results.push((arr[i] + arr[i + 1]) / 2);\r\n      }\r\n    }\r\n    results.unshift(arr[0]);\r\n    results.push(arr[arr.length - 1]);\r\n    return results;\r\n  }\r\n\r\n  smooth(): number[] {\r\n    if (!this.data.smooth) {\r\n      this.sorted();\r\n      this.data.smooth = this.getSmooth(this.data.original);\r\n    }\r\n    this.data.rough = this.getRough(this.data.original, this.data.smooth);\r\n    return this.data.smooth;\r\n  }\r\n\r\n  private getRough(original: number[], smoothed: number[]): number[] {\r\n    const residuals: number[] = [];\r\n    for (let x = 0; x < original.length; x++) {\r\n      residuals.push(original[x] - smoothed[x]);\r\n    }\r\n    return residuals;\r\n  }\r\n\r\n  private getSmooth(arr: number[], passes: number = 3): number[] {\r\n    let smoothed = [...arr];\r\n    smoothed = this.smoothMedian(smoothed, passes);\r\n    smoothed = this.smoothExtremes(smoothed, -1);\r\n    smoothed = this.smoothSplit(smoothed, 2);\r\n    smoothed = this.smoothMedian(smoothed, passes);\r\n    smoothed = this.smoothExtremes(smoothed, -1);\r\n    smoothed = this.smoothMedian(smoothed, passes);\r\n    return smoothed;\r\n  }\r\n\r\n  private smoothExtremes(\r\n    arr: number[],\r\n    passes: number = 1,\r\n    current: number = 0,\r\n    end: 'both' | 'head' | 'tail' = 'both'\r\n  ): number[] {\r\n    const len = arr.length;\r\n    if (len <= 2) return [...arr];\r\n\r\n    const result = [...arr];\r\n\r\n    for (let pass = current; pass < passes || passes === -1; pass++) {\r\n      let changed = false;\r\n\r\n      if (end === 'both' || end === 'head') {\r\n        const first = result[0];\r\n        const second = result[1];\r\n        const third = result[2];\r\n        const tmp = second - 2 * (third - second);\r\n        // Median of three: sort and pick middle\r\n        const median =\r\n          first <= second\r\n            ? second <= tmp\r\n              ? second\r\n              : first <= tmp\r\n                ? tmp\r\n                : first\r\n            : first <= tmp\r\n              ? first\r\n              : second <= tmp\r\n                ? tmp\r\n                : second;\r\n        if (result[0] !== median) {\r\n          result[0] = median;\r\n          changed = true;\r\n        }\r\n      }\r\n\r\n      if (end === 'both' || end === 'tail') {\r\n        const antepenultimate = result[len - 3];\r\n        const penultimate = result[len - 2];\r\n        const last = result[len - 1];\r\n        const tmp = penultimate - 2 * (antepenultimate - penultimate);\r\n        const median =\r\n          last <= penultimate\r\n            ? penultimate <= tmp\r\n              ? penultimate\r\n              : last <= tmp\r\n                ? tmp\r\n                : last\r\n            : last <= tmp\r\n              ? last\r\n              : penultimate <= tmp\r\n                ? tmp\r\n                : penultimate;\r\n        if (result[len - 1] !== median) {\r\n          result[len - 1] = median;\r\n          changed = true;\r\n        }\r\n      }\r\n\r\n      if (passes === -1 && !changed) {\r\n        break;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private smoothSplit(\r\n    arr: number[],\r\n    passes: number = DEFAULT_SPLIT_PASSES,\r\n    current: number = 0\r\n  ): number[] {\r\n    let result = [...arr];\r\n    const len = arr.length;\r\n\r\n    for (let pass = current; pass < passes || passes === -1; pass++) {\r\n      let changed = false;\r\n\r\n      for (let i = 2; i < len - 1; i++) {\r\n        const num = result[i];\r\n        const t1 = result[i - 1];\r\n        const t2 = result[i - 2];\r\n        const f1 = result[i + 1];\r\n\r\n        if (num === t1 && ((t1 > t2 && num > f1) || (t1 < t2 && num < f1))) {\r\n          // Apply smoothExtremes at split point in-place\r\n          const left = this.smoothExtremes(result.slice(0, i));\r\n          const right = this.smoothExtremes(result.slice(i));\r\n          result = left.concat(right);\r\n          changed = true;\r\n        }\r\n      }\r\n\r\n      if (passes === -1 && !changed) {\r\n        return result;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private smoothMedian(arr: number[], passes: number = 1, current: number = 0): number[] {\r\n    let result = arr;\r\n    const len = arr.length;\r\n    if (len <= 2) return [...arr];\r\n\r\n    for (let pass = current; pass < passes || passes === -1; pass++) {\r\n      const next = new Array<number>(len);\r\n      next[0] = result[0];\r\n      next[len - 1] = result[len - 1];\r\n\r\n      let changed = false;\r\n      for (let i = 1; i < len - 1; i++) {\r\n        const val = result[i];\r\n        const smoothed = Math.min(Math.max(result[i - 1], val), result[i + 1]);\r\n        next[i] = smoothed;\r\n        if (smoothed !== val) changed = true;\r\n      }\r\n\r\n      if (passes === -1 && !changed) {\r\n        return result;\r\n      }\r\n      result = next;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private jitter(\r\n    arr: number[],\r\n    passes: number = 1,\r\n    floor: number = NaN,\r\n    multiplier: number = DEFAULT_JITTER_MULTIPLIER,\r\n    weight: number = NaN,\r\n    current: number = 0\r\n  ): number[] {\r\n    const nextCurrent = current + 1;\r\n    const copy = [...arr];\r\n\r\n    if (nextCurrent <= passes) {\r\n      const jittered: number[] = [];\r\n      for (const num of copy) {\r\n        let w = weight;\r\n        if (!w && !isNaN(w)) {\r\n          w = (1 + Math.floor(num / 10)) * (Math.random() > 0.5 ? 1 : -1);\r\n        }\r\n        let value = num + Math.floor(Math.random() * multiplier * w);\r\n        if (!isNaN(floor) && value < floor) {\r\n          value = floor;\r\n        }\r\n        jittered.push(value);\r\n      }\r\n      return this.jitter(jittered, passes, floor, multiplier, weight, nextCurrent);\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  // Trimean (Tukey's trimean: (Q1 + 2*median + Q3) / 4)\r\n  trimean(): number {\r\n    const med = this.median();\r\n    const h = this.hinges();\r\n    if (h.length < 2) return med.datum;\r\n    return (h[0].datum + 2 * med.datum + h[1].datum) / 4;\r\n  }\r\n\r\n  // Letter values (depth-based summaries beyond hinges)\r\n  letterValues(): Array<{ letter: string; depth: number; lower: number; upper: number; mid: number; spread: number }> {\r\n    this.sorted();\r\n    const n = this.data.sorted!.length;\r\n    if (n < 2) return [];\r\n\r\n    const letters = ['M', 'F', 'E', 'D', 'C', 'B', 'A', 'Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S'];\r\n    const results: Array<{ letter: string; depth: number; lower: number; upper: number; mid: number; spread: number }> = [];\r\n\r\n    // M = median\r\n    const medDepth = (n + 1) / 2;\r\n    const medValue = this.median().datum;\r\n    results.push({\r\n      letter: 'M',\r\n      depth: medDepth,\r\n      lower: medValue,\r\n      upper: medValue,\r\n      mid: medValue,\r\n      spread: 0,\r\n    });\r\n\r\n    // Subsequent letter values\r\n    let depth = medDepth;\r\n    let letterIdx = 1;\r\n\r\n    while (depth > 1 && letterIdx < letters.length) {\r\n      depth = Math.floor((Math.floor(depth) + 1) / 2);\r\n      if (depth < 1) break;\r\n\r\n      const lowerIdx = Math.ceil(depth) - 1;\r\n      const upperIdx = n - Math.ceil(depth);\r\n\r\n      if (lowerIdx < 0 || upperIdx >= n || lowerIdx >= upperIdx) break;\r\n\r\n      const lower = this.data.sorted![lowerIdx];\r\n      const upper = this.data.sorted![upperIdx];\r\n      const mid = (lower + upper) / 2;\r\n      const spread = upper - lower;\r\n\r\n      results.push({\r\n        letter: letters[letterIdx],\r\n        depth,\r\n        lower,\r\n        upper,\r\n        mid,\r\n        spread,\r\n      });\r\n\r\n      letterIdx++;\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  // Rough (residuals: original - smooth)\r\n  rough(): number[] {\r\n    if (!this.data.rough) {\r\n      this.smooth();\r\n    }\r\n    return this.data.rough || [];\r\n  }\r\n\r\n  // Stem-and-leaf display (text-based visualization)\r\n  stemLeaf(leafDigits: number = 1): { stems: string[]; leaves: Record<string, string[]>; display: string[] } {\r\n    this.sorted();\r\n    const data = this.data.sorted!;\r\n    if (!data.length) return { stems: [], leaves: {}, display: [] };\r\n\r\n    const scale = Math.pow(10, leafDigits);\r\n    const stems = new Map<number, number[]>();\r\n\r\n    for (const val of data) {\r\n      const stem = Math.floor(val / scale);\r\n      const leaf = Math.abs(Math.round(val % scale));\r\n      if (!stems.has(stem)) {\r\n        stems.set(stem, []);\r\n      }\r\n      stems.get(stem)!.push(leaf);\r\n    }\r\n\r\n    const sortedStems = Array.from(stems.keys()).sort((a, b) => a - b);\r\n    const stemStrings: string[] = [];\r\n    const leavesRecord: Record<string, string[]> = {};\r\n    const display: string[] = [];\r\n\r\n    for (const stem of sortedStems) {\r\n      const stemStr = String(stem);\r\n      stemStrings.push(stemStr);\r\n      const leaves = stems.get(stem)!.sort((a, b) => a - b).map(String);\r\n      leavesRecord[stemStr] = leaves;\r\n      display.push(`${stemStr.padStart(4)} | ${leaves.join(' ')}`);\r\n    }\r\n\r\n    return { stems: stemStrings, leaves: leavesRecord, display };\r\n  }\r\n\r\n  // Mid-summaries (averages of symmetric quantile pairs)\r\n  midSummaries(): Array<{ depth: number; mid: number; spread: number }> {\r\n    const lv = this.letterValues();\r\n    return lv.map(({ depth, mid, spread }) => ({ depth, mid, spread }));\r\n  }\r\n\r\n  // Describe - full summary\r\n  describe(): SeriesDescription {\r\n    this.data.description = {\r\n      original: this.data.original,\r\n      summary: {\r\n        median: this.median(),\r\n        mean: this.mean(),\r\n        mode: this.mode(),\r\n        hinges: this.hinges(),\r\n        adjacent: this.adjacent(),\r\n        outliers: this.outliers(),\r\n        outer: this.outer(),\r\n        outside: this.outside(),\r\n        inside: this.inside(),\r\n        extremes: this.extremes(),\r\n        iqr: this.iqr(),\r\n        fences: this.fences(),\r\n      },\r\n      smooths: {\r\n        smooth: this.smooth(),\r\n        hanning: this.hanning(),\r\n      },\r\n      transforms: {\r\n        logs: this.logs(),\r\n        roots: this.roots(),\r\n        inverse: this.inverse(),\r\n      },\r\n      counts: this.counts(),\r\n      sorted: this.sorted(),\r\n      ranked: this.ranked(),\r\n      binned: this.binned(),\r\n    };\r\n    return this.data.description;\r\n  }\r\n}\r\n\r\n/**\r\n * Points class for n-dimensional data exploration\r\n */\r\nexport class Points {\r\n  private data: {\r\n    original: number[][];\r\n    centroid?: number[];\r\n    variances?: number[];\r\n    stddevs?: number[];\r\n    covarianceMatrix?: number[][];\r\n    correlationMatrix?: number[][];\r\n    mahalanobisDistances?: number[];\r\n    description?: PointsDescription;\r\n  };\r\n  private dimension: number;\r\n  private count: number;\r\n\r\n  constructor(options: PointsOptions | number = {}) {\r\n    if (typeof options === 'number') {\r\n      this.count = options;\r\n      this.dimension = DEFAULT_MAX_RANDOM_DIMENSIONALITY;\r\n      this.data = {\r\n        original: randomPoints(this.count, this.dimension),\r\n      };\r\n    } else {\r\n      this.dimension = options.dimensionality ?? 2;\r\n      this.count = options.count ?? 100;\r\n      this.data = {\r\n        original: options.data ?? randomPoints(this.count, this.dimension),\r\n      };\r\n      if (options.data && options.data.length > 0) {\r\n        this.dimension = options.data[0].length;\r\n        this.count = options.data.length;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Mean point across all dimensions\r\n  centroid(): number[] {\r\n    if (!this.data.centroid) {\r\n      const pts = this.data.original;\r\n      const dim = this.dimension;\r\n      const n = pts.length;\r\n      if (n === 0) {\r\n        this.data.centroid = [];\r\n        return this.data.centroid;\r\n      }\r\n      const sums = new Array<number>(dim).fill(0);\r\n      for (const pt of pts) {\r\n        for (let d = 0; d < dim; d += 1) {\r\n          sums[d] += pt[d] ?? 0;\r\n        }\r\n      }\r\n      this.data.centroid = sums.map((s) => s / n);\r\n    }\r\n    return this.data.centroid;\r\n  }\r\n\r\n  // Per-dimension sample variance\r\n  variances(): number[] {\r\n    if (!this.data.variances) {\r\n      const pts = this.data.original;\r\n      const dim = this.dimension;\r\n      const n = pts.length;\r\n      if (n < 2) {\r\n        this.data.variances = new Array<number>(dim).fill(NaN);\r\n        return this.data.variances;\r\n      }\r\n      const means = this.centroid();\r\n      const sums = new Array<number>(dim).fill(0);\r\n      for (const pt of pts) {\r\n        for (let d = 0; d < dim; d += 1) {\r\n          const delta = (pt[d] ?? 0) - means[d];\r\n          sums[d] += delta * delta;\r\n        }\r\n      }\r\n      this.data.variances = sums.map((s) => s / (n - 1));\r\n    }\r\n    return this.data.variances;\r\n  }\r\n\r\n  // Per-dimension standard deviation\r\n  standardDeviations(): number[] {\r\n    if (!this.data.stddevs) {\r\n      this.data.stddevs = this.variances().map((v) => Math.sqrt(v));\r\n    }\r\n    return this.data.stddevs;\r\n  }\r\n\r\n  // Full covariance matrix\r\n  covarianceMatrix(): number[][] {\r\n    if (!this.data.covarianceMatrix) {\r\n      const pts = this.data.original;\r\n      const dim = this.dimension;\r\n      const n = pts.length;\r\n      const means = this.centroid();\r\n\r\n      const cov: number[][] = Array.from({ length: dim }, () =>\r\n        new Array<number>(dim).fill(0),\r\n      );\r\n\r\n      if (n < 2) {\r\n        this.data.covarianceMatrix = cov;\r\n        return this.data.covarianceMatrix;\r\n      }\r\n\r\n      for (const pt of pts) {\r\n        for (let i = 0; i < dim; i += 1) {\r\n          const di = (pt[i] ?? 0) - means[i];\r\n          for (let j = i; j < dim; j += 1) {\r\n            const dj = (pt[j] ?? 0) - means[j];\r\n            cov[i][j] += di * dj;\r\n          }\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < dim; i += 1) {\r\n        for (let j = i; j < dim; j += 1) {\r\n          cov[i][j] /= n - 1;\r\n          cov[j][i] = cov[i][j];\r\n        }\r\n      }\r\n\r\n      this.data.covarianceMatrix = cov;\r\n    }\r\n    return this.data.covarianceMatrix;\r\n  }\r\n\r\n  // Pearson correlation matrix\r\n  correlationMatrix(): number[][] {\r\n    if (!this.data.correlationMatrix) {\r\n      const cov = this.covarianceMatrix();\r\n      const dim = this.dimension;\r\n      const stddevs = this.standardDeviations();\r\n\r\n      const corr: number[][] = Array.from({ length: dim }, () =>\r\n        new Array<number>(dim).fill(0),\r\n      );\r\n\r\n      for (let i = 0; i < dim; i += 1) {\r\n        for (let j = 0; j < dim; j += 1) {\r\n          const denom = stddevs[i] * stddevs[j];\r\n          corr[i][j] = denom === 0 ? (i === j ? 1 : 0) : cov[i][j] / denom;\r\n        }\r\n      }\r\n\r\n      this.data.correlationMatrix = corr;\r\n    }\r\n    return this.data.correlationMatrix;\r\n  }\r\n\r\n  // Mahalanobis distance of a single point from the distribution\r\n  mahalanobis(point: number[]): number {\r\n    const means = this.centroid();\r\n    const vars = this.variances();\r\n    const dim = Math.min(point.length, means.length, vars.length);\r\n    if (dim === 0) return 0;\r\n\r\n    let sum = 0;\r\n    for (let i = 0; i < dim; i += 1) {\r\n      const delta = (point[i] ?? 0) - means[i];\r\n      const v = Math.max(vars[i], 1e-8);\r\n      sum += (delta * delta) / v;\r\n    }\r\n    return Math.sqrt(sum);\r\n  }\r\n\r\n  // Mahalanobis distance for each stored point\r\n  mahalanobisAll(): number[] {\r\n    if (!this.data.mahalanobisDistances) {\r\n      const means = this.centroid();\r\n      const vars = this.variances();\r\n      this.data.mahalanobisDistances = this.data.original.map((pt) => {\r\n        const dim = Math.min(pt.length, means.length, vars.length);\r\n        let sum = 0;\r\n        for (let i = 0; i < dim; i += 1) {\r\n          const delta = (pt[i] ?? 0) - means[i];\r\n          const v = Math.max(vars[i], 1e-8);\r\n          sum += (delta * delta) / v;\r\n        }\r\n        return Math.sqrt(sum);\r\n      });\r\n    }\r\n    return this.data.mahalanobisDistances;\r\n  }\r\n\r\n  // Outlier detection: points with Mahalanobis distance > threshold\r\n  outliersByMahalanobis(threshold: number = 3.0): number[][] {\r\n    const distances = this.mahalanobisAll();\r\n    const results: number[][] = [];\r\n    for (let i = 0; i < distances.length; i += 1) {\r\n      if (distances[i] > threshold) {\r\n        results.push(this.data.original[i]);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n  // L2-normalize all points (returns new Points)\r\n  normalizeL2(): Points {\r\n    const normalized = this.data.original.map((pt) => {\r\n      let sumSq = 0;\r\n      for (const v of pt) {\r\n        sumSq += v * v;\r\n      }\r\n      const mag = Math.sqrt(sumSq);\r\n      if (mag === 0) return pt.map(() => 0);\r\n      return pt.map((v) => v / mag);\r\n    });\r\n    return new Points({ data: normalized });\r\n  }\r\n\r\n  // Z-score normalize per dimension (returns new Points)\r\n  normalizeZscore(): Points {\r\n    const means = this.centroid();\r\n    const stddevs = this.standardDeviations();\r\n    const dim = this.dimension;\r\n\r\n    const normalized = this.data.original.map((pt) => {\r\n      const result = new Array<number>(dim);\r\n      for (let d = 0; d < dim; d += 1) {\r\n        const s = stddevs[d];\r\n        result[d] = s === 0 || isNaN(s) ? 0 : ((pt[d] ?? 0) - means[d]) / s;\r\n      }\r\n      return result;\r\n    });\r\n    return new Points({ data: normalized });\r\n  }\r\n\r\n  // Full description\r\n  describe(): PointsDescription {\r\n    const distances = this.mahalanobisAll();\r\n    const outlierCount = distances.filter((d) => d > 3.0).length;\r\n\r\n    // Build per-dimension Series summaries\r\n    const dim = this.dimension;\r\n    const dimensionSummaries: SeriesDescription[] = [];\r\n    for (let d = 0; d < dim; d += 1) {\r\n      const values = this.data.original.map((pt) => pt[d] ?? 0);\r\n      const series = new Series({ data: values });\r\n      dimensionSummaries.push(series.describe());\r\n    }\r\n\r\n    this.data.description = {\r\n      original: this.data.original,\r\n      centroid: this.centroid(),\r\n      variances: this.variances(),\r\n      correlationMatrix: this.correlationMatrix(),\r\n      mahalanobisDistances: distances,\r\n      outlierCount,\r\n      dimensionSummaries,\r\n    };\r\n    return this.data.description;\r\n  }\r\n}\r\n\r\n/**\r\n * Main Twokeys class - factory for Series and Points\r\n */\r\nexport class Twokeys {\r\n  public smoothed: boolean = false;\r\n\r\n  // Constants\r\n  static readonly DEFAULT_MAX_RANDOM_INTEGER = DEFAULT_MAX_RANDOM_INTEGER;\r\n  static readonly DEFAULT_MIN_RANDOM_INTEGER = DEFAULT_MIN_RANDOM_INTEGER;\r\n  static readonly DEFAULT_RANDOM_SERIES_COUNT = DEFAULT_RANDOM_SERIES_COUNT;\r\n  static readonly DEFAULT_OUTLIER_MULTIPLE = DEFAULT_OUTLIER_MULTIPLE;\r\n  static readonly DEFAULT_JITTER_MULTIPLIER = DEFAULT_JITTER_MULTIPLIER;\r\n  static readonly DEFAULT_SPLIT_PASSES = DEFAULT_SPLIT_PASSES;\r\n  static readonly DEFAULT_MAX_RANDOM_DIMENSIONALITY = DEFAULT_MAX_RANDOM_DIMENSIONALITY;\r\n\r\n  // Static factory methods\r\n  static Series = Series;\r\n  static Points = Points;\r\n\r\n  // Utility methods\r\n  static randomInteger = randomInteger;\r\n  static randomSeries = randomSeries;\r\n  static randomPoint = randomPoint;\r\n  static randomPoints = randomPoints;\r\n}\r\n\r\nexport * from './distance';\r\nexport * from './graph';\r\nexport * from './graph-eda';\r\n\r\n// Default export\r\nexport default Twokeys;\r\n"]}