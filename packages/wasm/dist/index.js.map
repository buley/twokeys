{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @buley/twokeys-wasm — WASM-accelerated statistics, distance & analysis\n *\n * Automatically uses WebAssembly when available, falls back to TypeScript.\n * Covers the full v3 API surface: Series statistics, distance functions,\n * outlier detection, transforms, smoothing, and comprehensive analysis.\n */\n\nimport type {\n  MedianResult,\n  ModeResult,\n  RankedResult,\n  BinnedResult,\n  SeriesDescription,\n} from '@buley/twokeys-types';\n\n// Re-export types consumers need\nexport type {\n  MedianResult,\n  ModeResult,\n  RankedResult,\n  BinnedResult,\n  SeriesDescription,\n} from '@buley/twokeys-types';\n\n// =============================================================================\n// Additional types\n// =============================================================================\n\nexport interface LetterValue {\n  letter: string;\n  depth: number;\n  lower: number;\n  upper: number;\n  mid: number;\n  spread: number;\n}\n\nexport interface StemLeafResult {\n  stems: string[];\n  leaves: Record<string, string[]>;\n  display: string[];\n}\n\nexport interface MidSummary {\n  depth: number;\n  mid: number;\n  spread: number;\n}\n\nexport interface AnalysisResult extends SeriesDescription {\n  implementation: 'wasm' | 'typescript';\n}\n\n// =============================================================================\n// TypeScript fallback implementations\n// =============================================================================\n\n// --- Sorting ----------------------------------------------------------------\n\nfunction tsSorted(arr: number[]): number[] {\n  return [...arr].sort((a, b) => a - b);\n}\n\n// --- Core Statistics --------------------------------------------------------\n\nfunction tsMean(arr: number[]): number {\n  if (!arr.length) return NaN;\n  let sum = 0;\n  for (const n of arr) sum += n;\n  return sum / arr.length;\n}\n\nfunction tsMedian(sorted: number[]): number {\n  const len = sorted.length;\n  if (!len) return NaN;\n  if (len === 1) return sorted[0];\n  const mid = Math.floor(len / 2);\n  return len % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];\n}\n\nfunction tsMedianDepth(length: number, offset: number = 0): number {\n  if (!length) return NaN;\n  return offset + (length + 1) / 2;\n}\n\nfunction tsMode(data: number[]): ModeResult {\n  if (!data.length) return { count: 0, data: [] };\n  const freq = new Map<number, number>();\n  let maxCount = 0;\n  for (const val of data) {\n    const count = (freq.get(val) || 0) + 1;\n    freq.set(val, count);\n    if (count > maxCount) maxCount = count;\n  }\n  const modes: number[] = [];\n  for (const [val, count] of freq) {\n    if (count === maxCount) modes.push(val);\n  }\n  return { count: maxCount, data: modes.sort((a, b) => a - b) };\n}\n\nfunction tsExtremes(sorted: number[]): [number, number] {\n  if (!sorted.length) return [NaN, NaN];\n  return [sorted[0], sorted[sorted.length - 1]];\n}\n\nfunction tsVariance(data: number[]): number {\n  if (data.length < 2) return NaN;\n  const m = tsMean(data);\n  let sum = 0;\n  for (const val of data) {\n    const delta = val - m;\n    sum += delta * delta;\n  }\n  return sum / (data.length - 1);\n}\n\nfunction tsStddev(data: number[]): number {\n  return Math.sqrt(tsVariance(data));\n}\n\nfunction tsSkewness(data: number[]): number {\n  const n = data.length;\n  if (n < 3) return NaN;\n  const m = tsMean(data);\n  const s = tsStddev(data);\n  if (s === 0) return 0;\n  let sum = 0;\n  for (const val of data) {\n    const z = (val - m) / s;\n    sum += z * z * z;\n  }\n  return (n / ((n - 1) * (n - 2))) * sum;\n}\n\nfunction tsKurtosis(data: number[]): number {\n  const n = data.length;\n  if (n < 4) return NaN;\n  const m = tsMean(data);\n  const s = tsStddev(data);\n  if (s === 0) return 0;\n  let sum = 0;\n  for (const val of data) {\n    const z = (val - m) / s;\n    sum += z * z * z * z;\n  }\n  const rawKurt = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3)) * sum;\n  const correction = (3 * (n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n  return rawKurt - correction;\n}\n\n// --- Quartiles & Fences -----------------------------------------------------\n\nfunction tsHinges(sorted: number[]): MedianResult[] {\n  const len = sorted.length;\n  if (len < 4) return [];\n  const per = Math.floor(len / 2);\n  const q1Slice = sorted.slice(0, per);\n  const q3Slice = sorted.slice(per);\n  return [\n    { datum: tsMedian(q1Slice), depth: tsMedianDepth(per, 0) },\n    { datum: tsMedian(q3Slice), depth: tsMedianDepth(q3Slice.length, per) },\n  ];\n}\n\nfunction tsIqr(h: MedianResult[]): number {\n  if (h.length < 2) return NaN;\n  return Math.abs(h[1].datum - h[0].datum);\n}\n\nfunction tsFences(med: number, iqrVal: number, multiple: number = 1.5): [number, number] {\n  if (isNaN(med) || isNaN(iqrVal)) return [NaN, NaN];\n  const extra = iqrVal * multiple;\n  return [med - extra, med + extra];\n}\n\nfunction tsOuterFences(med: number, iqrVal: number, multiple: number = 1.5): [number, number] {\n  if (isNaN(med) || isNaN(iqrVal)) return [NaN, NaN];\n  const extra = 2 * iqrVal * multiple;\n  return [med - extra, med + extra];\n}\n\nfunction tsOutliers(sortedData: number[], f: [number, number]): number[] {\n  if (isNaN(f[0]) || isNaN(f[1])) return [];\n  return sortedData.filter((n) => n < f[0] || n > f[1]);\n}\n\n// --- Filtering --------------------------------------------------------------\n\nfunction tsAdjacent(sortedData: number[], f: number[]): number[] {\n  if (f.length === 0) return [];\n  const low = f[0];\n  const high = f[1];\n  const lows: number[] = [];\n  const highs: number[] = [];\n  for (const val of sortedData) {\n    if (val > low) lows.push(val);\n    if (val < high) highs.push(val);\n  }\n  lows.sort((a, b) => a - b);\n  highs.sort((a, b) => a - b);\n  return [lows[0], highs[highs.length - 1]];\n}\n\nfunction tsInside(sortedData: number[], f: number[]): number[] {\n  if (f.length === 0) return [];\n  const lo = Math.min(...f);\n  const hi = Math.max(...f);\n  return sortedData.filter((n) => n > lo && n < hi);\n}\n\nfunction tsOutside(sortedData: number[], outer: number[]): number[] {\n  if (outer.length === 0) return [];\n  const lo = Math.min(...outer);\n  const hi = Math.max(...outer);\n  return sortedData.filter((n) => n < lo || n > hi);\n}\n\n// --- Ordering ---------------------------------------------------------------\n\nfunction tsCounts(sortedData: number[]): [number, number][] {\n  const freq = new Map<number, number>();\n  for (const val of sortedData) {\n    freq.set(val, (freq.get(val) || 0) + 1);\n  }\n  const result: [number, number][] = [];\n  for (const [val, count] of freq) {\n    result.push([val, count]);\n  }\n  return result.sort((a, b) => a[0] - b[0]);\n}\n\nfunction tsRanked(sortedData: number[]): RankedResult {\n  const up: Record<number, { rank: number; peers: number }> = {};\n  const down: Record<number, { rank: number; peers: number }> = {};\n  const total = sortedData.length;\n  const ranked: (number | number[])[] = [];\n\n  let tiedRank = NaN;\n  let tiedNumbers: number[] = [];\n\n  const reset = (): void => {\n    tiedRank = NaN;\n    tiedNumbers = [];\n  };\n\n  for (let i = 0; i < sortedData.length; i++) {\n    const num = sortedData[i];\n    const incr = i + 1;\n    const decr = i - 1;\n\n    if (num === sortedData[decr]) {\n      if (!isNaN(tiedRank) && tiedNumbers.length === 0) {\n        tiedNumbers.push(num);\n        ranked.push(tiedNumbers);\n        reset();\n      } else {\n        tiedNumbers.push(num);\n        tiedRank = decr;\n      }\n      if (num !== sortedData[incr]) {\n        ranked.push(tiedNumbers);\n        reset();\n      }\n    } else {\n      if (num !== sortedData[incr]) {\n        if (tiedNumbers.length > 0) {\n          ranked.push(tiedNumbers);\n          reset();\n        } else {\n          ranked.push(num);\n        }\n      } else {\n        tiedNumbers.push(num);\n      }\n    }\n  }\n\n  let offset = 0;\n  for (let i = 0; i < ranked.length; i++) {\n    const item = ranked[i];\n    if (typeof item === 'number') {\n      down[item] = { rank: i + 1 + offset, peers: 0 };\n      up[item] = { rank: total - i - offset, peers: 0 };\n    } else if (Array.isArray(item)) {\n      offset += item.length;\n      const usable = item[0];\n      down[usable] = { rank: i + 1 + offset, peers: item.length };\n      up[usable] = { rank: total - i - offset, peers: item.length };\n    } else {\n      offset += 1;\n    }\n  }\n\n  return {\n    up,\n    down,\n    groups: {\n      down: [...ranked],\n      up: [...ranked].reverse(),\n    },\n  };\n}\n\nfunction tsBinned(sortedData: number[], ext: number[]): BinnedResult {\n  const binned: Record<number, { from: number; to: number; data: number[] }> = {};\n  const total = sortedData.length;\n\n  if (total === 0 || ext.length < 2) {\n    return { bins: 0, width: NaN, binned: {} };\n  }\n\n  let width = (ext[1] - ext[0]) / (Math.log(sortedData.length) / Math.LN2);\n  width = Math.floor(width);\n  if (width < 1) width = 1;\n\n  let binCount = Math.floor(ext[1] / width) + 1;\n  if (!binCount || binCount < 1) binCount = 1;\n\n  for (const val of sortedData) {\n    const bin = Math.floor(val / width);\n    if (!binned[bin]) {\n      binned[bin] = {\n        from: bin * width,\n        to: (bin + 1) * width - 1,\n        data: [],\n      };\n    }\n    binned[bin].data.push(val);\n  }\n\n  return { bins: binCount, width, binned };\n}\n\n// --- Transforms -------------------------------------------------------------\n\nfunction tsLogs(arr: number[]): number[] {\n  return arr.map((n) => Math.log(n));\n}\n\nfunction tsRoots(arr: number[]): number[] {\n  return arr.map((n) => Math.sqrt(n));\n}\n\nfunction tsInverse(arr: number[]): number[] {\n  return arr.map((n) => 1 / n);\n}\n\nfunction tsZscore(data: number[]): number[] {\n  const m = tsMean(data);\n  const s = tsStddev(data);\n  if (s === 0 || isNaN(s)) return data.map(() => 0);\n  return data.map((val) => (val - m) / s);\n}\n\n// --- Smoothing --------------------------------------------------------------\n\nfunction tsHanning(arr: number[]): number[] {\n  if (arr.length < 2) return [...arr];\n  const result: number[] = [arr[0]];\n  for (let i = 1; i < arr.length - 1; i++) {\n    result.push((arr[i] + arr[i + 1]) / 2);\n  }\n  result.push(arr[arr.length - 1]);\n  return result;\n}\n\nfunction tsSmoothMedian(arr: number[]): number[] {\n  if (arr.length <= 2) return [...arr];\n  const result = new Array<number>(arr.length);\n  result[0] = arr[0];\n  result[arr.length - 1] = arr[arr.length - 1];\n  for (let i = 1; i < arr.length - 1; i++) {\n    result[i] = Math.min(Math.max(arr[i - 1], arr[i]), arr[i + 1]);\n  }\n  return result;\n}\n\nfunction tsSmoothExtremes(arr: number[]): number[] {\n  if (arr.length <= 2) return [...arr];\n  const result = [...arr];\n  // Head\n  const tmpHead = arr[1] - 2 * (arr[2] - arr[1]);\n  const candidates = [arr[0], arr[1], tmpHead].sort((a, b) => a - b);\n  result[0] = candidates[1];\n  // Tail\n  const tmpTail = arr[arr.length - 2] - 2 * (arr[arr.length - 3] - arr[arr.length - 2]);\n  const tailCandidates = [arr[arr.length - 1], arr[arr.length - 2], tmpTail].sort((a, b) => a - b);\n  result[arr.length - 1] = tailCandidates[1];\n  return result;\n}\n\nfunction tsSmooth(arr: number[]): number[] {\n  let result = [...arr];\n  for (let i = 0; i < 3; i++) result = tsSmoothMedian(result);\n  result = tsSmoothExtremes(result);\n  for (let i = 0; i < 3; i++) result = tsSmoothMedian(result);\n  result = tsSmoothExtremes(result);\n  for (let i = 0; i < 3; i++) result = tsSmoothMedian(result);\n  return result;\n}\n\nfunction tsEma(data: number[], alpha: number): number[] {\n  if (data.length === 0) return [];\n  const result: number[] = [data[0]];\n  for (let i = 1; i < data.length; i++) {\n    result.push(result[i - 1] * (1 - alpha) + data[i] * alpha);\n  }\n  return result;\n}\n\nfunction tsRough(original: number[], smoothed: number[]): number[] {\n  const result: number[] = [];\n  for (let i = 0; i < original.length; i++) {\n    result.push(original[i] - (smoothed[i] ?? 0));\n  }\n  return result;\n}\n\n// --- Summaries --------------------------------------------------------------\n\nfunction tsTrimean(q1: number, med: number, q3: number): number {\n  return (q1 + 2 * med + q3) / 4;\n}\n\nfunction tsLetterValues(sortedData: number[], medResult: MedianResult): LetterValue[] {\n  const n = sortedData.length;\n  if (n < 2) return [];\n\n  const letters = ['M', 'F', 'E', 'D', 'C', 'B', 'A', 'Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S'];\n  const results: LetterValue[] = [];\n\n  const medDepth = (n + 1) / 2;\n  results.push({\n    letter: 'M',\n    depth: medDepth,\n    lower: medResult.datum,\n    upper: medResult.datum,\n    mid: medResult.datum,\n    spread: 0,\n  });\n\n  let depth = medDepth;\n  let letterIdx = 1;\n\n  while (depth > 1 && letterIdx < letters.length) {\n    depth = Math.floor((Math.floor(depth) + 1) / 2);\n    if (depth < 1) break;\n\n    const lowerIdx = Math.ceil(depth) - 1;\n    const upperIdx = n - Math.ceil(depth);\n    if (lowerIdx < 0 || upperIdx >= n || lowerIdx >= upperIdx) break;\n\n    const lower = sortedData[lowerIdx];\n    const upper = sortedData[upperIdx];\n    results.push({\n      letter: letters[letterIdx],\n      depth,\n      lower,\n      upper,\n      mid: (lower + upper) / 2,\n      spread: upper - lower,\n    });\n    letterIdx++;\n  }\n\n  return results;\n}\n\nfunction tsStemLeaf(sortedData: number[], leafDigits: number = 1): StemLeafResult {\n  if (!sortedData.length) return { stems: [], leaves: {}, display: [] };\n\n  const scale = Math.pow(10, leafDigits);\n  const stemMap = new Map<number, number[]>();\n\n  for (const val of sortedData) {\n    const stem = Math.floor(val / scale);\n    const leaf = Math.abs(Math.round(val % scale));\n    if (!stemMap.has(stem)) stemMap.set(stem, []);\n    stemMap.get(stem)!.push(leaf);\n  }\n\n  const stemKeys = Array.from(stemMap.keys()).sort((a, b) => a - b);\n  const stems: string[] = [];\n  const leaves: Record<string, string[]> = {};\n  const display: string[] = [];\n\n  for (const stem of stemKeys) {\n    const stemStr = String(stem);\n    stems.push(stemStr);\n    const leafArr = stemMap.get(stem)!.sort((a, b) => a - b).map(String);\n    leaves[stemStr] = leafArr;\n    display.push(`${stemStr.padStart(4)} | ${leafArr.join(' ')}`);\n  }\n\n  return { stems, leaves, display };\n}\n\n// --- Distance (TS fallbacks) ------------------------------------------------\n\nfunction tsCosineSimilarity(a: number[], b: number[]): number {\n  const len = Math.min(a.length, b.length);\n  if (len === 0) return 0;\n  let dot = 0, magA = 0, magB = 0;\n  for (let i = 0; i < len; i++) {\n    dot += a[i] * b[i];\n    magA += a[i] * a[i];\n    magB += b[i] * b[i];\n  }\n  const denom = Math.sqrt(magA) * Math.sqrt(magB);\n  return denom === 0 ? 0 : dot / denom;\n}\n\nfunction tsSqEuclideanDistance(a: number[], b: number[]): number {\n  let sum = 0;\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const delta = (a[i] ?? 0) - (b[i] ?? 0);\n    sum += delta * delta;\n  }\n  return sum;\n}\n\nfunction tsEuclideanDistance(a: number[], b: number[]): number {\n  return Math.sqrt(tsSqEuclideanDistance(a, b));\n}\n\nfunction tsManhattanDistance(a: number[], b: number[]): number {\n  let sum = 0;\n  const len = Math.max(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    sum += Math.abs((a[i] ?? 0) - (b[i] ?? 0));\n  }\n  return sum;\n}\n\nfunction tsMahalanobisDistance(\n  point: number[],\n  means: number[],\n  variances: number[],\n  epsilon: number = 1e-8,\n): number {\n  const len = Math.min(point.length, means.length, variances.length);\n  if (len === 0) return 0;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    const delta = (point[i] ?? 0) - (means[i] ?? 0);\n    const v = Math.max(variances[i] ?? 0, epsilon);\n    sum += (delta * delta) / v;\n  }\n  return Math.sqrt(sum);\n}\n\nfunction tsNormalizeL2(vector: number[]): number[] {\n  let sumSq = 0;\n  for (const v of vector) sumSq += v * v;\n  const mag = Math.sqrt(sumSq);\n  if (mag === 0) return vector.map(() => 0);\n  return vector.map((v) => v / mag);\n}\n\n// =============================================================================\n// WASM Loading\n// =============================================================================\n\ninterface WasmExports {\n  // v2 functions\n  sort: (data: Float64Array) => Float64Array;\n  mean: (data: Float64Array) => number;\n  median: (data: Float64Array) => number;\n  medianSorted: (sorted: Float64Array) => number;\n  medianDepth: (length: number, offset?: number) => number;\n  mode: (data: Float64Array) => Float64Array;\n  extremes: (data: Float64Array) => Float64Array;\n  extremesSorted: (sorted: Float64Array) => Float64Array;\n  hingesSorted: (sorted: Float64Array) => Float64Array;\n  iqrFromHinges: (hinges: Float64Array) => number;\n  fences: (median: number, iqr: number, multiple?: number) => Float64Array;\n  outerFences: (median: number, iqr: number, multiple?: number) => Float64Array;\n  outliers: (sorted: Float64Array, fenceLow: number, fenceHigh: number) => Float64Array;\n  logs: (data: Float64Array) => Float64Array;\n  roots: (data: Float64Array) => Float64Array;\n  inverse: (data: Float64Array) => Float64Array;\n  hanning: (data: Float64Array) => Float64Array;\n  smooth: (data: Float64Array) => Float64Array;\n  // v3 statistics\n  variance: (data: Float64Array) => number;\n  stddev: (data: Float64Array) => number;\n  skewness: (data: Float64Array) => number;\n  kurtosis: (data: Float64Array) => number;\n  emaCalc: (data: Float64Array, alpha: number) => Float64Array;\n  zscoreCalc: (data: Float64Array) => Float64Array;\n  roughCalc: (original: Float64Array, smoothed: Float64Array) => Float64Array;\n  // v3 distance\n  cosineSim: (a: Float64Array, b: Float64Array) => number;\n  sqEuclideanDist: (a: Float64Array, b: Float64Array) => number;\n  euclideanDist: (a: Float64Array, b: Float64Array) => number;\n  manhattanDist: (a: Float64Array, b: Float64Array) => number;\n  mahalanobisDist: (point: Float64Array, means: Float64Array, variances: Float64Array) => number;\n  normalizeL2Vec: (vector: Float64Array) => Float64Array;\n}\n\nlet wasmInstance: WasmExports | null = null;\nlet wasmLoadPromise: Promise<WasmExports | null> | null = null;\n\n/**\n * Load WASM module. Falls back to TypeScript if unavailable.\n */\nexport async function loadWasm(): Promise<WasmExports | null> {\n  if (wasmInstance) return wasmInstance;\n  if (wasmLoadPromise) return wasmLoadPromise;\n\n  wasmLoadPromise = (async () => {\n    try {\n      const wasmUrl = new URL('../build/release.wasm', import.meta.url);\n      const response = await fetch(wasmUrl);\n      const wasmBuffer = await response.arrayBuffer();\n      const wasmModule = await WebAssembly.instantiate(wasmBuffer);\n      wasmInstance = wasmModule.instance.exports as unknown as WasmExports;\n      return wasmInstance;\n    } catch {\n      console.warn('@buley/twokeys-wasm: WASM not available, using TypeScript fallback');\n      return null;\n    }\n  })();\n\n  return wasmLoadPromise;\n}\n\n/**\n * Check if WASM is loaded and available.\n */\nexport function isWasmLoaded(): boolean {\n  return wasmInstance !== null;\n}\n\n// =============================================================================\n// Hybrid API — Sorting\n// =============================================================================\n\n/** Sort array ascending. */\nexport function sorted(data: number[]): number[] {\n  if (wasmInstance) {\n    return Array.from(wasmInstance.sort(new Float64Array(data)));\n  }\n  return tsSorted(data);\n}\n\n// =============================================================================\n// Hybrid API — Core Statistics\n// =============================================================================\n\n/** Arithmetic mean. */\nexport function mean(data: number[]): number {\n  if (wasmInstance) return wasmInstance.mean(new Float64Array(data));\n  return tsMean(data);\n}\n\n/** Median value and depth. */\nexport function median(data: number[]): MedianResult {\n  const s = sorted(data);\n  const datum = wasmInstance\n    ? wasmInstance.medianSorted(new Float64Array(s))\n    : tsMedian(s);\n  const depth = wasmInstance\n    ? wasmInstance.medianDepth(data.length)\n    : tsMedianDepth(data.length);\n  return { datum, depth };\n}\n\n/** Mode (most frequent values). */\nexport function mode(data: number[]): ModeResult {\n  if (wasmInstance) {\n    const result = wasmInstance.mode(new Float64Array(data));\n    return { count: result[0], data: Array.from(result.slice(1)) };\n  }\n  return tsMode(data);\n}\n\n/** [min, max] values. */\nexport function extremes(data: number[]): [number, number] {\n  if (wasmInstance) {\n    const result = wasmInstance.extremes(new Float64Array(data));\n    return [result[0], result[1]];\n  }\n  return tsExtremes(tsSorted(data));\n}\n\n/** Sample variance: Σ(x - mean)² / (n - 1). */\nexport function variance(data: number[]): number {\n  if (wasmInstance) return wasmInstance.variance(new Float64Array(data));\n  return tsVariance(data);\n}\n\n/** Standard deviation. */\nexport function stddev(data: number[]): number {\n  if (wasmInstance) return wasmInstance.stddev(new Float64Array(data));\n  return tsStddev(data);\n}\n\n/** Fisher-Pearson skewness. */\nexport function skewness(data: number[]): number {\n  if (wasmInstance) return wasmInstance.skewness(new Float64Array(data));\n  return tsSkewness(data);\n}\n\n/** Excess kurtosis. */\nexport function kurtosis(data: number[]): number {\n  if (wasmInstance) return wasmInstance.kurtosis(new Float64Array(data));\n  return tsKurtosis(data);\n}\n\n// =============================================================================\n// Hybrid API — Quartiles & Outlier Detection\n// =============================================================================\n\n/** Quartile boundaries (Q1, Q3). */\nexport function hinges(data: number[]): MedianResult[] {\n  const s = sorted(data);\n  if (wasmInstance) {\n    const result = wasmInstance.hingesSorted(new Float64Array(s));\n    if (isNaN(result[0])) return [];\n    return [\n      { datum: result[0], depth: result[1] },\n      { datum: result[2], depth: result[3] },\n    ];\n  }\n  return tsHinges(s);\n}\n\n/** Interquartile range. */\nexport function iqr(data: number[]): number {\n  return tsIqr(hinges(data));\n}\n\n/** Inner fence boundaries (1.5 × IQR from median). */\nexport function fences(data: number[], multiple: number = 1.5): [number, number] {\n  const s = sorted(data);\n  const med = wasmInstance\n    ? wasmInstance.medianSorted(new Float64Array(s))\n    : tsMedian(s);\n  const iqrVal = tsIqr(hinges(data));\n  if (wasmInstance) {\n    const result = wasmInstance.fences(med, iqrVal, multiple);\n    return [result[0], result[1]];\n  }\n  return tsFences(med, iqrVal, multiple);\n}\n\n/** Outer fence boundaries (3 × IQR from median). */\nexport function outerFences(data: number[], multiple: number = 1.5): [number, number] {\n  const s = sorted(data);\n  const med = wasmInstance\n    ? wasmInstance.medianSorted(new Float64Array(s))\n    : tsMedian(s);\n  const iqrVal = tsIqr(hinges(data));\n  if (wasmInstance) {\n    const result = wasmInstance.outerFences(med, iqrVal, multiple);\n    return [result[0], result[1]];\n  }\n  return tsOuterFences(med, iqrVal, multiple);\n}\n\n/** Values outside inner fences. */\nexport function outliers(data: number[], multiple: number = 1.5): number[] {\n  const s = sorted(data);\n  const f = fences(data, multiple);\n  if (wasmInstance) {\n    return Array.from(wasmInstance.outliers(new Float64Array(s), f[0], f[1]));\n  }\n  return tsOutliers(s, f);\n}\n\n/** Most extreme non-outlier values. */\nexport function adjacent(data: number[]): number[] {\n  const s = sorted(data);\n  const f = fences(data);\n  return tsAdjacent(s, f);\n}\n\n/** Values within inner fences. */\nexport function inside(data: number[]): number[] {\n  const s = sorted(data);\n  const f = fences(data);\n  return tsInside(s, f);\n}\n\n/** Values outside outer fences. */\nexport function outside(data: number[]): number[] {\n  const s = sorted(data);\n  const outer = outerFences(data);\n  return tsOutside(s, outer);\n}\n\n// =============================================================================\n// Hybrid API — Ordering\n// =============================================================================\n\n/** Frequency of each value as [value, count] pairs. */\nexport function counts(data: number[]): [number, number][] {\n  return tsCounts(sorted(data));\n}\n\n/** Rank information with tie handling. */\nexport function ranked(data: number[]): RankedResult {\n  return tsRanked(sorted(data));\n}\n\n/** Histogram-style binning. */\nexport function binned(data: number[]): BinnedResult {\n  const s = sorted(data);\n  const ext = s.length ? [s[0], s[s.length - 1]] : [];\n  return tsBinned(s, ext);\n}\n\n// =============================================================================\n// Hybrid API — Transforms\n// =============================================================================\n\n/** Natural logarithm of each value. */\nexport function logs(data: number[]): number[] {\n  if (wasmInstance) return Array.from(wasmInstance.logs(new Float64Array(data)));\n  return tsLogs(data);\n}\n\n/** Square root of each value. */\nexport function roots(data: number[]): number[] {\n  if (wasmInstance) return Array.from(wasmInstance.roots(new Float64Array(data)));\n  return tsRoots(data);\n}\n\n/** Reciprocal (1/x) of each value. */\nexport function inverse(data: number[]): number[] {\n  if (wasmInstance) return Array.from(wasmInstance.inverse(new Float64Array(data)));\n  return tsInverse(data);\n}\n\n/** Z-score normalization: (x - mean) / stddev. */\nexport function zscore(data: number[]): number[] {\n  if (wasmInstance) return Array.from(wasmInstance.zscoreCalc(new Float64Array(data)));\n  return tsZscore(data);\n}\n\n// =============================================================================\n// Hybrid API — Smoothing\n// =============================================================================\n\n/** Hanning filter (running weighted average). */\nexport function hanning(data: number[]): number[] {\n  if (wasmInstance) return Array.from(wasmInstance.hanning(new Float64Array(data)));\n  return tsHanning(data);\n}\n\n/** Tukey's 3RSSH smoothing. */\nexport function smooth(data: number[]): number[] {\n  if (wasmInstance) return Array.from(wasmInstance.smooth(new Float64Array(data)));\n  return tsSmooth(data);\n}\n\n/** Residuals (original - smooth). */\nexport function rough(data: number[]): number[] {\n  const smoothed = smooth(data);\n  if (wasmInstance) {\n    return Array.from(\n      wasmInstance.roughCalc(new Float64Array(data), new Float64Array(smoothed)),\n    );\n  }\n  return tsRough(data, smoothed);\n}\n\n/** Exponential moving average. */\nexport function ema(data: number[], alpha: number): number[] {\n  if (wasmInstance) return Array.from(wasmInstance.emaCalc(new Float64Array(data), alpha));\n  return tsEma(data, alpha);\n}\n\n// =============================================================================\n// Hybrid API — Summaries\n// =============================================================================\n\n/** Tukey's trimean: (Q1 + 2×median + Q3) / 4. */\nexport function trimean(data: number[]): number {\n  const med = median(data);\n  const h = hinges(data);\n  if (h.length < 2) return med.datum;\n  return tsTrimean(h[0].datum, med.datum, h[1].datum);\n}\n\n/** Letter values (extended quartiles: M, F, E, D, C, B, A...). */\nexport function letterValues(data: number[]): LetterValue[] {\n  const s = sorted(data);\n  const med = median(data);\n  return tsLetterValues(s, med);\n}\n\n/** Stem-and-leaf text display. */\nexport function stemLeaf(data: number[], leafDigits: number = 1): StemLeafResult {\n  return tsStemLeaf(sorted(data), leafDigits);\n}\n\n/** Mid-summaries (averages of symmetric quantile pairs). */\nexport function midSummaries(data: number[]): MidSummary[] {\n  return letterValues(data).map(({ depth, mid, spread }) => ({ depth, mid, spread }));\n}\n\n// =============================================================================\n// Hybrid API — Distance Functions\n// =============================================================================\n\n/** Cosine similarity between two dense vectors. Returns [-1, 1]. */\nexport function cosineSimilarity(a: number[], b: number[]): number {\n  if (wasmInstance) return wasmInstance.cosineSim(new Float64Array(a), new Float64Array(b));\n  return tsCosineSimilarity(a, b);\n}\n\n/** Squared Euclidean distance (avoids sqrt). */\nexport function squaredEuclideanDistance(a: number[], b: number[]): number {\n  if (wasmInstance) return wasmInstance.sqEuclideanDist(new Float64Array(a), new Float64Array(b));\n  return tsSqEuclideanDistance(a, b);\n}\n\n/** Euclidean (L2) distance. */\nexport function euclideanDistance(a: number[], b: number[]): number {\n  if (wasmInstance) return wasmInstance.euclideanDist(new Float64Array(a), new Float64Array(b));\n  return tsEuclideanDistance(a, b);\n}\n\n/** Manhattan (L1) distance. */\nexport function manhattanDistance(a: number[], b: number[]): number {\n  if (wasmInstance) return wasmInstance.manhattanDist(new Float64Array(a), new Float64Array(b));\n  return tsManhattanDistance(a, b);\n}\n\n/** Mahalanobis distance (diagonal covariance). */\nexport function mahalanobisDistance(\n  point: number[],\n  means: number[],\n  variances: number[],\n  epsilon: number = 1e-8,\n): number {\n  if (wasmInstance) {\n    return wasmInstance.mahalanobisDist(\n      new Float64Array(point),\n      new Float64Array(means),\n      new Float64Array(variances),\n    );\n  }\n  return tsMahalanobisDistance(point, means, variances, epsilon);\n}\n\n/** L2-normalize a vector to unit length. */\nexport function normalizeL2(vector: number[]): number[] {\n  if (wasmInstance) return Array.from(wasmInstance.normalizeL2Vec(new Float64Array(vector)));\n  return tsNormalizeL2(vector);\n}\n\n/** Cosine similarity between two sparse vectors (Map<string, number>). */\nexport function cosineSimilaritySparse(\n  a: Map<string, number>,\n  b: Map<string, number>,\n): number {\n  if (a.size === 0 || b.size === 0) return 0;\n\n  let dot = 0, magA = 0, magB = 0;\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\n\n  for (const [key, val] of small) {\n    const other = large.get(key);\n    if (other !== undefined) dot += val * other;\n    magA += val * val;\n  }\n  for (const val of large.values()) magB += val * val;\n\n  const denom = Math.sqrt(magA) * Math.sqrt(magB);\n  return denom === 0 ? 0 : dot / denom;\n}\n\n/** Jaccard similarity: |A ∩ B| / |A ∪ B|. */\nexport function jaccardSimilarity<T>(a: Set<T>, b: Set<T>): number {\n  if (a.size === 0 || b.size === 0) return 0;\n  let intersection = 0;\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\n  for (const value of small) {\n    if (large.has(value)) intersection++;\n  }\n  const union = a.size + b.size - intersection;\n  return union <= 0 ? 0 : intersection / union;\n}\n\n/** Overlap coefficient: |A ∩ B| / min(|A|, |B|). */\nexport function overlapCoefficient<T>(a: Set<T>, b: Set<T>): number {\n  if (a.size === 0 || b.size === 0) return 0;\n  let intersection = 0;\n  const [small, large] = a.size <= b.size ? [a, b] : [b, a];\n  for (const value of small) {\n    if (large.has(value)) intersection++;\n  }\n  const minSize = Math.min(a.size, b.size);\n  return minSize <= 0 ? 0 : intersection / minSize;\n}\n\n// =============================================================================\n// Full Analysis\n// =============================================================================\n\n/**\n * Complete statistical analysis of a dataset.\n * Returns a SeriesDescription-compatible result with implementation info.\n */\nexport function analyze(data: number[]): AnalysisResult {\n  const s = sorted(data);\n  const ext: [number, number] = s.length ? [s[0], s[s.length - 1]] : [NaN, NaN];\n  const med = median(data);\n  const h = hinges(data);\n  const iqrVal = tsIqr(h);\n  const f = fences(data);\n  const of = outerFences(data);\n\n  return {\n    original: data,\n    summary: {\n      median: med,\n      mean: mean(data),\n      mode: mode(data),\n      hinges: h,\n      adjacent: tsAdjacent(s, f),\n      outliers: tsOutliers(s, f),\n      outer: of,\n      outside: tsOutside(s, of),\n      inside: tsInside(s, f),\n      extremes: ext,\n      iqr: iqrVal,\n      fences: f,\n    },\n    smooths: {\n      smooth: smooth(data),\n      hanning: hanning(data),\n    },\n    transforms: {\n      logs: logs(data),\n      roots: roots(data),\n      inverse: inverse(data),\n    },\n    counts: counts(data),\n    sorted: s,\n    ranked: ranked(data),\n    binned: binned(data),\n    implementation: wasmInstance ? 'wasm' : 'typescript',\n  };\n}\n"],"mappings":"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","names":["sorted","ranked","binned"]}