{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @twokeys/wasm - WASM implementation with TypeScript fallback\n *\n * Automatically uses WASM when available, falls back to TypeScript implementation.\n */\n\n// Import types\nimport type {\n  MedianResult,\n  ModeResult,\n  RankedResult,\n  BinnedResult,\n} from '@buley/twokeys-types';\n\n// TypeScript fallback implementations\n// These are inlined for zero-dependency fallback\n\nfunction tsSorted(arr: number[]): number[] {\n  return [...arr].sort((a, b) => a - b);\n}\n\nfunction tsMean(arr: number[]): number {\n  if (!arr.length) return NaN;\n  let sum = 0;\n  for (const n of arr) sum += n;\n  return sum / arr.length;\n}\n\nfunction tsMedian(sorted: number[]): number {\n  const len = sorted.length;\n  if (!len) return NaN;\n  if (len === 1) return sorted[0];\n  const mid = Math.floor(len / 2);\n  return len % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];\n}\n\nfunction tsMedianDepth(length: number, offset: number = 0): number {\n  if (!length) return NaN;\n  return offset + (length + 1) / 2;\n}\n\nfunction tsMode(data: number[]): ModeResult {\n  if (!data.length) return { count: 0, data: [] };\n  const freq = new Map<number, number>();\n  let maxCount = 0;\n  for (const val of data) {\n    const count = (freq.get(val) || 0) + 1;\n    freq.set(val, count);\n    if (count > maxCount) maxCount = count;\n  }\n  const modes: number[] = [];\n  for (const [val, count] of freq) {\n    if (count === maxCount) modes.push(val);\n  }\n  return { count: maxCount, data: modes.sort((a, b) => a - b) };\n}\n\nfunction tsExtremes(sorted: number[]): [number, number] {\n  if (!sorted.length) return [NaN, NaN];\n  return [sorted[0], sorted[sorted.length - 1]];\n}\n\nfunction tsHinges(sorted: number[]): MedianResult[] {\n  const len = sorted.length;\n  if (len < 4) return [];\n  const per = Math.floor(len / 2);\n  const q1Slice = sorted.slice(0, per);\n  const q3Slice = sorted.slice(per);\n  return [\n    { datum: tsMedian(q1Slice), depth: tsMedianDepth(per, 0) },\n    { datum: tsMedian(q3Slice), depth: tsMedianDepth(q3Slice.length, per) },\n  ];\n}\n\nfunction tsIqr(hinges: MedianResult[]): number {\n  if (hinges.length < 2) return NaN;\n  return Math.abs(hinges[1].datum - hinges[0].datum);\n}\n\nfunction tsFences(median: number, iqr: number, multiple: number = 1.5): [number, number] {\n  if (isNaN(median) || isNaN(iqr)) return [NaN, NaN];\n  const extra = iqr * multiple;\n  return [median - extra, median + extra];\n}\n\nfunction tsOuterFences(median: number, iqr: number, multiple: number = 1.5): [number, number] {\n  if (isNaN(median) || isNaN(iqr)) return [NaN, NaN];\n  const extra = 2 * iqr * multiple;\n  return [median - extra, median + extra];\n}\n\nfunction tsOutliers(sorted: number[], fences: [number, number]): number[] {\n  if (isNaN(fences[0]) || isNaN(fences[1])) return [];\n  return sorted.filter((n) => n < fences[0] || n > fences[1]);\n}\n\nfunction tsLogs(arr: number[]): number[] {\n  return arr.map((n) => Math.log(n));\n}\n\nfunction tsRoots(arr: number[]): number[] {\n  return arr.map((n) => Math.sqrt(n));\n}\n\nfunction tsInverse(arr: number[]): number[] {\n  return arr.map((n) => 1 / n);\n}\n\nfunction tsHanning(arr: number[]): number[] {\n  if (arr.length < 2) return [...arr];\n  const result: number[] = [arr[0]];\n  for (let i = 1; i < arr.length - 1; i++) {\n    result.push((arr[i] + arr[i + 1]) / 2);\n  }\n  result.push(arr[arr.length - 1]);\n  return result;\n}\n\nfunction tsSmoothMedian(arr: number[]): number[] {\n  if (arr.length <= 2) return [...arr];\n  const result = new Array<number>(arr.length);\n  result[0] = arr[0];\n  result[arr.length - 1] = arr[arr.length - 1];\n  for (let i = 1; i < arr.length - 1; i++) {\n    result[i] = Math.min(Math.max(arr[i - 1], arr[i]), arr[i + 1]);\n  }\n  return result;\n}\n\nfunction tsSmoothExtremes(arr: number[]): number[] {\n  if (arr.length <= 2) return [...arr];\n  const result = [...arr];\n  // Head\n  const tmpHead = arr[1] - 2 * (arr[2] - arr[1]);\n  const candidates = [arr[0], arr[1], tmpHead].sort((a, b) => a - b);\n  result[0] = candidates[1];\n  // Tail\n  const tmpTail = arr[arr.length - 2] - 2 * (arr[arr.length - 3] - arr[arr.length - 2]);\n  const tailCandidates = [arr[arr.length - 1], arr[arr.length - 2], tmpTail].sort((a, b) => a - b);\n  result[arr.length - 1] = tailCandidates[1];\n  return result;\n}\n\nfunction tsSmooth(arr: number[]): number[] {\n  let result = [...arr];\n  // 3 median passes\n  for (let i = 0; i < 3; i++) result = tsSmoothMedian(result);\n  result = tsSmoothExtremes(result);\n  // 3 more median passes\n  for (let i = 0; i < 3; i++) result = tsSmoothMedian(result);\n  result = tsSmoothExtremes(result);\n  // Final median passes\n  for (let i = 0; i < 3; i++) result = tsSmoothMedian(result);\n  return result;\n}\n\n// =============================================================================\n// WASM Loading\n// =============================================================================\n\ninterface WasmExports {\n  sort: (data: Float64Array) => Float64Array;\n  mean: (data: Float64Array) => number;\n  median: (data: Float64Array) => number;\n  medianSorted: (sorted: Float64Array) => number;\n  medianDepth: (length: number, offset?: number) => number;\n  mode: (data: Float64Array) => Float64Array;\n  extremes: (data: Float64Array) => Float64Array;\n  extremesSorted: (sorted: Float64Array) => Float64Array;\n  hingesSorted: (sorted: Float64Array) => Float64Array;\n  iqrFromHinges: (hinges: Float64Array) => number;\n  fences: (median: number, iqr: number, multiple?: number) => Float64Array;\n  outerFences: (median: number, iqr: number, multiple?: number) => Float64Array;\n  outliers: (sorted: Float64Array, fenceLow: number, fenceHigh: number) => Float64Array;\n  logs: (data: Float64Array) => Float64Array;\n  roots: (data: Float64Array) => Float64Array;\n  inverse: (data: Float64Array) => Float64Array;\n  hanning: (data: Float64Array) => Float64Array;\n  smooth: (data: Float64Array) => Float64Array;\n}\n\nlet wasmInstance: WasmExports | null = null;\nlet wasmLoadPromise: Promise<WasmExports | null> | null = null;\n\n/**\n * Load WASM module\n * @returns Promise that resolves to WASM exports or null if failed\n */\nexport async function loadWasm(): Promise<WasmExports | null> {\n  if (wasmInstance) return wasmInstance;\n  if (wasmLoadPromise) return wasmLoadPromise;\n\n  wasmLoadPromise = (async () => {\n    try {\n      // Try to load the WASM module\n      const wasmUrl = new URL('../build/release.wasm', import.meta.url);\n      const response = await fetch(wasmUrl);\n      const wasmBuffer = await response.arrayBuffer();\n      const wasmModule = await WebAssembly.instantiate(wasmBuffer);\n      wasmInstance = wasmModule.instance.exports as unknown as WasmExports;\n      return wasmInstance;\n    } catch (e) {\n      console.warn('@buley/twokeys-wasm: WASM not available, using TypeScript fallback');\n      return null;\n    }\n  })();\n\n  return wasmLoadPromise;\n}\n\n/**\n * Check if WASM is loaded and available\n */\nexport function isWasmLoaded(): boolean {\n  return wasmInstance !== null;\n}\n\n// =============================================================================\n// Hybrid API (WASM with TS fallback)\n// =============================================================================\n\n/**\n * Sort array (ascending)\n */\nexport function sorted(data: number[]): number[] {\n  if (wasmInstance) {\n    const input = new Float64Array(data);\n    const result = wasmInstance.sort(input);\n    return Array.from(result);\n  }\n  return tsSorted(data);\n}\n\n/**\n * Calculate arithmetic mean\n */\nexport function mean(data: number[]): number {\n  if (wasmInstance) {\n    return wasmInstance.mean(new Float64Array(data));\n  }\n  return tsMean(data);\n}\n\n/**\n * Calculate median\n */\nexport function median(data: number[]): MedianResult {\n  const sortedData = sorted(data);\n  const datum = wasmInstance\n    ? wasmInstance.medianSorted(new Float64Array(sortedData))\n    : tsMedian(sortedData);\n  const depth = wasmInstance\n    ? wasmInstance.medianDepth(data.length)\n    : tsMedianDepth(data.length);\n  return { datum, depth };\n}\n\n/**\n * Calculate mode\n */\nexport function mode(data: number[]): ModeResult {\n  if (wasmInstance) {\n    const result = wasmInstance.mode(new Float64Array(data));\n    const count = result[0];\n    const modes = Array.from(result.slice(1));\n    return { count, data: modes };\n  }\n  return tsMode(data);\n}\n\n/**\n * Get extremes [min, max]\n */\nexport function extremes(data: number[]): [number, number] {\n  if (wasmInstance) {\n    const result = wasmInstance.extremes(new Float64Array(data));\n    return [result[0], result[1]];\n  }\n  const sortedData = tsSorted(data);\n  return tsExtremes(sortedData);\n}\n\n/**\n * Calculate hinges (quartiles)\n */\nexport function hinges(data: number[]): MedianResult[] {\n  const sortedData = sorted(data);\n  if (wasmInstance) {\n    const result = wasmInstance.hingesSorted(new Float64Array(sortedData));\n    if (isNaN(result[0])) return [];\n    return [\n      { datum: result[0], depth: result[1] },\n      { datum: result[2], depth: result[3] },\n    ];\n  }\n  return tsHinges(sortedData);\n}\n\n/**\n * Calculate IQR\n */\nexport function iqr(data: number[]): number {\n  const h = hinges(data);\n  return tsIqr(h);\n}\n\n/**\n * Calculate fences (inner: 1.5 * IQR)\n */\nexport function fences(data: number[], multiple: number = 1.5): [number, number] {\n  const sortedData = sorted(data);\n  const med = wasmInstance\n    ? wasmInstance.medianSorted(new Float64Array(sortedData))\n    : tsMedian(sortedData);\n  const h = hinges(data);\n  const iqrVal = tsIqr(h);\n  if (wasmInstance) {\n    const result = wasmInstance.fences(med, iqrVal, multiple);\n    return [result[0], result[1]];\n  }\n  return tsFences(med, iqrVal, multiple);\n}\n\n/**\n * Calculate outer fences (3 * IQR)\n */\nexport function outerFences(data: number[], multiple: number = 1.5): [number, number] {\n  const sortedData = sorted(data);\n  const med = wasmInstance\n    ? wasmInstance.medianSorted(new Float64Array(sortedData))\n    : tsMedian(sortedData);\n  const h = hinges(data);\n  const iqrVal = tsIqr(h);\n  if (wasmInstance) {\n    const result = wasmInstance.outerFences(med, iqrVal, multiple);\n    return [result[0], result[1]];\n  }\n  return tsOuterFences(med, iqrVal, multiple);\n}\n\n/**\n * Find outliers\n */\nexport function outliers(data: number[], multiple: number = 1.5): number[] {\n  const sortedData = sorted(data);\n  const f = fences(data, multiple);\n  if (wasmInstance) {\n    const result = wasmInstance.outliers(new Float64Array(sortedData), f[0], f[1]);\n    return Array.from(result);\n  }\n  return tsOutliers(sortedData, f);\n}\n\n/**\n * Natural logarithm transform\n */\nexport function logs(data: number[]): number[] {\n  if (wasmInstance) {\n    const result = wasmInstance.logs(new Float64Array(data));\n    return Array.from(result);\n  }\n  return tsLogs(data);\n}\n\n/**\n * Square root transform\n */\nexport function roots(data: number[]): number[] {\n  if (wasmInstance) {\n    const result = wasmInstance.roots(new Float64Array(data));\n    return Array.from(result);\n  }\n  return tsRoots(data);\n}\n\n/**\n * Inverse (1/x) transform\n */\nexport function inverse(data: number[]): number[] {\n  if (wasmInstance) {\n    const result = wasmInstance.inverse(new Float64Array(data));\n    return Array.from(result);\n  }\n  return tsInverse(data);\n}\n\n/**\n * Hanning filter\n */\nexport function hanning(data: number[]): number[] {\n  if (wasmInstance) {\n    const result = wasmInstance.hanning(new Float64Array(data));\n    return Array.from(result);\n  }\n  return tsHanning(data);\n}\n\n/**\n * Tukey's 3RSSH smoothing\n */\nexport function smooth(data: number[]): number[] {\n  if (wasmInstance) {\n    const result = wasmInstance.smooth(new Float64Array(data));\n    return Array.from(result);\n  }\n  return tsSmooth(data);\n}\n\n// =============================================================================\n// Full Analysis (like Series.describe())\n// =============================================================================\n\nexport interface AnalysisResult {\n  sorted: number[];\n  summary: {\n    median: MedianResult;\n    mean: number;\n    mode: ModeResult;\n    extremes: [number, number];\n    hinges: MedianResult[];\n    iqr: number;\n    fences: [number, number];\n    outliers: number[];\n  };\n  transforms: {\n    logs: number[];\n    roots: number[];\n    inverse: number[];\n  };\n  smooths: {\n    hanning: number[];\n    smooth: number[];\n  };\n  implementation: 'wasm' | 'typescript';\n}\n\n/**\n * Full statistical analysis\n */\nexport function analyze(data: number[]): AnalysisResult {\n  const sortedData = sorted(data);\n  const med = median(data);\n  const m = mean(data);\n  const mo = mode(data);\n  const ext = extremes(data);\n  const h = hinges(data);\n  const iqrVal = iqr(data);\n  const f = fences(data);\n  const out = outliers(data);\n\n  return {\n    sorted: sortedData,\n    summary: {\n      median: med,\n      mean: m,\n      mode: mo,\n      extremes: ext,\n      hinges: h,\n      iqr: iqrVal,\n      fences: f,\n      outliers: out,\n    },\n    transforms: {\n      logs: logs(data),\n      roots: roots(data),\n      inverse: inverse(data),\n    },\n    smooths: {\n      hanning: hanning(data),\n      smooth: smooth(data),\n    },\n    implementation: wasmInstance ? 'wasm' : 'typescript',\n  };\n}\n"],"mappings":"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","names":["sorted","hinges","median","iqr","fences"]}